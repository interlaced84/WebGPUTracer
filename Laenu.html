// Iteration: 1 - Sphere selection and real-time property editing (UI functional, GPU updated).
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Raytracer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #1a1a2e; /* Dark background */
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        /* View management */
        #app-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; /* For absolute positioning of views */
        }
        .view {
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.5s ease-in-out; /* Faster transition for general views */
        }
        .view.active {
            display: flex;
            opacity: 1;
        }

        /* Specific view layouts */
        #menu-view {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: #1a1a2e;
            z-index: 10;
        }
        #scene-view {
            justify-content: center;
            align-items: center;
            background-color: #0d0d1e;
            z-index: 5;
        }
        #loading-view {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #1a1a2e;
            z-index: 15; /* Highest z-index to overlay everything during loading */
            text-align: center;
        }

        /* Canvas */
        canvas {
            display: block;
            background-color: #0d0d1e; /* Darker background for canvas */
            width: 100%; /* Take full width of parent */
            height: 100%; /* Take full height of parent */
            cursor: grab; /* Cursor for camera control */
        }
        canvas:active {
            cursor: grabbing;
        }
        /* UI Components - Tailwind based */
        .button-primary {
            @apply px-8 py-4 m-4 text-lg font-semibold text-white bg-indigo-600 rounded-lg shadow-lg hover:bg-indigo-700 transition-all duration-300 transform hover:scale-105 border-2 border-indigo-500;
        }
        .button-secondary {
            @apply px-6 py-3 m-2 text-md font-medium text-indigo-200 bg-gray-800 rounded-md shadow-md hover:bg-gray-700 transition-all duration-300 transform hover:scale-105 border-2 border-gray-700;
        }
        .panel {
            @apply bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-700 max-w-xl w-full;
        }
        .input-range {
            @apply w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer;
            -webkit-appearance: none; /* Override default appearance */
        }
        .input-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5; /* Tailwind indigo-600 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.4); /* Focus ring effect */
        }
        .input-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.4);
        }

        /* Specific UI element styling */
        #menu-view h1 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #4CAF50; /* A nice green for the title */
        }
        #menu-view p {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        #settings-panel {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(20px);
            max-width: 700px; /* Use max-width directly */
        }
        #settings-panel.active {
            opacity: 1;
            pointer-events: all;
            transform: translateY(0);
        }
        #settings-panel h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        #settings-panel label {
            display: block;
            margin-bottom: 5px;
            text-align: left;
            font-weight: 600;
        }
        #settings-panel select {
            @apply w-full p-3 rounded-md bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500;
        }

        /* Loading view specific styles */
        #loading-view .spinner {
            animation: spin 1s linear infinite;
            border-top-color: #6366f1; /* Tailwind indigo-500 */
            border-right-color: transparent;
            border-bottom-color: #6366f1;
            border-left-color: transparent;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-view p {
            margin-top: 20px;
            font-size: 1.2em;
            color: #a0a0a0;
        }
        /* Scene view UI */
        #fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #0f0;
            z-index: 20;
            font-family: monospace;
            display: none; /* Hidden by default, activated when scene is active */
        }
        #back-to-main-menu-from-scene {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 20;
        }
        /* Error Display */
        #error-message-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ef4444; /* Tailwind red-500 */
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10000; /* Very high to ensure visibility */
            display: none; /* Hidden by default */
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #error-message-display.active {
            display: block;
            opacity: 1;
        }
        /* Collapsible sections for scene controls */
        #scene-controls-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: #e0e0e0;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transition: width 0.3s ease;
            width: 300px; /* Default width */
            z-index: 1000; /* Ensure panel is above canvas */
            display: none; /* Hidden by default */
        }
        #scene-controls-panel.active {
            display: block;
        }
        #toggle-panel-button {
            background: none;
            border: none;
            color: #00ffff;
            font-size: 24px;
            cursor: pointer;
            position: absolute;
            top: 5px;
            left: 5px;
            line-height: 20px;
        }
        #scene-controls-panel.collapsed {
            width: 40px;
            overflow: hidden;
        }
        #scene-controls-panel.collapsed #toggle-panel-button {
            left: auto; /* reset left property to allow automatic positioning */
            right: 5px; /* Adjust button position when collapsed */
            transform: scaleX(-1); /* Flip caret horizontally */
        }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-weight: bold; color: #00ffff; }
        .control-group input[type="range"] { width: 100%; -webkit-appearance: none; appearance: none; height: 8px; background: #555; border-radius: 512px; outline: none; }
        .control-group input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00ffff; cursor: pointer; border: 2px solid #fff; }
        .control-group input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00ffff; cursor: pointer; border: 2px solid #fff; }
        .current-value { float: right; font-weight: normal; color: #e0e0e0; }
        #scene-controls-panel h2 { color: #00ffff; border-bottom: 2px solid #00ffff; padding-bottom: 5px; margin-top: 0; }
        .github-link {
            display: block;
            margin-top: 20px;
            text-align: center;
        }
        .github-link a {
            color: #00ffff;
            text-decoration: none;
            font-weight: bold;
        }
        .github-link a:hover {
            text-decoration: underline;
        }
        details {
            margin-bottom: 10px;
            border: 1px solid #0056b3;
            border-radius: 5px;
        }
        summary {
            background-color: #007bff;
            color: white;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        summary:hover {
            background-color: #0056b3;
        }
        details[open] summary {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        .details-content {
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-top: 1px solid #0056b3;
        }
        .button-group {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            margin-bottom: 15px;
        }
        .button-group button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        .button-group button:hover {
            background-color: #0056b3;
        }
        .button-group button.active {
            background-color: #00c0ff;
            box-shadow: 0 0 8px rgba(0, 192, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Main Menu View -->
        <div id="menu-view" class="view active">
            <div class="panel">
                <h1 class="text-4xl font-bold mb-6 text-indigo-300">WebGPU Raytracer</h1>
                <p class="mb-8 text-lg text-gray-300">Experience physically-based rendering on your GPU.</p>
                <button id="start-button" class="button-primary">Start Raytracing</button>
                <button id="settings-button" class="button-primary">Settings</button>
            </div>
            <!-- Settings Panel (hidden initially) -->
            <div id="settings-panel" class="panel absolute opacity-0 pointer-events-none transition-all duration-500 scale-95" style="transform: translateY(20px);">
                <h2 class="text-3xl font-bold mb-6 text-indigo-300">Settings</h2>
                <div class="mb-6">
                    <label for="quality-preset" class="block text-gray-300 text-left mb-2">Quality Preset:</label>
                    <select id="quality-preset" class="w-full p-3 rounded-md bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="low">Low (Fewer Samples, Less Bounces)</option>
                        <option value="medium" selected>Medium (Balanced)</option>
                        <option value="high">High (More Samples, More Bounces)</option>
                    </select>
                </div>
                <div class="mb-6">
                    <label for="num-spheres" class="block text-gray-300 text-left mb-2">Number of Spheres: <span id="num-spheres-value">5</span></label>
                    <input type="range" id="num-spheres" min="1" max="100" value="5" class="input-range">
                </div>
                 <div class="mb-6">
                    <label for="max-bounces" class="block text-gray-300 text-left mb-2">Max Bounces: <span id="max-bounces-value">2</span></label>
                    <input type="range" id="max-bounces" min="1" max="10" value="2" class="input-range">
                </div>
                <div class="mb-6">
                    <label for="samples-per-pixel" class="block text-gray-300 text-left mb-2">Samples per Pixel: <span id="samples-per-pixel-value">4</span></label>
                    <input type="range" id="samples-per-pixel" min="1" max="64" value="4" class="input-range">
                </div>
                <button id="apply-settings-button" class="button-primary">Apply & Start</button>
                <button id="back-to-menu-button" class="button-secondary mt-4">Back to Main Menu</button>
            </div>
        </div>
        <!-- Loading View -->
        <div id="loading-view" class="view">
            <div class="text-center">
                <div class="spinner rounded-full h-16 w-16 border-t-4 border-b-4 border-indigo-500 mb-4 mx-auto"></div>
                <p id="loading-status" class="text-xl text-gray-300">Initializing WebGPU and compiling shaders...</p>
            </div>
        </div>
        <!-- Scene View (contains canvas and scene-specific UI) -->
        <div id="scene-view" class="view">
            <canvas id="webgpu-canvas"></canvas>
            <div id="fps-counter" class="fps-counter">FPS: --</div>
            <button id="back-to-main-menu-from-scene" class="button-secondary absolute bottom-8 right-8">Back to Menu</button>
            <!-- Scene Controls Panel -->
            <div id="scene-controls-panel">
                <button id="toggle-panel-button">&lt;</button>
                <h2>Raytracer Controls</h2>
                <details open>
                    <summary>Camera & Scene</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="sphereCountSlider">Number of Spheres: <span id="sphereCountValue" class="current-value">1</span></label>
                            <input type="range" id="sphereCountSlider" min="1" max="100" value="1">
                        </div>
                        <div class="control-group">
                            <label for="warpStrengthSlider">Domain Warp Strength: <span id="warpStrengthValue" class="current-value">0.0</span></label>
                            <input type="range" id="warpStrengthSlider" min="0.0" max="2.0" step="0.01" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="focalDistanceSlider">Focal Distance: <span id="focalDistanceValue" class="current-value">10.0</span></label>
                            <input type="range" id="focalDistanceSlider" min="0.1" max="50.0" step="0.1" value="10.0">
                        </div>
                        <div class="control-group">
                            <label for="apertureSizeSlider">Aperture Size: <span id="apertureSizeValue" class="current-value">0.00</span></label>
                            <input type="range" id="apertureSizeSlider" min="0.0" max="1.0" step="0.01" value="0.00">
                        </div>
                        <div class="control-group">
                            <label>Sky Preset:</label>
                            <div class="button-group">
                                <button id="sunnyDayButton" class="active">Sunny Day</button>
                                <button id="duskButton">Dusk</button>
                            </div>
                        </div>
                    </div>
                </details>
                <details open>
                    <summary>Sun</summary> <!-- Renamed from Lighting -->
                    <div class="details-content">
                        <div class="control-group">
                            <label for="lightXSlider">Light X: <span id="lightXValue" class="current-value">0.0</span></label>
                            <input type="range" id="lightXSlider" min="-10.0" max="10.0" step="0.1" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="lightYSlider">Light Y: <span id="lightYValue" class="current-value">10.0</span></label>
                            <input type="range" id="lightYSlider" min="0.1" max="20.0" step="0.1" value="10.0">
                        </div>
                        <div class="control-group">
                            <label for="lightZSlider">Light Z: <span id="lightZValue" class="current-value">2.8</span></label>
                            <input type="range" id="lightZSlider" min="-10.0" max="10.0" step="0.1" value="2.8">
                        </div>
                        <div class="control-group">
                            <label for="lightBrightnessSlider">Light Brightness: <span id="lightBrightnessValue" class="current-value">1.0</span></label>
                            <input type="range" id="lightBrightnessSlider" min="0.1" max="5.0" step="0.1" value="1.0">
                        </div>
                        <div class="control-group">
                            <label for="lightSizeSlider">Light Size: <span id="lightSizeValue" class="current-value">0.4</span></label>
                            <input type="range" id="lightSizeSlider" min="0.0" max="5.0" step="0.1" value="0.4">
                        </div>
                        <!-- New Sun Color/Hue Slider -->
                        <div class="control-group">
                            <label for="sunHueSlider">Sun Color/Hue: <span id="sunHueValue" class="current-value">0.00</span></label>
                            <input type="range" id="sunHueSlider" min="0" max="1" step="0.01" value="0">
                        </div>
                    </div>
                </details>
                <details>
                    <summary>Water</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="waveStrengthSlider">Wave Strength: <span id="waveStrengthValue" class="current-value">0.24</span></label>
                            <input type="range" id="waveStrengthSlider" min="0.005" max="0.5" step="0.005" value="0.24">
                        </div>
                        <div class="control-group">
                            <label for="waveFrequencySlider">Wave Frequency: <span id="waveFrequencyValue" class="current-value">0.5</span></label>
                            <input type="range" id="waveFrequencySlider" min="0.5" max="20.0" step="0.1" value="0.5">
                        </div>
                        <div class="control-group">
                            <label for="waveSpeedSlider">Wave Speed: <span id="waveSpeedValue" class="current-value">0.01</span></label>
                            <input type="range" id="waveSpeedSlider" min="0.01" max="2.0" step="0.01" value="0.01">
                        </div>
                        <div class="control-group">
                            <label for="refractiveIndexSlider">Refractive Index: <span id="refractiveIndexValue" class="current-value">1.3</span></label>
                            <input type="range" id="refractiveIndexSlider" min="1.0" max="2.0" step="0.01" value="1.50">
                        </div>
                    </div>
                </details>
                <details>
                    <summary>Terrain</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="terrainHeightSlider">Terrain Height: <span id="terrainHeightValue" class="current-value">0.0</span></label>
                            <input type="range" id="terrainHeightSlider" min="0.0" max="20.0" step="0.1" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="terrainFrequencySlider">Terrain Frequency: <span id="terrainFrequencyValue" class="current-value">0.15</span></label>
                            <input type="range" id="terrainFrequencySlider" min="0.01" max="1.0" step="0.01" value="0.15">
                        </div>
                    </div>
                </details>
                <details open>
                    <summary>Raytracing Settings</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="bouncesSlider">Max Bounces: <span id="bouncesValue" class="current-value">2</span></label>
                            <input type="range" id="bouncesSlider" min="1" max="10" step="1" value="2">
                        </div>
                        <div class="control-group">
                            <label for="raymarchStepsSlider">Max Raymarch Steps: <span id="raymarchStepsValue" class="current-value">150</span></label>
                            <input type="range" id="raymarchStepsSlider" min="100" max="1000" step="50" value="150">
                        </div>
                        <div class="control-group">
                            <label for="shadowSamplesSlider">Shadow Samples: <span id="shadowSamplesValue" class="current-value">2</span></label>
                            <input type="range" id="shadowSamplesSlider" min="1" max="32" step="1" value="2">
                        </div>
                        <div class="control-group">
                            <label for="dofSamplesSlider">DOF Samples: <span id="dofSamplesValue" class="current-value">4</span></label>
                            <input type="range" id="dofSamplesSlider" min="1" max="32" step="1" value="4">
                        </div>
                    </div>
                </details>
                <div class="github-link">
                    <a href="https://github.com/your-repo-link" target="_blank">View on GitHub</a>
                </div>

                <div id="selected-sphere-controls" style="display: none; margin-top: 20px; border-top: 1px solid #4a5568; padding-top: 15px;">
                    <h3 style="color: #00ffff; font-weight: bold; margin-bottom: 10px;">Selected Sphere (-1)</h3>
                    <div class="control-group">
                        <label for="selected-albedo-color">Albedo: </label>
                        <input type="color" id="selected-albedo-color" value="#ffffff" style="width: 100%; height: 30px; padding: 2px;">
                    </div>
                    <div class="control-group">
                        <label for="selected-radius-slider">Radius: <span id="selected-radius-value" class="current-value">1.0</span></label>
                        <input type="range" id="selected-radius-slider" min="0.1" max="10.0" step="0.1" value="1.0" class="input-range">
                    </div>
                    <div class="control-group">
                        <label for="selected-metallic-slider">Metallic: <span id="selected-metallic-value" class="current-value">0.0</span></label>
                        <input type="range" id="selected-metallic-slider" min="0.0" max="1.0" step="0.01" value="0.0" class="input-range">
                    </div>
                    <div class="control-group">
                        <label for="selected-roughness-slider">Roughness: <span id="selected-roughness-value" class="current-value">0.5</span></label>
                        <input type="range" id="selected-roughness-slider" min="0.0" max="1.0" step="0.01" value="0.5" class="input-range">
                    </div>
                    <div class="control-group">
                        <label for="selected-reflectivity-slider">Reflectivity (F0): <span id="selected-reflectivity-value" class="current-value">0.04</span></label>
                        <input type="range" id="selected-reflectivity-slider" min="0.0" max="1.0" step="0.01" value="0.04" class="input-range">
                    </div>
                    <div class="control-group">
                        <label for="selected-material-type">Material Type:</label>
                        <select id="selected-material-type" class="w-full p-2 rounded-md bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" style="color: white; background-color: #2d3748;">
                            <option value="0">Diffuse</option>
                            <option value="1">Reflective</option>
                            <option value="2">Refractive</option>
                        </select>
                    </div>
                    <div id="selected-refractive-index-control-group" class="control-group" style="display: none;"> {/* Initially hidden */}
                        <label for="selected-refractive-index-slider">Refractive Index: <span id="selected-refractive-index-value" class="current-value">1.5</span></label>
                        <input type="range" id="selected-refractive-index-slider" min="1.0" max="2.5" step="0.01" value="1.5" class="input-range">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="error-message-display" class="error-message"></div>
    <script type="text/javascript">
        // --- IMPORTANT: Core Directives & Troubleshooting Log References ---
        // This section ensures adherence to the core development principles and leverages
        // our historical knowledge base for robust, high-quality code.
        //
        // Document: 'My Core Directives' (ID: 'my-core-directives')
        // This document contains the fundamental principles and quality standards for all development.
        //
        // Document: 'My Troubleshooting Methodology' (ID: 'troubleshooting-log')
        // This document serves as the comprehensive history and detailed solutions for all encountered issues.
        // It should be consulted for in-depth understanding of recurring problems.
        //
        // Document: 'WebGPU Troubleshooting Resources' (ID: 'webgpu-troubleshooting-resources')
        // This document collects external resources, tools, and general tips for debugging WebGPU applications.
        //
        // --- End References & Checks ---
        //
        // Troubleshooting Log (In-Code Summary):
        // Last modified by AI: 2024-07-15 12:05:00 UTC
        // This section provides a brief summary of the most recent and relevant troubleshooting steps directly related to this file.
        // For the complete and detailed troubleshooting history, refer to the 'My Troubleshooting Methodology' document (ID: 'troubleshooting-log').
        //
        // - Current Step (June 17, 2025): Addressing persistent `textureLoad` and sampler/texture type errors.
        //   - **CRITICAL REMINDER (Persistent WGSL Array/Type Bugs):** Always ensure `u` suffix for `u32` integer literals (e.g., `1u`, `0u`) and explicit `f` suffix for `f32` literals (e.g., `0.0f`). When initializing arrays, use the `array<Type, Size>(...)` constructor with correctly typed elements.
        //   - Confirmed `textureLoad(inputTexture, vec2<i32>(global_id.xy), 0u)` in the compute shader, providing the mandatory mipmap level `0u`.
        //   - Confirmed `sampler: { type: 'non-filtering' }` for binding 0 in the render pipeline's bind group layout, matching the `unfilterable-float` `sampleType` of the `rgba32float` texture used for accumulation.
        //   - Confirmed `texture: { sampleType: 'unfilterable-float' }` for binding 1 (mainTexture) in the render pipeline's bind group layout.
        //   - Confirmed `texture: { sampleType: 'unfilterable-float' }` for binding 7 (inputTexture) in the compute pipeline's bind group layout.
        //   - Note on `rgba32float` as storage texture: While `rgba32float` does not support `read-write` access for storage textures without extensions, our ping-pong uses one `write-only` storage texture and one `read-only` texture (`texture_2d<f32>`), which is a valid usage.
        //
        // - Previous Step: Implemented Double Buffering (Ping-Pong Rendering) for accumulation.
        //   - Created two rgba32float textures (outputTexture0, outputTexture1) for ping-pong.
        //   - Modified compute shader to take both a read-only input texture (texture_2d<f32>) and a write-only output texture (texture_storage_2d<rgba32float, write>).
        //   - Swapped input/output textures dynamically per frame.
        //   - Adjusted accumulation blend factor in WGSL to use frameCount.
        // - Implemented 'unfilterable-float' sampleType for texture in render pipeline to correctly display rgba32float.
        //   - Changed outputSampler filter to 'nearest' for consistency.
        // - Retained all previous features (BVH, PBR, Perlin noise, etc.) and bug fixes.
        //
        // - Previous Step: Re-generated the complete fully-featured raytracer from conversation history.
        // - Implemented accumulation rendering by changing outputTexture format to rgba32float and adding textureLoad/textureStore accumulation logic in compute shader.
        // - Corrected CameraUniform buffer packing in JavaScript to precisely match WGSL struct (24 floats, 96 bytes) to fix "write range does not fit" error.
        // - Verified 'perm' and 'grad3' arrays in WGSL for correct size and u32 suffixes to ensure proper parsing.
        // - Kept `device.lost.then()` and `pushErrorScope`/`popErrorScope` for robust error handling as they provide valuable debugging info without crashing, overriding previous temporary omissions for system stability.
        //
        // - Previous Step: Implementing enhanced debugging for "30-second stall/CPU spike" by adding `device.lost.then()` handler and `device.pushErrorScope()`/`popErrorScope()` around command submission in `renderLoop` to catch GPU errors more effectively. This will help diagnose potential device loss or shader hangs.
        // - Previous Step: Fixed "unresolved value 'global_id'" error by passing `global_id.xy` as a `vec2<u32>` parameter to `calculateLighting` and `get_color_from_sub_hit` functions and updating all call sites within the shader. This ensures the random number generation per pixel is correctly handled.
        // - Previous Step: Addressed "A valid external Instance reference no longer exists" (device lost) after 30s stall by:
        //   1. Setting more conservative default values for `targetSphereCount` (5), `maxBounces` (2), and `samplesPerPixel` (4) to reduce initial GPU load.
        //   2. Enhanced loading status messages to provide more granular feedback during WebGPU initialization and BVH building.
        // - Previous Step: Fixed WGSL `perm` array initialization. The array was declared as size 512 but only initialized with 256 elements. Duplicated the initial 256 elements to properly fill the 512-element array.
        // - Previous Step: Fixed WGSL `SyntaxError: Unexpected identifier 'is_water_medium_flag'` by consistently using `u32` (0 or 1) for water medium flags in `calculateLighting`, `get_color_from_sub_hit`, and `traceRay` functions, and updating all call sites. This ensures robust type handling in WGSL.
        // - Previous Step: Regenerating the complete HTML code for 'my-project-code' immersive due to truncation in the previous response.
        // - Previous Step: Renamed boolean parameters `in_water_medium` (in `calculateLighting`) to `is_water_medium_flag` and `in_water_medium_param` (in `get_color_from_sub_hit`) to `is_sub_ray_in_water_medium_flag`. Also renamed local variable `is_current_medium_water` (in `traceRay`) to `is_in_water_medium_trace`. This addresses persistent "Unexpected identifier" errors often caused by subtle WGSL parsing quirks with boolean naming.
        // - Previous Step: Fixed logical error in WGSL shader's `snellsLaw` function (`incident` to `incident_dir`). Thoroughly re-verified WGSL function signatures for subtle syntax issues that could lead to "Unexpected identifier" compilation errors.
        // - Previous Step: Fixed WGSL shader error 'unresolved value 'is_in_current_medium_water'' by declaring `is_in_current_medium_water` at the beginning of `traceRay` and updating it as `current_ior` changes, ensuring it's always in scope.
        // - Previous Step: Fixed WGSL shader error 'cannot assign to 'let kD'' by changing 'let kD' to 'var kD' to make it mutable.
        // - Previous Step: Fixed WGSL shader error 'unresolved value globalWarpStrength' by moving global JS variables (like globalWarpStrength, skyPreset, camera.focalDistance, camera.apertureSize) into WGSL uniform structs (CameraUniform and RaytracerParams) and updating their JavaScript buffer allocation/write logic to match. This resolves UBO layout mismatches.
        // - Previous Step: Fixed WGSL parsing errors by replacing '.length()' calls on storage buffers with uniform parameters (`raytracerUBO.numBVHNodes` and `raytracerUBO.numPrimitives`). Corrected `lightUBOBuffer` size to 40 bytes (was 32 bytes) to match WGSL struct layout and resolve 'Write range does not fit' error. Ensured JavaScript updates these new uniform fields.
        // - Previous Step: Moved `resizeCanvasAndAssets()` call after pipeline creation in `initWebGPUAndCompileShaders()` to ensure pipelines are defined when bind groups are created. This addressed the "Skipping bind group creation: essential resources not ready" warning and potential black screen issues.
        // - Previous Step: Removed `device.onuncapturederror` and `device.pushErrorScope`/`popErrorScope` as these were found to cause GPU device loss on your specific system. This is crucial for stability.
        // - Previous Step: Implemented Sun Color/Hue control. Renamed "Lighting" menu to "Sun". Added a new slider for sun hue, converted hue to RGB in JS, and passed it to the WGSL shader.
        // - Previous Step: Reconstructed the full PBR-enabled raytracer with BVH into a single HTML file, integrating it with the new Main Menu and Scene Management system. This addresses the significant regression reported by the user.
        // - Previous Step: Implemented Physically-Based Rendering (PBR) into the WGSL compute shader, including GGX NDF, Schlick-GGX Geometry Function, and robust Fresnel integration, along with new material properties (metallic, roughness). Adjusted `populateInitialSpheres` and `updateGPUBuffers` for new material data layout.
        // - Previous Step: Performed self-improvement passes: Double-checked all buffer alignments/sizes, confirmed WGSL 'perm' and 'grad3' array correctness. Fixed an issue where the 'refractiveIndexSlider' would cause an error when updating sphere material properties by ensuring the correct CPU-side BVH data ('currentBvhResult') is passed to 'updateGPUBuffers' without rebuilding the BVH.
        // - Previous Step: Re-generated the full feature set of the raytracer (including Perlin, complex materials, camera controls, UI) and integrated the BVH data structures and traversal logic directly into a single HTML file. BVH construction is now performed on the main thread for single-file compatibility (potential temporary UI freeze for very high sphere counts).
        // - Previous Step: Corrected a critical error where the previous generation truncated the code, removing thousands of lines of features. This generation rectifies that by building upon the last full-featured version.
        // - Previous Step: Re-verified and meticulously re-typed the 'perm' and 'grad3' array initializations in WGSL. This addresses persistent "expected ')'" and "expected '"" parsing errors, which likely stemmed from subtle, hard-to-spot syntax issues or hidden characters that confused the WGSL parser.
        // - Previous Step: Fixed WGSL 'perm' array initialization syntax by explicitly using 'array<u32, 512>(...)' constructor, resolving 'expected )' parsing error.
        // - Previous Step: Fixed 'lastFrameTime' redeclaration error by removing 'let' inside renderLoop.
        // - Previous Step: Fixed WGSL 'perm' array initialization by ensuring all integer literals have 'u' suffix for u32 type and using the correct 256 base values, duplicated to 512. This resolves potential WGSL parsing errors that could manifest as array size issues.
        // - Previous Step: Performed micro-stepping syntax verification of the entire rendering pipeline. Applied 'u' suffix to all integer literals in WGSL 'perm' array for robust u32 parsing. Removed redundant 'init_perlin_tables()' function from WGSL as it was uncalled and array initialization is global. The code is highly robust and adheres to best practices derived from past troubleshooting.
        // - Previous Step: Refactored initializeWebGPU to align with compute-first architecture. Ensured all compute and render bind groups and vertex buffers are created and updated correctly. Added a max canvas dimension limit for stability.
        // - Previous Step: Major architectural change: Fully featured raytracer ported to a compute shader pipeline. All raytracing logic (SDFs, lighting, materials, reflections, refractions, soft shadows, DOF, domain warping, Perlin noise, skybox) moved to compute. A simple render pass then displays the computed texture. UI controls are re-integrated to update compute shader uniforms. This is the "go for broke" variant.
        // - Previous Step: Implemented optimizations for "trivial" issues: Bind groups are now created only once during initialization and recreated only on canvas resize. The 'onResize' handler now efficiently recreates only the necessary texture and bind groups, avoiding a full WebGPU re-initialization. This significantly improved stability and performance by reducing resource churn.
        // - Previous Step: Fixed WGSL parsing error: Removed 'var<storage, read_write>' from 'outputTexture' declaration in compute shader. 'texture_storage_2d' is a texture type, not a buffer, and doesn't belong in the 'storage' address space. Access mode ('write') is part of the texture type itself.
        // - Previous Step: Re-establishing the "Eureka" baseline: A minimal WebGPU setup using a compute shader to generate a color pattern into a texture, which is then rendered to the canvas by a basic render pipeline. This test confirmed that the fundamental components that previously worked are still functional.

        // Global WebGPU objects
        let device;
        let context;
        let computePipeline;
        let renderPipeline;
        let outputTexture0; // For ping-ponging
        let outputTexture1; // For ping-ponging
        let outputTextureView0;
        let outputTextureView1;
        let outputSampler;
        let computeBindGroup0; // For Camera, Light, RaytracerParams, Time, Water, Terrain, and ping-pong textures
        let computeBindGroup1; // For Spheres (storage buffer) and BVH (storage buffers)
        let renderBindGroup;
        let renderQuadVertexBuffer; // Vertex buffer for the full-screen quad

        // Uniform Buffer Objects (UBOs)
        let cameraUBOBuffer;
        let lightUBOBuffer;
        let timeUBOBuffer;
        let waterUBOBuffer;
        let terrainUBOBuffer;
        let raytracerUBOBuffer;

        // Pre-allocated TypedArrays for UBO data
        let cameraDataArray = new Float32Array(24); // 96 bytes
        let lightDataArray = new Float32Array(16);    // 64 bytes
        let timeDataArray = new Float32Array(4);      // 16 bytes
        let waterDataArray = new Float32Array(4);     // 16 bytes
        let terrainDataArray = new Float32Array(4);   // 16 bytes
        let raytracerDataArray = new Float32Array(12); // 48 bytes

        // BVH Storage Buffers
        let bvhNodesBuffer;
        let primitiveIndicesBuffer; // Stores the reordered indices of primitives (spheres)
        // Sphere Storage Buffer (still needed for material properties, etc.)
        let sphereDataBuffer;

        // Camera and scene variables
        const camera = {
            position: [0.0, 5.0, 20.0],
            rotationX: -0.05,
            rotationY: Math.PI,
            forward: [0, 0, -1],
            right: [1, 0, 0],
            up: [0, 1, 0],
            movementSpeed: 0.05,
            rotationSpeed: 0.005,
            fovy: Math.PI / 3,
            aspect: 0,
            near: 0.1,
            far: 100.0,
            focalDistance: 10.0,
            apertureSize: 0.00,
        };

        const light = {
            position: [0.0, 10.0, 2.8],
            brightness: 1.0,
            size: 0.4,
            color: [1.0, 1.0, 1.0] // Default to white
        };

        let sunHue = 0.0; // 0.0 to 1.0, representing 0-360 degrees

        // Sphere primitives data (JavaScript objects, will be transformed to Float32Array)
        let spheres = [];
        // Changed default settings for initial load to reduce GPU stress
        let targetSphereCount = 5;
        let lastSphereCount = targetSphereCount; // Track last count to prevent redundant BVH rebuilds

        // Global variable to store the last built BVH result on CPU side for reuse
        let currentBvhResult = { bvhNodes: [], primitiveIndices: [] };

        let waveStrength = 0.24;
        let waveFrequency = 0.5;
        let waveSpeed = 0.01;

        let globalRefractiveIndex = 1.50; // New global for refractive index control
        let globalWarpStrength = 0.0; // New global for domain warp
        let terrainHeightScale = 0.0;
        let terrainFrequency = 0.15;

        // Changed default settings for initial load to reduce GPU stress
        let maxBounces = 2;
        let maxRaymarchSteps = 150;
        // Changed default settings for initial load to reduce GPU stress
        let shadowSamples = 4;
        let dofSamples = 4; // Using same as shadowSamples for now

        const MATERIAL_DIFFUSE = 0;
        const MATERIAL_REFLECTIVE = 1;
        const MATERIAL_REFRACTIVE = 2;

        let skyPreset = 0; // 0 for sunny day, 1 for dusk

        // Input handling for scene camera
        const keysPressed = {};
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Performance tracking
        let frameCount = 0; // Accumulation frame count
        let lastFpsUpdateTime = 0;
        let fps = 0;
        let lastFrameTime = 0;
        let totalTime = 0;
        let animationFrameId; // To control requestAnimationFrame

        // Ping-pong texture tracking
        let currentTextureIndex = 0; // 0 for outputTexture0, 1 for outputTexture1
        let lastClickedRay = { origin: null, direction: null }; // For storing the last clicked ray

        // UI Elements (App State Management)
        let appState = 'menu'; // Initial state is the menu
        const appContainer = document.getElementById('app-container');
        const menuView = document.getElementById('menu-view');
        const loadingView = document.getElementById('loading-view');
        const sceneView = document.getElementById('scene-view');
        const settingsPanel = document.getElementById('settings-panel');
        const loadingStatusP = document.getElementById('loading-status');
        const errorMessageDisplay = document.getElementById('error-message-display');

        // Main Menu UI elements
        const startButton = document.getElementById('start-button');
        const settingsButton = document.getElementById('settings-button');
        const qualityPresetSelect = document.getElementById('quality-preset');
        const numSpheresRange = document.getElementById('num-spheres');
        const numSpheresValueSpan = document.getElementById('num-spheres-value');
        const maxBouncesRange = document.getElementById('max-bounces');
        const maxBouncesValueSpan = document.getElementById('max-bounces-value');
        const samplesPerPixelRange = document.getElementById('samples-per-pixel');
        const samplesPerPixelValueSpan = document.getElementById('samples-per-pixel-value');
        const applySettingsButton = document.getElementById('apply-settings-button');
        const backToMenuButton = document.getElementById('back-to-menu-button');
        const backToMainMenuFromSceneButton = document.getElementById('back-to-main-menu-from-scene');

        // Scene Controls UI elements
        const canvas = document.getElementById('webgpu-canvas'); // Needs to be accessible globally
        const sceneControlsPanel = document.getElementById('scene-controls-panel');
        const togglePanelButton = document.getElementById('toggle-panel-button');
        const sphereCountSlider = document.getElementById('sphereCountSlider');
        const sphereCountValue = document.getElementById('sphereCountValue');
        const lightXSlider = document.getElementById('lightXSlider');
        const lightYSlider = document.getElementById('lightYSlider');
        const lightZSlider = document.getElementById('lightZSlider');
        const lightBrightnessSlider = document.getElementById('lightBrightnessSlider');
        const lightSizeSlider = document.getElementById('lightSizeSlider');
        const lightXValue = document.getElementById('lightXValue');
        const lightYValue = document.getElementById('lightYValue');
        const lightZValue = document.getElementById('lightZValue');
        const lightBrightnessValue = document.getElementById('lightBrightnessValue');
        const lightSizeValue = document.getElementById('lightSizeValue');
        const sunHueSlider = document.getElementById('sunHueSlider'); // New
        const sunHueValueSpan = document.getElementById('sunHueValue'); // New
        const waveStrengthSlider = document.getElementById('waveStrengthSlider');
        const waveFrequencySlider = document.getElementById('waveFrequencySlider');
        const waveSpeedSlider = document.getElementById('waveSpeedSlider');
        const waveStrengthValue = document.getElementById('waveStrengthValue');
        const waveFrequencyValue = document.getElementById('waveFrequencyValue');
        const waveSpeedValue = document.getElementById('waveSpeedValue');
        const refractiveIndexSlider = document.getElementById('refractiveIndexSlider');
        const refractiveIndexValue = document.getElementById('refractiveIndexValue');
        const warpStrengthSlider = document.getElementById('warpStrengthSlider');
        const warpStrengthValue = document.getElementById('warpStrengthValue');
        const terrainHeightSlider = document.getElementById('terrainHeightSlider');
        const terrainHeightValue = document.getElementById('terrainHeightValue');
        const terrainFrequencySlider = document.getElementById('terrainFrequencySlider');
        const terrainFrequencyValue = document.getElementById('terrainFrequencyValue');
        const bouncesSlider = document.getElementById('bouncesSlider');
        const bouncesValue = document.getElementById('bouncesValue');
        const raymarchStepsSlider = document.getElementById('raymarchStepsSlider');
        const raymarchStepsValue = document.getElementById('raymarchStepsValue');
        const shadowSamplesSlider = document.getElementById('shadowSamplesSlider');
        const shadowSamplesValue = document.getElementById('shadowSamplesValue');
        const dofSamplesSlider = document.getElementById('dofSamplesSlider');
        const dofSamplesValue = document.getElementById('dofSamplesValue');
        const focalDistanceSlider = document.getElementById('focalDistanceSlider');
        const focalDistanceValue = document.getElementById('focalDistanceValue');
        const apertureSizeSlider = document.getElementById('apertureSizeSlider');
        const apertureSizeValue = document.getElementById('apertureSizeValue');
        const sunnyDayButton = document.getElementById('sunnyDayButton');
        const duskButton = document.getElementById('duskButton');
        const fpsCounterElement = document.getElementById('fps-counter');

        // Define a maximum dimension for the canvas to prevent excessive GPU memory usage
        const MAX_CANVAS_DIMENSION = 1920;

        // Function to display errors in the UI
        function displayErrorMessage(message) {
            if (errorMessageDisplay) {
                errorMessageDisplay.textContent = message;
                errorMessageDisplay.classList.add('active');
                // Auto-hide after some time
                setTimeout(() => {
                    errorMessageDisplay.classList.remove('active');
                }, 7000); // Increased display time for potentially longer messages
            }
            console.error(message);
        }

        // --- Input Validation Helper ---
        function validateAndClampInput(event, isFloat = false) {
            const inputElement = event.target;
            let value = isFloat ? parseFloat(inputElement.value) : parseInt(inputElement.value);
            const min = isFloat ? parseFloat(inputElement.min) : parseInt(inputElement.min);
            const max = isFloat ? parseFloat(inputElement.max) : parseInt(inputElement.max);
            let originalValue = value; // For logging

            if (isNaN(value) || !isFinite(value)) {
                console.warn(`Invalid input: ${inputElement.value} for ${inputElement.id}. Resetting to min/max bounds or default. Original was NaN or Infinite.`);
                value = min;
            }

            if (value < min) {
                value = min;
                console.warn(`Input ${originalValue} for ${inputElement.id} was below min (${min}). Clamped to ${value}.`);
            } else if (value > max) {
                value = max;
                console.warn(`Input ${originalValue} for ${inputElement.id} was above max (${max}). Clamped to ${value}.`);
            }

            inputElement.value = value;
            return value;
        }

        // --- Buffer Write Validation Helper ---
        function validateAndWriteBuffer(bufferName, functionName, targetBuffer, bufferOffset, sourceData, sourceDataElementOffset = 0, writeDataSizeInBytes) {
            if (!device || !device.queue || !targetBuffer || !sourceData) {
                console.error(`[${functionName}] Error: WebGPU device, queue, targetBuffer, or sourceData is null/undefined for ${bufferName}. Skipping writeBuffer.`);
                displayErrorMessage(`Critical error: Essential WebGPU component missing for ${bufferName}. Check console.`);
                return false;
            }

            const sourceDataByteOffset = sourceDataElementOffset * sourceData.BYTES_PER_ELEMENT;
            let effectiveWriteDataSize = writeDataSizeInBytes;
            if (effectiveWriteDataSize === undefined) {
                effectiveWriteDataSize = sourceData.byteLength - sourceDataByteOffset;
            }

            let valid = true;
            let errors = [];

            // Check 1: bufferOffset must be a multiple of 4.
            if (bufferOffset % 4 !== 0) {
                errors.push(`bufferOffset (${bufferOffset}) must be a multiple of 4.`);
                valid = false;
            }
            // Check 2: sourceDataByteOffset must be a multiple of 4.
            if (sourceDataByteOffset % 4 !== 0) {
                errors.push(`sourceDataByteOffset (${sourceDataByteOffset}, from element offset ${sourceDataElementOffset}) must be a multiple of 4.`);
                valid = false;
            }
            // Check 3: effectiveWriteDataSize must be a multiple of 4.
            if (effectiveWriteDataSize % 4 !== 0) {
                errors.push(`effectiveWriteDataSize (${effectiveWriteDataSize}) must be a multiple of 4.`);
                valid = false;
            }
            // Check 4: bufferOffset + effectiveWriteDataSize must not exceed targetBuffer.size.
            if (bufferOffset + effectiveWriteDataSize > targetBuffer.size) {
                errors.push(`bufferOffset (${bufferOffset}) + effectiveWriteDataSize (${effectiveWriteDataSize}) = ${bufferOffset + effectiveWriteDataSize} exceeds targetBuffer.size (${targetBuffer.size}).`);
                valid = false;
            }

            if (valid) {
                // Ensure the validated effectiveWriteDataSize is passed to the native call
                device.queue.writeBuffer(targetBuffer, bufferOffset, sourceData, sourceDataByteOffset, effectiveWriteDataSize);
                return true;
            } else {
                const errorMessage = `[${functionName}] Buffer write validation failed for '${bufferName}':
${errors.join('
')}`;
                console.error(errorMessage);
                displayErrorMessage(`Buffer write validation error for ${bufferName}. Check console for details.`);
                return false;
            }
        }

        // --- View Management Logic ---
        function switchView(newViewId) {
            // Hide all views
            menuView.classList.remove('active');
            loadingView.classList.remove('active');
            sceneView.classList.remove('active');
            settingsPanel.classList.remove('active'); // Ensure settings panel is hidden too
            // Hide scene-specific UI
            fpsCounterElement.style.display = 'none';
            sceneControlsPanel.style.display = 'none';
            backToMainMenuFromSceneButton.style.display = 'none';

            // Show target view after a short delay to allow CSS transitions
            setTimeout(() => {
                if (newViewId === 'menu') {
                    menuView.classList.add('active');
                    canvas.style.display = 'none'; // Ensure canvas is hidden when in menu
                } else if (newViewId === 'loading') {
                    loadingView.classList.add('active');
                    canvas.style.display = 'none'; // Canvas remains hidden during loading
                } else if (newViewId === 'scene') {
                    sceneView.classList.add('active');
                    canvas.style.display = 'block'; // Show canvas for rendering
                    fpsCounterElement.style.display = 'block';
                    sceneControlsPanel.style.display = 'block';
                    backToMainMenuFromSceneButton.style.display = 'block';
                    // Resume render loop if not already running
                    startRenderLoop();
                }
                appState = newViewId;
                console.log(`Switched to view: ${appState}`);
            }, 50); // Small delay
        }

        // --- Main Menu and Settings Panel Interactions ---
        startButton.addEventListener('click', () => {
            // Use current settings to apply and start
            applySettingsAndStart();
        });

        settingsButton.addEventListener('click', () => {
            menuView.classList.remove('active');
            settingsPanel.classList.add('active');
        });

        backToMenuButton.addEventListener('click', () => {
            settingsPanel.classList.remove('active');
            menuView.classList.add('active'); // Fade back to main menu
        });

        applySettingsButton.addEventListener('click', applySettingsAndStart);

        function applySettingsAndStart() {
            // Update global settings based on UI
            // Values are already validated and stored in the range elements themselves
            // or directly in global vars by their respective event listeners.
            targetSphereCount = parseInt(numSpheresRange.value); // Assuming numSpheresRange.value is updated by its listener
            maxBounces = parseInt(maxBouncesRange.value);       // Assuming maxBouncesRange.value is updated by its listener
            shadowSamples = parseInt(samplesPerPixelRange.value); // Assuming samplesPerPixelRange.value is updated
            dofSamples = shadowSamples; // Keep these linked for now as per existing logic

            // Update scene controls sliders to reflect these new values
            sphereCountSlider.value = targetSphereCount; sphereCountValue.textContent = targetSphereCount;
            bouncesSlider.value = maxBounces; bouncesValue.textContent = maxBounces;
            shadowSamplesSlider.value = shadowSamples; shadowSamplesValue.textContent = shadowSamples;
            dofSamplesSlider.value = dofSamples; dofSamplesValue.textContent = dofSamples;

            // Transition to loading view and start WebGPU initialization
            switchView('loading');
            loadingStatusP.textContent = "Initializing WebGPU and requesting GPU adapter...";
            initWebGPUAndCompileShaders(); // This function now handles full initialization
        }

        // Event listeners for settings sliders
        numSpheresRange.addEventListener('input', (e) => {
            const value = validateAndClampInput(e, false);
            numSpheresValueSpan.textContent = value;
            // No need to update targetSphereCount here, applySettingsAndStart reads from numSpheresRange.value
        });
        maxBouncesRange.addEventListener('input', (e) => {
            const value = validateAndClampInput(e, false);
            maxBouncesValueSpan.textContent = value;
        });
        samplesPerPixelRange.addEventListener('input', (e) => {
            const value = validateAndClampInput(e, false);
            samplesPerPixelValueSpan.textContent = value;
        });

        qualityPresetSelect.addEventListener('change', (e) => {
            const preset = e.target.value;
            if (preset === 'low') {
                numSpheresRange.value = 5; // Directly set value, it will be picked up by applySettingsAndStart
                maxBouncesRange.value = 2;
                samplesPerPixelRange.value = 4;
            } else if (preset === 'medium') {
                numSpheresRange.value = 10;
                maxBouncesRange.value = 4;
                samplesPerPixelRange.value = 16;
            } else if (preset === 'high') {
                numSpheresRange.value = 50;
                maxBouncesRange.value = 8;
                samplesPerPixelRange.value = 32;
            }
            // Update spans after setting values
            numSpheresValueSpan.textContent = numSpheresRange.value;
            maxBouncesValueSpan.textContent = maxBouncesRange.value;
            samplesPerPixelValueSpan.textContent = samplesPerPixelRange.value;
        });

        // --- Scene Controls UI Listeners ---

        // Function to reset accumulation (called on all relevant UI changes)
        function resetAccumulation() {
            frameCount = 0; // Reset accumulated frames
            currentTextureIndex = 0; // Reset ping-pong state
            // Re-initialize textures to clear accumulated data
            createPingPongTextures(); // Clears textures by recreating them
            console.log('Accumulation reset.');
        }

        togglePanelButton.addEventListener('click', () => {
            sceneControlsPanel.classList.toggle('collapsed');
            togglePanelButton.textContent = sceneControlsPanel.classList.contains('collapsed') ? '>' : '<';
        });

        sphereCountSlider.addEventListener('input', (e) => {
            targetSphereCount = validateAndClampInput(e, false);
            sphereCountValue.textContent = targetSphereCount;
            manageSpheres();
            resetAccumulation();
        });

        lightXSlider.addEventListener('input', (e) => { light.position[0] = validateAndClampInput(e, true); lightXValue.textContent = light.position[0].toFixed(1); updateLightUniformBuffer(); resetAccumulation(); });
        lightYSlider.addEventListener('input', (e) => { light.position[1] = validateAndClampInput(e, true); lightYValue.textContent = light.position[1].toFixed(1); updateLightUniformBuffer(); resetAccumulation(); });
        lightZSlider.addEventListener('input', (e) => { light.position[2] = validateAndClampInput(e, true); lightZValue.textContent = light.position[2].toFixed(1); updateLightUniformBuffer(); resetAccumulation(); });
        lightBrightnessSlider.addEventListener('input', (e) => { light.brightness = validateAndClampInput(e, true); lightBrightnessValue.textContent = light.brightness.toFixed(1); updateLightUniformBuffer(); resetAccumulation(); });
        lightSizeSlider.addEventListener('input', (e) => { light.size = validateAndClampInput(e, true); lightSizeValue.textContent = light.size.toFixed(1); updateLightUniformBuffer(); resetAccumulation(); });

        sunHueSlider.addEventListener('input', (e) => {
            sunHue = validateAndClampInput(e, true);
            sunHueValueSpan.textContent = sunHue.toFixed(2);
            light.color = hsvToRgb(sunHue);
            updateLightUniformBuffer();
            resetAccumulation();
        });

        waveStrengthSlider.addEventListener('input', (e) => { waveStrength = validateAndClampInput(e, true); waveStrengthValue.textContent = waveStrength.toFixed(3); updateWaterUniformBuffer(); resetAccumulation(); }); // .toFixed(3) for step 0.005
        waveFrequencySlider.addEventListener('input', (e) => { waveFrequency = validateAndClampInput(e, true); waveFrequencyValue.textContent = waveFrequency.toFixed(1); updateWaterUniformBuffer(); resetAccumulation(); });
        waveSpeedSlider.addEventListener('input', (e) => { waveSpeed = validateAndClampInput(e, true); waveSpeedValue.textContent = waveSpeed.toFixed(2); updateWaterUniformBuffer(); resetAccumulation(); });

        refractiveIndexSlider.addEventListener('input', (e) => {
            globalRefractiveIndex = validateAndClampInput(e, true);
            refractiveIndexValue.textContent = globalRefractiveIndex.toFixed(2);

            spheres.forEach(s => {
                if (s.materialType === MATERIAL_REFRACTIVE) {
                    s.refractiveIndex = globalRefractiveIndex;
                }
            });
            updateGPUBuffers(spheres, currentBvhResult);
            resetAccumulation();
        });

        warpStrengthSlider.addEventListener('input', (e) => { globalWarpStrength = validateAndClampInput(e, true); warpStrengthValue.textContent = globalWarpStrength.toFixed(2); updateRaytracerParamsUniformBuffer(); resetAccumulation(); });
        terrainHeightSlider.addEventListener('input', (e) => { terrainHeightScale = validateAndClampInput(e, true); terrainHeightValue.textContent = terrainHeightScale.toFixed(1); updateTerrainUniformBuffer(); resetAccumulation(); });
        terrainFrequencySlider.addEventListener('input', (e) => { terrainFrequency = validateAndClampInput(e, true); terrainFrequencyValue.textContent = terrainFrequency.toFixed(2); updateTerrainUniformBuffer(); resetAccumulation(); });
        bouncesSlider.addEventListener('input', (e) => { maxBounces = validateAndClampInput(e, false); bouncesValue.textContent = maxBounces; updateRaytracerParamsUniformBuffer(); resetAccumulation(); });
        raymarchStepsSlider.addEventListener('input', (e) => { maxRaymarchSteps = validateAndClampInput(e, false); raymarchStepsValue.textContent = maxRaymarchSteps; updateRaytracerParamsUniformBuffer(); resetAccumulation(); });
        shadowSamplesSlider.addEventListener('input', (e) => { shadowSamples = validateAndClampInput(e, false); shadowSamplesValue.textContent = shadowSamples; updateRaytracerParamsUniformBuffer(); resetAccumulation(); });
        dofSamplesSlider.addEventListener('input', (e) => { dofSamples = validateAndClampInput(e, false); dofSamplesValue.textContent = dofSamples; updateRaytracerParamsUniformBuffer(); resetAccumulation(); });
        focalDistanceSlider.addEventListener('input', (e) => { camera.focalDistance = validateAndClampInput(e, true); focalDistanceValue.textContent = camera.focalDistance.toFixed(1); updateRaytracerParamsUniformBuffer(); resetAccumulation(); });
        apertureSizeSlider.addEventListener('input', (e) => { camera.apertureSize = validateAndClampInput(e, true); apertureSizeValue.textContent = camera.apertureSize.toFixed(2); updateRaytracerParamsUniformBuffer(); resetAccumulation(); });

        sunnyDayButton.addEventListener('click', () => {
            skyPreset = 0; updateRaytracerParamsUniformBuffer();
            sunnyDayButton.classList.add('active'); duskButton.classList.remove('active');
            resetAccumulation(); // Reset accumulation on setting change
        });
        duskButton.addEventListener('click', () => {
            skyPreset = 1; updateRaytracerParamsUniformBuffer();
            duskButton.classList.add('active'); sunnyDayButton.classList.remove('active');
            resetAccumulation(); // Reset accumulation on setting change
        });

        backToMainMenuFromSceneButton.addEventListener('click', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            switchView('menu');
        });

        // --- Camera Movement and Utilities ---

        function calculateCameraVectors() {
            const pitch = camera.rotationX;
            const yaw = camera.rotationY;

            // Calculate forward vector
            camera.forward[0] = Math.cos(pitch) * Math.sin(yaw);
            camera.forward[1] = Math.sin(pitch);
            camera.forward[2] = -Math.cos(pitch) * Math.cos(yaw);
            let len = Math.sqrt(camera.forward[0] ** 2 + camera.forward[1] ** 2 + camera.forward[2] ** 2);
            camera.forward[0] /= len; camera.forward[1] /= len; camera.forward[2] /= len;

            // Calculate right vector (cross product of world up and forward)
            let worldUp = [0, 1, 0];
            camera.right[0] = worldUp[1] * camera.forward[2] - worldUp[2] * camera.forward[1];
            camera.right[1] = worldUp[2] * camera.forward[0] - worldUp[0] * camera.forward[2];
            camera.right[2] = worldUp[0] * camera.forward[1] - worldUp[1] * camera.forward[0];
            len = Math.sqrt(camera.right[0] ** 2 + camera.right[1] ** 2 + camera.right[2] ** 2);
            if (len > 0) { camera.right[0] /= len; camera.right[1] /= len; camera.right[2] /= len; } else { camera.right = [1, 0, 0]; }

            // Calculate up vector (cross product of forward and right)
            camera.up[0] = camera.forward[1] * camera.right[2] - camera.forward[2] * camera.right[1];
            camera.up[1] = camera.forward[2] * camera.right[0] - camera.forward[0] * camera.right[2];
            camera.up[2] = camera.forward[0] * camera.right[1] - camera.forward[1] * camera.right[0];
            len = Math.sqrt(camera.up[0] ** 2 + camera.up[1] ** 2 + camera.up[2] ** 2);
            if (len > 0) { camera.up[0] /= len; camera.up[1] /= len; camera.up[2] /= len; } else { camera.up = [0, 1, 0]; }
        }

        // HSV to RGB conversion for Sun Color
        function hsvToRgb(h) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = 0; // v * (1 - s) for full saturation, value=1
            const q = 1 - f; // v * (1 - f * s) for full saturation, value=1
            const t = f; // v * (1 - (1 - f) * s) for full saturation, value=1
            switch (i % 6) {
                case 0: r = 1, g = t, b = p; break;
                case 1: r = q, g = 1, b = p; break;
                case 2: r = p, g = 1, b = t; break;
                case 3: r = p, g = q, b = 1; break;
                case 4: r = t, g = p, b = 1; break;
                case 5: r = 1, g = p, b = q; break;
            }
            return [r, g, b]; // Colors are already 0-1
        }

        // --- Uniform Buffer Updates ---

        function updateCameraUniformBuffer() {
            calculateCameraVectors();
            // CameraUniform struct:
            // position: vec3<f32>, _padding0: f32, (16 bytes)
            // forward: vec3<f32>, _padding1: f32,  (16 bytes)
            // right: vec3<f32>, _padding2: f32,    (16 bytes)
            // up: vec3<f32>, _padding3: f32,      (16 bytes)
            // resolution: vec2<f32>, aspect: f32, fovy: f32, (16 bytes, vec2 aligns to 8, then 2 floats for 16 total)
            // near: f32, far: f32, _padding4: vec2<f32>, (16 bytes, 2 floats, then vec2 for padding to 16)
            // Total: 6 * 16 bytes = 96 bytes.
            // This translates to 24 floats.
            cameraDataArray[0] = camera.position[0]; cameraDataArray[1] = camera.position[1]; cameraDataArray[2] = camera.position[2]; cameraDataArray[3] = 0.0;
            cameraDataArray[4] = camera.forward[0]; cameraDataArray[5] = camera.forward[1]; cameraDataArray[6] = camera.forward[2]; cameraDataArray[7] = 0.0;
            cameraDataArray[8] = camera.right[0]; cameraDataArray[9] = camera.right[1]; cameraDataArray[10] = camera.right[2]; cameraDataArray[11] = 0.0;
            cameraDataArray[12] = camera.up[0]; cameraDataArray[13] = camera.up[1]; cameraDataArray[14] = camera.up[2]; cameraDataArray[15] = 0.0;
            cameraDataArray[16] = canvas.width; cameraDataArray[17] = canvas.height;
            cameraDataArray[18] = camera.aspect;
            cameraDataArray[19] = camera.fovy;
            cameraDataArray[20] = camera.near;
            cameraDataArray[21] = camera.far;
            cameraDataArray[22] = 0.0; cameraDataArray[23] = 0.0;

            if (device && device.queue && cameraUBOBuffer) {
                validateAndWriteBuffer('cameraUBOBuffer', 'updateCameraUniformBuffer', cameraUBOBuffer, 0, cameraDataArray);
            }
        }

        function updateLightUniformBuffer() {
            // WGSL LightUniform struct expects 64 bytes (16 floats)
            // position: vec3<f32>, pad, (16 bytes)
            // brightness: f32, pad, pad, pad (16 bytes)
            // size: f32, pad, pad, pad (16 bytes)
            // color: vec3<f32>, pad (16 bytes)
            lightDataArray[0] = light.position[0];
            lightDataArray[1] = light.position[1];
            lightDataArray[2] = light.position[2];
            // lightDataArray[3] = 0.0f; // Padding

            lightDataArray[4] = light.brightness;
            // lightDataArray[5,6,7] = 0.0f; // Padding

            lightDataArray[8] = light.size;
            // lightDataArray[9,10,11] = 0.0f; // Padding

            lightDataArray[12] = light.color[0];
            lightDataArray[13] = light.color[1];
            lightDataArray[14] = light.color[2];
            // lightDataArray[15] = 0.0f; // Padding

            // Note: Float32Array is initialized to zeros, so explicit padding assignment is not strictly needed if it's 0.

            if (device && device.queue && lightUBOBuffer) {
                validateAndWriteBuffer('lightUBOBuffer', 'updateLightUniformBuffer', lightUBOBuffer, 0, lightDataArray);
            }
        }

        function updateTimeUniformBuffer(time) {
            timeDataArray[0] = time;
            timeDataArray[1] = parseFloat(frameCount);
            // timeDataArray[2,3] are padding (already 0.0f)
            if (device && device.queue && timeUBOBuffer) {
                validateAndWriteBuffer('timeUBOBuffer', 'updateTimeUniformBuffer', timeUBOBuffer, 0, timeDataArray);
            }
        }

        function updateWaterUniformBuffer() {
            waterDataArray[0] = waveStrength;
            waterDataArray[1] = waveFrequency;
            waterDataArray[2] = waveSpeed;
            // waterDataArray[3] is padding (already 0.0f)
            if (device && device.queue && waterUBOBuffer) {
                validateAndWriteBuffer('waterUBOBuffer', 'updateWaterUniformBuffer', waterUBOBuffer, 0, waterDataArray);
            }
        }

        function updateTerrainUniformBuffer() {
            terrainDataArray[0] = terrainHeightScale;
            terrainDataArray[1] = terrainFrequency;
            // terrainDataArray[2,3] are padding (already 0.0f)
            if (device && device.queue && terrainUBOBuffer) {
                validateAndWriteBuffer('terrainUBOBuffer', 'updateTerrainUniformBuffer', terrainUBOBuffer, 0, terrainDataArray);
            }
        }

        function updateRaytracerParamsUniformBuffer() {
            raytracerDataArray[0] = maxBounces;
            raytracerDataArray[1] = maxRaymarchSteps;
            raytracerDataArray[2] = shadowSamples;
            raytracerDataArray[3] = dofSamples;
            raytracerDataArray[4] = currentBvhResult.bvhNodes.length;
            raytracerDataArray[5] = spheres.length;
            raytracerDataArray[6] = skyPreset;
            // raytracerDataArray[7] is padding (already 0.0f)
            raytracerDataArray[8] = globalWarpStrength;
            raytracerDataArray[9] = camera.focalDistance;
            raytracerDataArray[10] = camera.apertureSize;
            // raytracerDataArray[11] is padding (already 0.0f)

            if (device && device.queue && raytracerUBOBuffer) {
                validateAndWriteBuffer('raytracerUBOBuffer', 'updateRaytracerParamsUniformBuffer', raytracerUBOBuffer, 0, raytracerDataArray);
            }
        }


        // --- BVH Data Structures and Logic (CPU side) ---
        class AABB {
            constructor(min, max) {
                this.min = min;
                this.max = max;
            }

            expand(point) {
                this.min[0] = Math.min(this.min[0], point[0]);
                this.min[1] = Math.min(this.min[1], point[1]);
                this.min[2] = Math.min(this.min[2], point[2]);
                this.max[0] = Math.max(this.max[0], point[0]);
                this.max[1] = Math.max(this.max[1], point[1]);
                this.max[2] = Math.max(this.max[2], point[2]);
            }

            union(other) {
                this.min[0] = Math.min(this.min[0], other.min[0]);
                this.min[1] = Math.min(this.min[1], other.min[1]);
                this.min[2] = Math.min(this.min[2], other.min[2]);
                this.max[0] = Math.max(this.max[0], other.max[0]);
                this.max[1] = Math.max(this.max[1], other.max[1]);
                this.max[2] = Math.max(this.max[2], other.max[2]);
            }

            centroid() {
                return [
                    (this.min[0] + this.max[0]) * 0.5,
                    (this.min[1] + this.max[1]) * 0.5,
                    (this.min[2] + this.max[2]) * 0.5
                ];
            }

            longestAxis() {
                const dx = this.max[0] - this.min[0];
                const dy = this.max[1] - this.min[1];
                const dz = this.max[2] - this.min[2];
                if (dx > dy && dx > dz) return 0;
                if (dy > dz) return 1;
                return 2;
            }
        }

        class BvhNode {
            constructor() {
                this.minBounds = [Infinity, Infinity, Infinity];
                this.maxBounds = [-Infinity, -Infinity, -Infinity];
                this.isLeaf = 0; // 0 for internal, 1 for leaf
                this.primitiveCount = 0;
                this.leftChildOrFirstPrimitiveIndex = 0; // Index in flattened array or primitiveIndices array
            }
        }

        const BVH_LEAF_SIZE = 4; // Max number of primitives in a leaf node

        // Build the BVH recursively
        function buildBvh(primitives, flattenedNodes, primitiveIndices, offset, count) {
            let bbox = new AABB(
                [Infinity, Infinity, Infinity],
                [-Infinity, -Infinity, -Infinity]
            );
            for (let i = offset; i < offset + count; ++i) {
                const p = primitives[primitiveIndices[i]];
                // Expand AABB by sphere bounds
                bbox.expand([p.position[0] - p.radius, p.position[1] - p.radius, p.position[2] - p.radius]);
                bbox.expand([p.position[0] + p.radius, p.position[1] + p.radius, p.position[2] + p.radius]);
            }

            const nodeIndex = flattenedNodes.length;
            const node = new BvhNode();
            node.minBounds = bbox.min;
            node.maxBounds = bbox.max;
            flattenedNodes.push(node); // Push a placeholder, will update later

            if (count <= BVH_LEAF_SIZE) {
                node.isLeaf = 1;
                node.primitiveCount = count;
                node.leftChildOrFirstPrimitiveIndex = offset; // Stores the start index in primitiveIndices array
            } else {
                const axis = bbox.longestAxis();
                const pivot = bbox.centroid()[axis];

                // Partition primitives using a quicksort-like approach
                let left = offset;
                let right = offset + count - 1;
                while (left <= right) {
                    while (left <= right && primitives[primitiveIndices[left]].position[axis] < pivot) {
                        left++;
                    }
                    while (left <= right && primitives[primitiveIndices[right]].position[axis] >= pivot) {
                        right--;
                    }
                    if (left < right) {
                        // Swap indices in the primitiveIndices array
                        [primitiveIndices[left], primitiveIndices[right]] = [primitiveIndices[right], primitiveIndices[left]];
                        left++;
                        right--;
                    }
                }

                // If partitioning failed to split, fall back to simple half split
                let mid = left;
                if (mid === offset || mid === offset + count) {
                    mid = offset + Math.floor(count / 2);
                }

                const leftCount = mid - offset;
                const rightCount = count - leftCount;

                node.isLeaf = 0; // Mark as internal node
                node.primitiveCount = 0; // Internal nodes don't have primitives directly
                node.leftChildOrFirstPrimitiveIndex = flattenedNodes.length; // Index of the left child in flattenedNodes

                // Recursively build children
                buildBvh(primitives, flattenedNodes, primitiveIndices, offset, leftCount);
                buildBvh(primitives, flattenedNodes, primitiveIndices, mid, rightCount);
            }
            flattenedNodes[nodeIndex] = node; // Update the placeholder node
            return nodeIndex; // Return index of this node
        }

        function buildBvhStructure(primitives) {
            console.time("BVH Build");
            loadingStatusP.textContent = `Building BVH for ${primitives.length} spheres... This might take a moment.`;
            if (primitives.length === 0) {
                console.warn("No primitives to build BVH for.");
                return { bvhNodes: [], primitiveIndices: [] };
            }

            const flattenedNodes = [];
            // Create an array of primitive indices [0, 1, 2, ..., n-1]
            const primitiveIndices = Array.from({ length: primitives.length }, (_, i) => i);

            try {
                // Start recursive BVH build
                buildBvh(primitives, flattenedNodes, primitiveIndices, 0, primitives.length);
            } catch (e) {
                console.error("Error during BVH construction:", e);
                displayErrorMessage(`BVH construction failed: ${e.message}`);
                return { bvhNodes: [], primitiveIndices: [] };
            }

            console.timeEnd("BVH Build");
            loadingStatusP.textContent = `BVH built with ${flattenedNodes.length} nodes. Uploading to GPU...`;
            return { bvhNodes: flattenedNodes, primitiveIndices: primitiveIndices };
        }

        const sphereMinRadius = 0.5;
        const sphereMaxRadius = 1.5;

        function populateInitialSpheres(count) {
            const newSpheres = [];

            // Fixed floor sphere
            if (count > 0) { // Always add ground if there's at least one sphere desired
                newSpheres.push({
                    position: [0.0, -100.5, 0.0], radius: 100.0,
                    color: [0.7, 0.7, 0.7],
                    baseReflectivity: 0.04,
                    perPixelRoughness: 0.9,
                    metallic: 0.0,
                    refractiveIndex: 1.0, // Not used for diffuse, but good to have
                    materialType: MATERIAL_DIFFUSE
                });
            }

            // Generate other spheres
            for (let i = newSpheres.length; i < count; ++i) {
                let materialType;
                const r = Math.random();
                if (r < 0.4) { materialType = MATERIAL_DIFFUSE; }
                else if (r < 0.7) { materialType = MATERIAL_REFLECTIVE; }
                else { materialType = MATERIAL_REFRACTIVE; }

                let s = {
                    position: [0,0,0], // Will be set in collision loop
                    radius: sphereMinRadius + Math.random() * (sphereMaxRadius - sphereMinRadius),
                    color: [0,0,0], // Will be set by material type
                    baseReflectivity: 0.04,
                    perPixelRoughness: 0.0,
                    metallic: 0.0,
                    refractiveIndex: 1.0,
                    materialType: materialType
                };

                // Simple distance utility
                function distance(p1, p2) {
                    const dx = p1[0] - p2[0];
                    const dy = p1[1] - p2[1];
                    const dz = p1[2] - p2[2];
                    return Math.sqrt(dx*dx + dy*dy + dz*dz);
                }

                let attempts = 0;
                const max_attempts = 50; // Increased attempts for better placement
                let collided;

                // Attempt to place sphere without collision
                do {
                    collided = false;
                    s.position[0] = (Math.random() - 0.5) * 15;
                    s.position[1] = (Math.random() - 0.5) * 4 + 2.0;
                    s.position[2] = (Math.random() - 0.5) * 15;

                    for (let j = 0; j < newSpheres.length; ++j) {
                        // Exclude the ground plane from collision checks for other spheres
                        if (newSpheres[j].radius === 100.0 && newSpheres[j].position[1] === -100.5) {
                            continue;
                        }
                        if (distance(s.position, newSpheres[j].position) < (s.radius + newSpheres[j].radius + 0.5)) {
                            collided = true;
                            break;
                        }
                    }
                    attempts++;
                } while (collided && attempts < max_attempts);

                // Set material properties based on type
                if (materialType === MATERIAL_DIFFUSE) {
                    s.baseReflectivity = 0.04;
                    s.perPixelRoughness = Math.random() * 0.7 + 0.3; // More rough
                    s.metallic = 0.0;
                    s.color = [Math.random(), Math.random(), Math.random()];
                }
                else if (materialType === MATERIAL_REFLECTIVE) {
                    s.baseReflectivity = Math.random() * 0.9 + 0.1; // More reflective
                    s.perPixelRoughness = Math.random() * 0.1; // Less rough (shiny)
                    s.metallic = 1.0;
                    s.color = [Math.random() * 0.7 + 0.3, Math.random() * 0.7 + 0.3, Math.random() * 0.7 + 0.3]; // Metallic colors
                }
                else if (materialType === MATERIAL_REFRACTIVE) {
                    s.baseReflectivity = 0.04;
                    s.perPixelRoughness = Math.random() * 0.1; // Smooth
                    s.metallic = 0.0;
                    s.refractiveIndex = globalRefractiveIndex; // Use global setting
                    s.color = [Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5]; // Translucent colors
                }
                newSpheres.push(s);
            }
            return newSpheres;
        }

        function updateGPUBuffers(newSpheresData, bvhData) {
            if (!device) {
                console.warn("Device not ready for GPU buffer update.");
                return;
            }
            loadingStatusP.textContent = `Updating sphere data (${newSpheresData.length} spheres)...`;

            // Sphere struct in WGSL: position_radius (vec4), albedo_metallic (vec4), pbr_properties (vec4)
            // Total 12 floats per sphere (12 * 4 bytes = 48 bytes)
            const SPHERE_FLOAT_COUNT = 12;
            const sphereRawData = new Float32Array(newSpheresData.length * SPHERE_FLOAT_COUNT);

            newSpheresData.forEach((s, i) => {
                let offset = i * SPHERE_FLOAT_COUNT;
                sphereRawData[offset + 0] = s.position[0];
                sphereRawData[offset + 1] = s.position[1];
                sphereRawData[offset + 2] = s.position[2];
                sphereRawData[offset + 3] = s.radius; // position_radius.w

                sphereRawData[offset + 4] = s.color[0];
                sphereRawData[offset + 5] = s.color[1];
                sphereRawData[offset + 6] = s.color[2];
                sphereRawData[offset + 7] = s.metallic; // albedo_metallic.w

                sphereRawData[offset + 8] = s.perPixelRoughness;   // pbr_properties.x
                sphereRawData[offset + 9] = s.baseReflectivity;    // pbr_properties.y
                sphereRawData[offset + 10] = s.materialType;       // pbr_properties.z (u32, stored as float)
                sphereRawData[offset + 11] = s.refractiveIndex;    // pbr_properties.w
            });

            // Recreate sphere data buffer
            if (sphereDataBuffer) { sphereDataBuffer.destroy(); }
            sphereDataBuffer = device.createBuffer({
                size: sphereRawData.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            validateAndWriteBuffer('sphereDataBuffer', 'updateGPUBuffers', sphereDataBuffer, 0, sphereRawData);
            console.log(`Sphere raw data buffer recreated with ${newSpheresData.length} spheres.`);

            // Update current BVH result (used for GPU side)
            currentBvhResult.bvhNodes = bvhData.bvhNodes;
            currentBvhResult.primitiveIndices = bvhData.primitiveIndices;

            loadingStatusP.textContent = `Updating BVH nodes (${bvhData.bvhNodes.length} nodes)...`;

            // BVHNode struct in WGSL: minBounds (vec3), isLeaf (u32), maxBounds (vec3), primitiveCount (u32), leftChildOrFirstPrimitiveIndex (u32), _padding (vec3<u32>)
            // Total 12 floats per node (12 * 4 bytes = 48 bytes)
            const BVH_NODE_FLOAT_COUNT = 12;
            const bvhNodesFlat = new Float32Array(bvhData.bvhNodes.length * BVH_NODE_FLOAT_COUNT);

            bvhData.bvhNodes.forEach((node, i) => {
                let offset = i * BVH_NODE_FLOAT_COUNT;
                bvhNodesFlat[offset + 0] = node.minBounds[0];
                bvhNodesFlat[offset + 1] = node.minBounds[1];
                bvhNodesFlat[offset + 2] = node.minBounds[2];
                bvhNodesFlat[offset + 3] = node.isLeaf; // Stored as float for Float32Array, will be cast to u32 in shader

                bvhNodesFlat[offset + 4] = node.maxBounds[0];
                bvhNodesFlat[offset + 5] = node.maxBounds[1];
                bvhNodesFlat[offset + 6] = node.maxBounds[2];
                bvhNodesFlat[offset + 7] = node.primitiveCount; // Stored as float

                bvhNodesFlat[offset + 8] = node.leftChildOrFirstPrimitiveIndex; // Stored as float
                bvhNodesFlat[offset + 9] = 0; // Padding
                bvhNodesFlat[offset + 10] = 0; // Padding
                bvhNodesFlat[offset + 11] = 0; // Padding
            });

            loadingStatusP.textContent = `Updating primitive indices (${bvhData.primitiveIndices.length} indices)...`;
            const primitiveIndicesFlat = new Uint32Array(bvhData.primitiveIndices); // Use Uint32Array for indices

            // Recreate BVH nodes buffer
            if (bvhNodesBuffer) { bvhNodesBuffer.destroy(); }
            bvhNodesBuffer = device.createBuffer({
                size: bvhNodesFlat.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            validateAndWriteBuffer('bvhNodesBuffer', 'updateGPUBuffers', bvhNodesBuffer, 0, bvhNodesFlat);
            console.log(`BVH Nodes buffer recreated with ${bvhData.bvhNodes.length} nodes.`);

            // Recreate primitive indices buffer
            if (primitiveIndicesBuffer) { primitiveIndicesBuffer.destroy(); }
            primitiveIndicesBuffer = device.createBuffer({
                size: primitiveIndicesFlat.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            validateAndWriteBuffer('primitiveIndicesBuffer', 'updateGPUBuffers', primitiveIndicesBuffer, 0, primitiveIndicesFlat);
            console.log(`Primitive Indices buffer recreated with ${bvhData.primitiveIndices.length} indices.`);

            // Update the uniform buffer that holds sphere and BVH node counts
            updateRaytracerParamsUniformBuffer();
            // Recreate compute bind groups as storage buffers might have changed
            createComputeBindGroups();
        }

        function manageSpheres() {
            // Only rebuild BVH and spheres if target count has changed, or if it's the very first time
            if (spheres.length !== targetSphereCount || lastSphereCount !== targetSphereCount || spheres.length === 0) {
                spheres = populateInitialSpheres(targetSphereCount);
                lastSphereCount = targetSphereCount; // Update lastSphereCount after populating
                if (spheres.length === 0) {
                     // If no spheres, update with empty buffers
                     updateGPUBuffers([], { bvhNodes: [], primitiveIndices: [] });
                     return;
                }
                try {
                    const bvhResult = buildBvhStructure(spheres);
                    updateGPUBuffers(spheres, bvhResult);
                } catch (e) {
                    console.error("Error building BVH on main thread:", e);
                    displayErrorMessage(`Error building BVH: ${e.message}`);
                }
            }
        }

        // Helper to create/recreate the two ping-pong output textures and their views
        function createPingPongTextures() {
            if (!device) {
                console.warn("Device not ready for output texture creation.");
                return;
            }
            if (outputTexture0) { outputTexture0.destroy(); }
            if (outputTexture1) { outputTexture1.destroy(); }

            let textureWidth = canvas.width;
            let textureHeight = canvas.height;

            // Create two textures for ping-ponging, both rgba32float (for accumulation)
            // Note: rgba32float supports STORAGE_BINDING (write-only) and TEXTURE_BINDING (read-only), but NOT read-write storage binding without extensions.
            outputTexture0 = device.createTexture({
                size: { width: textureWidth, height: textureHeight },
                format: 'rgba32float', // Required for textureLoad and write in storage access
                usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
            });
            outputTextureView0 = outputTexture0.createView();

            outputTexture1 = device.createTexture({
                size: { width: textureWidth, height: textureHeight },
                format: 'rgba32float',
                usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
            });
            outputTextureView1 = outputTexture1.createView();
            console.log(`Ping-pong textures created with dimensions: ${textureWidth}x${textureHeight}.`);
        }

        // Helper to create all compute bind groups
        function createComputeBindGroups() {
            // Determine which texture is current read/write for the compute bind group
            const currentWriteTextureView = (currentTextureIndex === 0) ? outputTextureView0 : outputTextureView1;
            const currentReadTextureView = (currentTextureIndex === 0) ? outputTextureView1 : outputTextureView0; // Read from the "other" texture

            if (!device || !computePipeline || !currentWriteTextureView || !currentReadTextureView || !cameraUBOBuffer || !lightUBOBuffer || !timeUBOBuffer || !waterUBOBuffer || !terrainUBOBuffer || !raytracerUBOBuffer || !sphereDataBuffer || !bvhNodesBuffer || !primitiveIndicesBuffer) {
                console.warn("Skipping compute bind group creation: essential resources not ready. This is expected during initial setup while BVH is building.");
                return;
            }
            loadingStatusP.textContent = "Creating compute bind groups...";

            // Create Compute Bind Group 0: Uniforms and Ping-Pong Textures
            computeBindGroup0 = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: cameraUBOBuffer } },
                    { binding: 1, resource: { buffer: lightUBOBuffer } },
                    { binding: 2, resource: { buffer: raytracerUBOBuffer } },
                    { binding: 3, resource: { buffer: timeUBOBuffer } },
                    { binding: 4, resource: { buffer: waterUBOBuffer } },
                    { binding: 5, resource: { buffer: terrainUBOBuffer } },
                    { binding: 6, resource: currentWriteTextureView }, // Output (write-only storage texture)
                    { binding: 7, resource: currentReadTextureView },  // Input (read-only texture_2d<f32>)
                ],
            });

            // Create Compute Bind Group 1: Storage Buffers (Spheres & BVH)
            computeBindGroup1 = device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(1),
                entries: [
                    { binding: 0, resource: { buffer: sphereDataBuffer } },
                    { binding: 1, resource: { buffer: bvhNodesBuffer } },
                    { binding: 2, resource: { buffer: primitiveIndicesBuffer } },
                ],
            });
            console.log("Compute bind groups created/updated (including BVH).");
            loadingStatusP.textContent = "Compute bind groups created.";
        }

        // Helper to create render bind group
        function createRenderBindGroup() {
            // The render pass samples from the texture that was *just written to* by the compute shader
            const currentTextureToDisplay = (currentTextureIndex === 0) ? outputTexture0 : outputTexture1;
            const currentTextureViewToDisplay = (currentTextureIndex === 0) ? outputTextureView0 : outputTextureView1;

            if (!device || !renderPipeline || !outputSampler || !currentTextureViewToDisplay) {
                console.warn("Skipping render bind group creation: essential resources not ready.");
                return;
            }
            loadingStatusP.textContent = "Creating render bind group...";
            renderBindGroup = device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: outputSampler },
                    { binding: 1, resource: currentTextureViewToDisplay },
                ],
            });
            console.log("Render bind group created/updated.");
            loadingStatusP.textContent = "Render bind group created.";
        }

        // Optimized onResize handler
        function resizeCanvasAndAssets() {
            // Apply device pixel ratio for sharper image on high-DPI displays
            let newWidth = window.innerWidth * window.devicePixelRatio;
            let newHeight = window.innerHeight * window.devicePixelRatio;

            // Clamp dimensions to prevent excessive GPU memory usage
            if (newWidth > MAX_CANVAS_DIMENSION || newHeight > MAX_CANVAS_DIMENSION) {
                const aspectRatio = newWidth / newHeight;
                if (newWidth > newHeight) {
                    newWidth = MAX_CANVAS_DIMENSION;
                    newHeight = Math.floor(MAX_CANVAS_DIMENSION / aspectRatio);
                } else {
                    newHeight = MAX_CANVAS_DIMENSION;
                    newWidth = Math.floor(MAX_CANVAS_DIMENSION * aspectRatio);
                }
            }

            // Ensure dimensions are integers
            newWidth = Math.floor(newWidth);
            newHeight = Math.floor(newHeight);

            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                camera.aspect = canvas.width / canvas.height; // Update camera aspect ratio
                console.log(`Canvas resized to ${canvas.width}x${canvas.height}.`);
                loadingStatusP.textContent = `Canvas resized to ${canvas.width}x${canvas.height}. Recreating textures...`;

                // Configure context with new size
                context.configure({
                    device: device,
                    format: navigator.gpu.getPreferredCanvasFormat(),
                    alphaMode: 'opaque',
                    size: [canvas.width, canvas.height],
                });

                createPingPongTextures(); // Recreate ping-pong textures with new dimensions

                // Only attempt to create bind groups if pipelines are already defined
                if (computePipeline && renderPipeline) {
                    createComputeBindGroups(); // Recreate compute bind groups (they reference outputTextureViews)
                    createRenderBindGroup(); // Recreate render bind group (references outputTextureViews)
                } else {
                    console.warn("Pipelines not yet ready during resize, deferring bind group creation.");
                }

                // Update uniforms that depend on canvas size or aspect
                updateCameraUniformBuffer();
                updateRaytracerParamsUniformBuffer();

                // Reset accumulation when canvas size changes to avoid artifacts
                resetAccumulation();
            }
        }

        async function initWebGPUAndCompileShaders() {
            try {
                // Ensure a clean state if re-initializing
                if (device) {
                    device.destroy();
                    device = null;
                }

                loadingStatusP.textContent = "Checking WebGPU support...";
                if (!navigator.gpu) {
                    throw new Error("WebGPU not supported in your browser. Please try Chrome Canary or Edge Canary with flags enabled.");
                }

                loadingStatusP.textContent = "Requesting GPU adapter...";
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error("No appropriate GPU adapter found. Ensure your graphics drivers are up to date.");
                }

                loadingStatusP.textContent = "Requesting GPU device...";
                device = await adapter.requestDevice();
                if (!device) {
                    throw new Error("Could not acquire a WebGPU device.");
                }
                console.log("WebGPU device successfully acquired.");
                loadingStatusP.textContent = "GPU device acquired. Configuring canvas...";

                // --- Device Lost Handling ---
                device.lost.then((info) => {
                    console.error(`WebGPU device lost: ${info.message}`, info); // Log the full info object
                    let detailedMessage = `WebGPU device lost! Reason: ${info.reason || 'Unknown'}. This is a critical error indicating the GPU is no longer available for rendering.`;

                    detailedMessage += "

Common causes & Troubleshooting (see console for more specific error codes if available):";
                    if (info.reason === 'destroyed') {
                        detailedMessage += "
- The device was intentionally destroyed. If this was unexpected, it might indicate a bug in the application's cleanup logic.";
                    } else {
                        detailedMessage += "
- **Scene Complexity:** The rendering task might be too demanding. This is a common cause. Try reducing settings like 'Number of Spheres', 'Max Bounces', 'Max Raymarch Steps', 'Shadow Samples', and 'DOF Samples'. These can be adjusted from the main menu settings before starting, or in the scene controls if accessible.";
                        detailedMessage += "
- **GPU/Driver Issues:** Outdated or unstable graphics drivers are a frequent culprit. Ensure your drivers are fully updated directly from the manufacturer (NVIDIA, AMD, Intel).";
                        detailedMessage += "
- **Browser Issues:** Try a different WebGPU-compatible browser (latest Chrome or Edge is recommended). Sometimes browser updates or specific flags can affect stability.";
                        detailedMessage += "
- **System Resources:** Insufficient system memory (RAM) or GPU memory (VRAM) can lead to device loss, especially with complex scenes.";
                        detailedMessage += "
- **Overheating:** Check if your GPU is overheating, which can cause instability.";
                        detailedMessage += "
- **Hardware Problems:** In rare cases, this could indicate a problem with the GPU hardware itself.";
                        detailedMessage += "
- **System Sleep/Wake:** Recovering from system sleep can sometimes cause WebGPU issues. Try restarting the browser.";
                    }

                    detailedMessage += "

Recommended immediate actions:";
                    detailedMessage += "
1. Try refreshing the page. This might resolve temporary issues.";
                    detailedMessage += "
2. If the problem persists, try reducing settings via the main menu before starting the raytracer.";
                    detailedMessage += "
3. Restart your browser. If that doesn't help, restart your computer.";
                    detailedMessage += "

If the issue continues, please check the console log (Press F12, go to Console) for more technical details and report them if seeking help.";

                    displayErrorMessage(detailedMessage);
                    // Stop render loop
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    // Attempt to switch to menu view, but be aware the device is lost, so UI might be impaired.
                    try {
                        switchView('menu');
                    } catch (uiError) {
                        console.error("Error switching view after device loss:", uiError);
                        // Fallback: display a very simple message if primary UI is broken
                        if (document.body) {
                            document.body.innerHTML = '<div style="color:white; padding: 20px; font-family: sans-serif; text-align: center;">Critical GPU Error: Device Lost. Please refresh or restart your browser.</div>';
                        }
                    }
                });
                // --- End Device Lost Handling ---

                context = canvas.getContext('webgpu');
                if (!context) { throw new Error("Failed to get WebGPU context."); }

                const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                context.configure({ device, format: presentationFormat, alphaMode: 'opaque', size: [canvas.width, canvas.height] });
                console.log("Canvas context configured.");

                // --- IMPORTANT CHANGE: Create ping-pong textures and sampler before pipelines ---
                createPingPongTextures(); // Initialize both textures
                // FIX: Changed sampler filters to 'nearest' for unfilterable rgba32float textures
                outputSampler = device.createSampler({ minFilter: 'nearest', magFilter: 'nearest' });
                // --- END IMPORTANT CHANGE ---

                loadingStatusP.textContent = "Creating uniform buffers...";

                // CameraUBO buffer creation: 96 bytes (24 floats)
                cameraUBOBuffer = device.createBuffer({ size: 96, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

                // LightUBO buffer creation: 64 bytes (16 floats) - Corrected size
                lightUBOBuffer = device.createBuffer({ size: 64, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

                timeUBOBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
                waterUBOBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
                terrainUBOBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

                // RaytracerUBO buffer creation: 48 bytes (12 floats)
                raytracerUBOBuffer = device.createBuffer({ size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

                loadingStatusP.textContent = "Preparing rendering assets...";

                const renderQuadVertices = new Float32Array([
                    -1.0, -1.0,  // Bottom-left
                     1.0, -1.0,  // Bottom-right
                    -1.0,  1.0,  // Top-left
                    -1.0,  1.0,  // Top-left (duplicate for second triangle)
                     1.0, -1.0,  // Bottom-right (duplicate for second triangle)
                     1.0,  1.0,  // Top-right
                ]);
                renderQuadVertexBuffer = device.createBuffer({
                    size: renderQuadVertices.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });
                validateAndWriteBuffer('renderQuadVertexBuffer', 'initWebGPUAndCompileShaders', renderQuadVertexBuffer, 0, renderQuadVertices);

                loadingStatusP.textContent = "Compiling compute shader...";
                const computeShaderCode = `
                // Perlin Noise Permutation Table (512 elements = 256 duplicated)
                // CRITICAL REMINDER: Ensure all u32 literals have the 'u' suffix.
                // Syntax for array initialization is array<Type, Size>(...).
                var<private> perm: array<u32, 512> = array<u32, 512>(
                    151u, 160u, 137u, 91u, 90u, 15u, 131u, 13u, 201u, 95u, 96u, 53u, 194u, 233u, 7u, 225u,
                    140u, 36u, 103u, 30u, 69u, 142u, 8u, 99u, 37u, 240u, 21u, 10u, 23u, 190u, 6u, 148u,
                    247u, 120u, 234u, 75u, 0u, 26u, 197u, 62u, 94u, 252u, 219u, 203u, 117u, 35u, 11u, 32u,
                    57u, 177u, 33u, 88u, 237u, 149u, 56u, 87u, 178u, 119u, 246u, 76u, 138u, 161u, 134u, 107u,
                    97u, 28u, 164u, 73u, 204u, 159u, 125u, 158u, 215u, 116u, 176u, 31u, 250u, 189u, 155u, 109u,
                    144u, 20u, 93u, 63u, 128u, 91u, 124u, 66u, 165u, 179u, 113u, 220u, 243u, 166u, 136u, 61u,
                    100u, 175u, 195u, 48u, 122u, 198u, 139u, 79u, 184u, 167u, 106u, 80u, 200u, 127u, 43u, 239u,
                    77u, 181u, 129u, 232u, 251u, 248u, 47u, 185u, 49u, 224u, 245u, 153u, 168u, 13u, 130u, 24u,
                    170u, 105u, 104u, 154u, 196u, 1u, 38u, 126u, 78u, 244u, 140u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u, 110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u,
                    60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u, 197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u, 110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u,
                    60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u, 197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    // --- Start of Duplicated Elements to reach 512 ---
                    151u, 160u, 137u, 91u, 90u, 15u, 131u, 13u, 201u, 95u, 96u, 53u, 194u, 233u, 7u, 225u,
                    140u, 36u, 103u, 30u, 69u, 142u, 8u, 99u, 37u, 240u, 21u, 10u, 23u, 190u, 6u, 148u,
                    247u, 120u, 234u, 75u, 0u, 26u, 197u, 62u, 94u, 252u, 219u, 203u, 117u, 35u, 11u, 32u,
                    57u, 177u, 33u, 88u, 237u, 149u, 56u, 87u, 178u, 119u, 246u, 76u, 138u, 161u, 134u, 107u,
                    97u, 28u, 164u, 73u, 204u, 159u, 125u, 158u, 215u, 116u, 176u, 31u, 250u, 189u, 155u, 109u,
                    144u, 20u, 93u, 63u, 128u, 91u, 124u, 66u, 165u, 179u, 113u, 220u, 243u, 166u, 136u, 61u,
                    100u, 175u, 195u, 48u, 122u, 198u, 139u, 79u, 184u, 167u, 106u, 80u, 200u, 127u, 43u, 239u,
                    77u, 181u, 129u, 232u, 251u, 248u, 47u, 185u, 49u, 224u, 245u, 153u, 168u, 13u, 130u, 24u,
                    170u, 105u, 104u, 154u, 196u, 1u, 38u, 126u, 78u, 244u, 140u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u, 110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u,
                    60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u, 197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u, 110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u,
                    60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u, 197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u
                );

                // Perlin Noise Gradient Table (12 elements)
                var<private> grad3: array<vec3<f32>, 12> = array<vec3<f32>, 12>(
                    vec3<f32>(1.0f, 1.0f, 0.0f), vec3<f32>(-1.0f, 1.0f, 0.0f), vec3<f32>(1.0f, -1.0f, 0.0f), vec3<f32>(-1.0f, -1.0f, 0.0f),
                    vec3<f32>(1.0f, 0.0f, 1.0f), vec3<f32>(-1.0f, 0.0f, 1.0f), vec3<f32>(1.0f, 0.0f, -1.0f), vec3<f32>(-1.0f, 0.0f, -1.0f),
                    vec3<f32>(0.0f, 1.0f, 1.0f), vec3<f32>(0.0f, -1.0f, 1.0f), vec3<f32>(0.0f, 1.0f, -1.0f), vec3<f32>(0.0f, -1.0f, -1.0f)
                );

                // Helper for modulo 289
                fn mod289(x: vec3<f32>) -> vec3<f32> { return x - floor(x / 289.0f) * 289.0f; }
                fn mod289_f(x: f32) -> f32 { return x - floor(x / 289.0f) * 289.0f; }

                // Hash function for Perlin noise
                fn hash_grad(x: u32, y: u32, z: u32) -> u32 {
                    return perm[ (perm[ (perm[x % 256u] + y) % 256u ] + z) % 256u ];
                }

                // Classic Perlin Noise 3D
                fn snoise(p: vec3<f32>) -> f32 {
                    let F3 = 1.0f/3.0f; // F3 = (sqrt(3.0)-1.0)/3.0
                    let G3 = 1.0f/6.0f; // G3 = (3.0-sqrt(3.0))/6.0

                    let s = (p.x + p.y + p.z) * F3;
                    let i_float = floor(p + vec3<f32>(s, s, s));
                    let t = (i_float.x + i_float.y + i_float.z) * G3;
                    let x0 = p - i_float + vec3<f32>(t, t, t);

                    let g = step(x0.xyz, x0.yzx); // Determines order of dimensions
                    let l = 1.0f - g;
                    let i1 = min(g.xyz, l.yzx); // (0,0,0) or (1,0,0) or (0,1,0) etc.
                    let i2 = max(g.xyz, l.yzx); // (1,1,0) or (1,0,1) etc.

                    let i_u32 = vec3<u32>(u32(i_float.x), u32(i_float.y), u32(i_float.z));
                    let ii = i_u32 % 256u; // Modulo to wrap permutation table

                    let x1 = x0 - i1 + G3;
                    let x2 = x0 - i2 + 2.0f * G3;
                    let x3 = x0 - 1.0f + 3.0f * G3; // Final corner point at (1,1,1) offset

                    // Hashed gradients for the 4 simplex corners
                    let gi0 = hash_grad(ii.x, ii.y, ii.z);
                    let gi1 = hash_grad(ii.x + u32(i1.x), ii.y + u32(i1.y), ii.z + u32(i1.z));
                    let gi2 = hash_grad(ii.x + u32(i2.x), ii.y + u32(i2.y), ii.z + u32(i2.z));
                    let gi3 = hash_grad(ii.x + 1u, ii.y + 1u, ii.z + 1u);

                    // Contribution from each corner
                    let n0 = dot(grad3[gi0 % 12u], x0);
                    let n1 = dot(grad3[gi1 % 12u], x1);
                    let n2 = dot(grad3[gi2 % 12u], x2);
                    let n3 = dot(grad3[gi3 % 12u], x3);

                    // Attenuation factors (0.5 - distance squared)
                    let t0 = 0.5f - dot(x0, x0);
                    let t1 = 0.5f - dot(x1, x1);
                    let t2 = 0.5f - dot(x2, x2);
                    let t3 = 0.5f - dot(x3, x3);

                    var sum: f32 = 0.0f;
                    if (t0 >= 0.0f) { sum += pow(t0, 4.0f) * n0; }
                    if (t1 >= 0.0f) { sum += pow(t1, 4.0f) * n1; }
                    if (t2 >= 0.0f) { sum += pow(t2, 4.0f) * n2; }
                    if (t3 >= 0.0f) { sum += pow(t3, 4.0f) * n3; }

                    return 32.0f * sum; // Scale factor 32.0 (standard for Snoise output range [-1, 1])
                }

                // Random float generator based on screen coordinates and a seed
                // global_id_xy is used to ensure randomness varies per pixel
                fn rand_float(co: vec2<f32>, seed: f32) -> f32 {
                    return fract(sin(dot(co.xy + vec2<f32>(seed, seed), vec2<f32>(12.9898f, 78.233f))) * 43758.5453f);
                }

                // Fractional Brownian Motion (fBm) for more complex noise
                fn fBm(p: vec3<f32>) -> f32 {
                    var total: f32 = 0.0f;
                    var frequency: f32 = 1.0f;
                    var amplitude: f32 = 0.5f;
                    for (var i: u32 = 0u; i < 8u; i = i + 1u) { // 8 octaves
                        total += snoise(p * frequency) * amplitude;
                        frequency *= 2.0f;
                        amplitude *= 0.5f;
                    }
                    return total;
                }

                // Uniform Buffer Object (UBO) structures - must match JS side packing
                struct CameraUniform {
                    position: vec3<f32>, _padding0: f32, // vec4 alignment
                    forward: vec3<f32>, _padding1: f32,  // vec4 alignment
                    right: vec3<f32>, _padding2: f32,    // vec4 alignment
                    up: vec3<f32>, _padding3: f32,      // vec4 alignment
                    resolution: vec2<f32>, aspect: f32, fovy: f32, // 3 floats total
                    near: f32, far: f32, _padding4: vec2<f32>, // 2 floats + vec2 padding to align to 16 bytes
                };

                struct LightUniform {
                    position: vec3<f32>, brightness: f32, // vec4 alignment
                    size: f32, _padding0: vec3<f32>,     // float + vec3 padding to vec4
                    color: vec3<f32>, _padding1: f32,    // vec3 + float padding to vec4
                };

                // Sphere storage buffer struct
                struct Sphere {
                    position_radius: vec4<f32>, // xyz = position, w = radius
                    albedo_metallic: vec4<f32>, // xyz = albedo color, w = metallic
                    pbr_properties: vec4<f32>,  // x = roughness, y = baseReflectivity, z = materialType (u32), w = refractiveIndex
                };

                // BVH Node storage buffer struct
                struct BvhNode {
                    minBounds: vec3<f32>, isLeaf: u32,          // min corner, 1 if leaf, 0 if internal
                    maxBounds: vec3<f32>, primitiveCount: u32,  // max corner, number of primitives if leaf
                    leftChildOrFirstPrimitiveIndex: u32, _padding: vec3<u32>, // index to child node or first primitive
                };

                struct WaterParams {
                    strength: f32, frequency: f32, speed: f32, _padding: f32, // vec4
                };
                struct TerrainParams {
                    heightScale: f32, frequency: f32, _padding0: f32, _padding1: f32, // vec4
                };
                struct TimeUniform {
                    time: f32, frame_count: u32, _padding0: vec2<f32>, // time and frame count for accumulation
                };

                struct RaytracerParams {
                    maxBounces: u32,
                    maxRaymarchSteps: u32,
                    shadowSamples: u32,
                    dofSamples: u32,       // 4 x u32 (16 bytes)

                    numBVHNodes: u32,
                    numPrimitives: u32,
                    skyPreset: u32,
                    _padding0: u32,        // Padding for vec4 alignment (16 bytes total with above)

                    warpStrength: f32,
                    focalDistance: f32,
                    apertureSize: f32,
                    _padding1: f32,        // Padding for vec4 alignment (16 bytes total with above)
                };

                // Material type constants
                const MATERIAL_DIFFUSE: u32 = 0u;
                const MATERIAL_REFLECTIVE: u32 = 1u;
                const MATERIAL_REFRACTIVE: u32 = 2u;

                // Bind group 0: Uniforms and Ping-Pong Textures
                @group(0) @binding(0) var<uniform> cameraUBO: CameraUniform;
                @group(0) @binding(1) var<uniform> lightUBO: LightUniform;
                @group(0) @binding(2) var<uniform> raytracerUBO: RaytracerParams;
                @group(0) @binding(3) var<uniform> timeUBO: TimeUniform;
                @group(0) @binding(4) var<uniform> waterUBO: WaterParams;
                @group(0) @binding(5) var<uniform> terrainUBO: TerrainParams;
                @group(0) @binding(6) var outputTexture: texture_storage_2d<rgba32float, write>; // For writing current frame
                @group(0) @binding(7) var inputTexture: texture_2d<f32>; // For reading previous frame (for accumulation)

                // Bind group 1: Storage buffers (Spheres, BVH)
                @group(1) @binding(0) var<storage, read> spheres: array<Sphere>;
                @group(1) @binding(1) var<storage, read> bvhNodes: array<BvhNode>;
                @group(1) @binding(2) var<storage, read> primitiveIndices: array<u32>;

                const MIN_DIST: f32 = 0.0001f;
                const MAX_DIST: f32 = 1000.0f; // Increased max distance for larger scenes
                const EPSILON: f32 = 0.001f; // Small epsilon for ray marching and normal calculation
                const STACK_SIZE: u32 = 64u; // For BVH traversal stack

                const PI: f32 = 3.14159265359f;

                // Ray structure
                struct Ray {
                    origin: vec3<f32>,
                    direction: vec3<f32>,
                };

                // Hit information structure
                struct HitInfo {
                    hit_pos: vec3<f32>,
                    normal: vec3<f32>,
                    distance: f32,
                    is_hit: bool,
                    object_id: u32, // 0: terrain, 1: water, 2+: sphere index + 2
                    sphere_idx: u32, // Actual index in spheres array if object_id >= 2
                    is_water: bool, // Convenience flag
                };

                // Clamps a float value between min_val and max_val
                fn clamp_f(value: f32, min_val: f32, max_val: f32) -> f32 {
                    return max(min(value, max_val), min_val);
                }

                // Applies a domain warp using Perlin noise
                fn domainWarp(p: vec3<f32>, time: f32, strength: f32) -> vec3<f32> {
                    if (strength == 0.0f) { return p; }
                    let offset_factor = vec3<f32>(
                        snoise(p * 0.5f + time * 0.1f + vec3<f32>(10.0f, 20.0f, 30.0f)),
                        snoise(p * 0.7f - time * 0.2f + vec3<f32>(40.0f, 50.0f, 60.0f)),
                        snoise(p * 0.9f + time * 0.3f + vec3<f32>(70.0f, 80.0f, 90.0f))
                    );
                    return p + offset_factor * strength;
                }

                // Calculates terrain height using fBm noise
                fn terrainHeight(x: f32, z: f32, time: f32) -> f32 {
                    if (terrainUBO.heightScale == 0.0f) { return -100000.0f; } // Effectively disabled
                    let p_large_scale = vec3<f32>(x, z, time * 0.01f) * 0.05f; // Make noise larger scale
                    let large_scale_noise = fBm(p_large_scale);

                    let p_detail_scale = vec3<f32>(x, z, time * 0.05f) * terrainUBO.frequency;
                    let detail_noise = fBm(p_detail_scale);

                    let center_dist = distance(vec2<f32>(x, z), vec2<f32>(0.0f, 0.0f));
                    let island_shape_factor = smoothstep(150.0f, 0.0f, center_dist); // Soften terrain edges

                    let base_height = (0.5f + 0.5f * large_scale_noise * 0.6f) + (0.5f + 0.5f * detail_noise * 0.4f);
                    let scaled_height_from_noise = (base_height / 2.0f) * terrainUBO.heightScale;
                    return max(-2.0f, scaled_height_from_noise * island_shape_factor); // Clamp minimum height
                }

                // Calculates water wave height
                fn calculateWaveHeight(x: f32, z: f32, time: f32) -> f32 {
                    var h: f32 = 0.0f;
                    let initial_freq = waterUBO.frequency;
                    let initial_strength = waterUBO.strength;

                    // Sum of multiple sine waves for more complex water surface
                    h += sin(x * initial_freq + time * waterUBO.speed) * initial_strength * 0.7f;
                    h += cos(z * initial_freq * 1.5f + time * waterUBO.speed * 0.8f) * initial_strength * 0.5f;
                    h += sin((x + z) * initial_freq * 0.8f + time * waterUBO.speed * 1.2f) * initial_strength * 0.3f;

                    return h;
                }

                // Signed Distance Function (SDF) for water plane
                fn sdWaterPlane(p: vec3<f32>, time: f32, warp_strength: f32) -> f32 {
                    let warped_p = domainWarp(p, time * 0.5f, warp_strength);
                    return warped_p.y - calculateWaveHeight(warped_p.x, warped_p.z, time);
                }

                // Signed Distance Function (SDF) for a sphere
                fn sdSphere(p: vec3<f32>, s: Sphere, warp_strength: f32) -> f32 {
                    let warped_center = domainWarp(s.position_radius.xyz, timeUBO.time * 0.5f, warp_strength);
                    return distance(p, warped_center) - s.position_radius.w;
                }

                // AABB intersection for BVH traversal
                fn intersect_aabb(ray_origin: vec3<f32>, ray_inv_dir: vec3<f32>, min_bounds: vec3<f32>, max_bounds: vec3<f32>) -> f32 {
                    let t1 = (min_bounds - ray_origin) * ray_inv_dir;
                    let t2 = (max_bounds - ray_origin) * ray_inv_dir;

                    let t_min_vec = min(t1, t2);
                    let t_max_vec = max(t1, t2);

                    let t_enter = max(max(t_min_vec.x, t_min_vec.y), t_min_vec.z);
                    let t_exit = min(min(t_max_vec.x, t_max_vec.y), t_max_vec.z);

                    if (t_enter > t_exit || t_exit < 0.0f) {
                        return -1.0f; // No intersection or AABB is behind ray origin
                    }
                    return max(0.0f, t_enter); // Return the entry point (or 0 if origin is inside)
                }

                // BVH-accelerated sphere scene SDF. Finds the closest sphere.
                fn bvh_scene_sdf_spheres(ray_origin: vec3<f32>, ray_direction: vec3<f32>,
                                         current_time: f32, warp_strength: f32,
                                         closest_dist: ptr<function, f32>, closest_sphere_idx: ptr<function, u32>) {

                    // Early exit if no BVH or primitives
                    if (raytracerUBO.numPrimitives == 0u || raytracerUBO.numBVHNodes == 0u) { return; }

                    var inv_dir = 1.0f / ray_direction; // Precompute inverse direction for AABB intersection
                    var node_stack: array<u32, STACK_SIZE>; // Stack for BVH traversal
                    var stack_ptr: u32 = 0u;
                    var current_node_idx = 0u; // Start at root node (index 0)
                    // Safeguard array upper bounds using max(1u, count) - 1u to prevent underflow if count is 0
                    let max_node_idx = select(0u, raytracerUBO.numBVHNodes - 1u, raytracerUBO.numBVHNodes > 0u);
                    let max_prim_idx = select(0u, raytracerUBO.numPrimitives - 1u, raytracerUBO.numPrimitives > 0u);

                    // BVH traversal loop
                    for (var iter: u32 = 0u; iter < 1024u; iter = iter + 1u) { // Max iterations to prevent infinite loops
                        if (stack_ptr >= STACK_SIZE) { break; } // Prevent stack overflow

                        // Safeguard current_node_idx before accessing bvhNodes
                        current_node_idx = clamp(current_node_idx, 0u, max_node_idx);
                        if (raytracerUBO.numBVHNodes == 0u) { break; } // Early exit if no BVH nodes

                        let node = bvhNodes[current_node_idx];
                        let t = intersect_aabb(ray_origin, inv_dir, node.minBounds, node.maxBounds);

                        // If no intersection with current node's AABB, or current hit is closer than AABB exit
                        if (t == -1.0f || t > *closest_dist) {
                            if (stack_ptr == 0u) { break; } // If stack is empty, no more nodes to visit
                            stack_ptr = stack_ptr - 1u;
                            current_node_idx = node_stack[stack_ptr]; // Pop next node from stack
                            continue; // Continue to next iteration to process the popped node
                        }

                        if (node.isLeaf == 1u) { // If it's a leaf node
                            // Only process primitives if there are any and the buffer is valid
                            if (raytracerUBO.numPrimitives > 0u) {
                                for (var i: u32 = 0u; i < node.primitiveCount; i = i + 1u) {
                                    // Safeguard primitiveIndices access
                                    let prim_access_idx = clamp(node.leftChildOrFirstPrimitiveIndex + i, 0u, max_prim_idx);
                                    var sphere_original_idx = primitiveIndices[prim_access_idx];

                                    // Safeguard spheres access (original index from primitiveIndices should be valid, but clamp as defense)
                                    sphere_original_idx = clamp(sphere_original_idx, 0u, max_prim_idx);
                                    let s = spheres[sphere_original_idx];
                                    let d = sdSphere(ray_origin, s, warp_strength);
                                    if (d < *closest_dist) {
                                        *closest_dist = d;
                                        *closest_sphere_idx = sphere_original_idx;
                                    }
                                }
                            }
                            if (stack_ptr == 0u) { break; }
                            stack_ptr = stack_ptr - 1u;
                            current_node_idx = node_stack[stack_ptr];
                        } else { // If it's an internal node
                            var left_child_idx = node.leftChildOrFirstPrimitiveIndex;
                            var right_child_idx = node.leftChildOrFirstPrimitiveIndex + 1u;

                            // Safeguard child indices before use or pushing to stack
                            left_child_idx = clamp(left_child_idx, 0u, max_node_idx);
                            right_child_idx = clamp(right_child_idx, 0u, max_node_idx);

                            // This safety check might be redundant due to clamping above, but good for defense.
                            if (left_child_idx >= raytracerUBO.numBVHNodes || right_child_idx >= raytracerUBO.numBVHNodes) {
                                if (stack_ptr == 0u) { break; }
                                stack_ptr = stack_ptr - 1u;
                                current_node_idx = node_stack[stack_ptr]; // Pop and continue
                                continue;
                            }

                            // Access bvhNodes with already clamped child indices
                            let t_left = intersect_aabb(ray_origin, inv_dir, bvhNodes[left_child_idx].minBounds, bvhNodes[left_child_idx].maxBounds);
                            let t_right = intersect_aabb(ray_origin, inv_dir, bvhNodes[right_child_idx].minBounds, bvhNodes[right_child_idx].maxBounds);

                            // Prioritize closer child and push farther child onto stack
                            // Child indices are already clamped from above.
                            if (t_left != -1.0f && t_right != -1.0f) {
                                if (t_left < t_right) {
                                    node_stack[stack_ptr] = right_child_idx;
                                    stack_ptr = stack_ptr + 1u;
                                    current_node_idx = left_child_idx;
                                } else {
                                    node_stack[stack_ptr] = left_child_idx;
                                    stack_ptr = stack_ptr + 1u;
                                    current_node_idx = right_child_idx;
                                }
                            } else if (t_left != -1.0f) {
                                current_node_idx = left_child_idx;
                            } else if (t_right != -1.0f) {
                                current_node_idx = right_child_idx;
                            } else {
                                if (stack_ptr == 0u) { break; }
                                stack_ptr = stack_ptr - 1u;
                                current_node_idx = node_stack[stack_ptr];
                            }
                        }
                    }
                }

                // Combines all scene SDFs to find the closest object
                fn sceneSDF(p: vec3<f32>, current_time: f32, warp_strength: f32, object_id: ptr<function, u32>) -> f32 {
                    var min_dist: f32 = MAX_DIST;
                    *object_id = 999u; // Default to 'no hit' ID

                    // Terrain SDF
                    let terrain_dist = p.y - terrainHeight(p.x, p.z, current_time);
                    if (terrain_dist < min_dist) {
                        min_dist = terrain_dist;
                        *object_id = 0u; // ID for terrain
                    }

                    // Water Plane SDF
                    let water_dist = sdWaterPlane(p, current_time, warp_strength);
                    if (water_dist < min_dist) {
                        min_dist = water_dist;
                        *object_id = 1u; // ID for water
                    }

                    // Spheres SDF (via BVH traversal)
                    // Only call if there are primitives and BVH nodes to avoid issues with empty buffers or zero counts
                    if (raytracerUBO.numPrimitives > 0u && raytracerUBO.numBVHNodes > 0u) {
                        var closest_sphere_dist = MAX_DIST;
                        var closest_sphere_original_idx: u32 = raytracerUBO.numPrimitives; // Initialize to an out-of-bounds index
                        bvh_scene_sdf_spheres(p, vec3<f32>(0.0f, 0.0f, 0.0f), current_time, warp_strength, &closest_sphere_dist, &closest_sphere_original_idx);
                        if (closest_sphere_dist < min_dist) {
                             // Ensure the returned index is valid before assigning
                            if (closest_sphere_original_idx < raytracerUBO.numPrimitives) {
                                min_dist = closest_sphere_dist;
                                *object_id = closest_sphere_original_idx + 2u; // Sphere IDs start from 2
                            }
                        }
                    }
                    return min_dist;
                }

                // Estimates the normal at a point using the SDF (finite difference)
                fn estimateNormal(p: vec3<f32>, current_time: f32, warp_strength: f32, object_id_hint: u32) -> vec3<f32> {
                    var id_dummy: u32 = 0u; // Dummy ID for SDF calls in normal estimation
                    let grad_x = sceneSDF(p + vec3<f32>(EPSILON, 0.0f, 0.0f), current_time, warp_strength, &id_dummy) - sceneSDF(p - vec3<f32>(EPSILON, 0.0f, 0.0f), current_time, warp_strength, &id_dummy);
                    let grad_y = sceneSDF(p + vec3<f32>(0.0f, EPSILON, 0.0f), current_time, warp_strength, &id_dummy) - sceneSDF(p - vec3<f32>(0.0f, EPSILON, 0.0f), current_time, warp_strength, &id_dummy);
                    let grad_z = sceneSDF(p + vec3<f32>(0.0f, 0.0f, EPSILON), current_time, warp_strength, &id_dummy) - sceneSDF(p - vec3<f32>(0.0f, 0.0f, EPSILON), current_time, warp_strength, &id_dummy);
                    return normalize(vec3<f32>(grad_x, grad_y, grad_z));
                }

                // Calculates the normal for the water plane
                fn calculateWaterNormal(p: vec3<f32>, time: f32, warp_strength: f32) -> vec3<f32> {
                    let warped_p = domainWarp(p, time * 0.5f, warp_strength);
                    let x = warped_p.x;
                    let z = warped_p.z;
                    let h_base = calculateWaveHeight(x, z, time);
                    let eps = 0.001f;
                    let h_x = calculateWaveHeight(x + eps, z, time);
                    let h_z = calculateWaveHeight(x, z + eps, time);
                    let nx = -(h_x - h_base) / eps;
                    let ny = 1.0f;
                    let nz = -(h_z - h_base) / eps;
                    return normalize(vec3<f32>(nx, ny, nz));
                }

                // Calculates the normal for the terrain
                fn calculateTerrainNormal(p: vec3<f32>, current_time: f32, warp_strength: f32) -> vec3<f32> {
                    let warped_p = domainWarp(p, current_time * 0.5f, warp_strength);
                    let x = warped_p.x;
                    let z = warped_p.z;
                    let h_base = terrainHeight(x, z, current_time);
                    let eps = 0.001f;
                    let h_x = terrainHeight(x + eps, z, current_time);
                    let h_z = terrainHeight(x, z + eps, current_time);
                    let nx = -(h_x - h_base) / eps;
                    let ny = 1.0f;
                    let nz = -(h_z - h_base) / eps;
                    return normalize(vec3<f32>(nx, ny, nz));
                }

                // Raymarcher function
                fn raymarch(ray: Ray, current_time: f32, warp_strength: f32) -> HitInfo {
                    var hit_info: HitInfo;
                    hit_info.is_hit = false;
                    hit_info.distance = MAX_DIST;
                    hit_info.sphere_idx = 0u; // Default
                    hit_info.is_water = false;

                    var total_distance_marched: f32 = 0.0f;
                    var current_object_id_in_loop: u32 = 999u; // ID returned by sceneSDF

                    for (var i: u32 = 0u; i < raytracerUBO.maxRaymarchSteps; i = i + 1u) {
                        let current_pos = ray.origin + ray.direction * total_distance_marched;
                        let d = sceneSDF(current_pos, current_time, warp_strength, &current_object_id_in_loop);

                        if (d < MIN_DIST) { // Hit
                            hit_info.is_hit = true;
                            hit_info.hit_pos = current_pos;
                            hit_info.distance = total_distance_marched;
                            hit_info.object_id = current_object_id_in_loop;

                            if (current_object_id_in_loop == 1u) { // Water
                                hit_info.normal = calculateWaterNormal(current_pos, current_time, warp_strength);
                                hit_info.is_water = true;
                            } else if (current_object_id_in_loop == 0u) { // Terrain
                                hit_info.normal = calculateTerrainNormal(current_pos, current_time, warp_strength);
                                hit_info.is_water = false;
                            }
                            else { // Sphere
                                hit_info.sphere_idx = current_object_id_in_loop - 2u; // Convert object ID back to sphere array index
                                hit_info.normal = estimateNormal(current_pos, current_time, warp_strength, current_object_id_in_loop);
                                hit_info.is_water = false;
                            }
                            break;
                        }

                        total_distance_marched += d;
                        if (total_distance_marched >= MAX_DIST) {
                            break; // Ray went too far
                        }
                    }
                    return hit_info;
                }

                // Calculates sky color based on ray direction and sky preset
                fn getSkyColor(ray_dir: vec3<f32>, sky_preset: u32) -> vec3<f32> {
                    let sun_dir = normalize(lightUBO.position.xyz);
                    let sun_dot = dot(ray_dir, sun_dir);
                    let sun_intensity = smoothstep(0.99f, 1.0f, sun_dot); // Sharp falloff for sun disk
                    let sun_color_base = lightUBO.color * sun_intensity * lightUBO.brightness;

                    var sky_color_top: vec3<f32>;
                    var sky_color_horizon: vec3<f32>;

                    if (sky_preset == 0u) { // Sunny Day
                        sky_color_top = vec3<f32>(0.5f, 0.7f, 1.0f);
                        sky_color_horizon = vec3<f32>(0.7f, 0.8f, 0.9f);
                    } else { // Dusk
                        sky_color_top = vec3<f32>(0.6f, 0.7f, 0.85f);
                        sky_color_horizon = vec3<f32>(1.0f, 0.8f, 0.6f);
                    }

                    let y_factor = max(0.0f, ray_dir.y); // Vertical position in sky (0=horizon, 1=zenith)
                    let gradient_color = mix(sky_color_horizon, sky_color_top, y_factor);

                    // Basic clouds using Perlin noise
                    let cloud_coverage: f32 = 0.5f;
                    let cloud_density: f32 = 0.8f;
                    let cloud_detail: f32 = 0.1f;

                    let cloud_uv = ray_dir.xz * 10.0f;
                    let cloud_noise = snoise(vec3<f32>(cloud_uv.x, ray_dir.y * 5.0f, cloud_uv.y + timeUBO.time * 0.05f));
                    let clouds = smoothstep(cloud_coverage - cloud_detail, cloud_coverage + cloud_detail, cloud_noise) * cloud_density;

                    let final_sky_color = mix(gradient_color, vec3<f32>(0.9f, 0.9f, 0.9f), clouds); // Mix sky with cloud color
                    return final_sky_color + sun_color_base;
                }

                // PBR functions (GGX NDF, GeometrySchlickGGX, GeometrySmith, FresnelSchlickPBR)
                fn DistributionGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {
                    let a = roughness*roughness;
                    let a2 = a*a;
                    let NdotH = max(dot(N, H), 0.0f);
                    let NdotH2 = NdotH*NdotH;
                    let nom   = a2;
                    var denom = (NdotH2 * (a2 - 1.0f) + 1.0f);
                    denom = PI * denom * denom;
                    return nom / max(denom, 0.0000001f); // Prevent division by zero
                }

                fn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
                    let r = (roughness + 1.0f);
                    let k = (r*r) / 8.0f; // This is a simplification for direct lighting
                    let nom   = NdotV;
                    let denom = NdotV * (1.0f - k) + k;
                    return nom / max(denom, 0.0000001f); // Prevent division by zero
                }

                fn GeometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {
                    let NdotV = max(dot(N, V), 0.0f);
                    let NdotL = max(dot(N, L), 0.0f);
                    let ggx2 = GeometrySchlickGGX(NdotV, roughness);
                    let ggx1 = GeometrySchlickGGX(NdotL, roughness);
                    return ggx1 * ggx2;
                }

                fn FresnelSchlickPBR(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {
                    return F0 + (vec3<f32>(1.0f) - F0) * pow(clamp(1.0f - cosTheta, 0.0f, 1.0f), 5.0f);
                }

                // Calculates PBR lighting for a hit point
                // global_id_xy parameter is crucial for per-pixel random numbers
                fn calculateLighting(hit_pos: vec3<f32>, N: vec3<f32>, V: vec3<f32>, current_time: f32,
                                     albedo: vec3<f32>, metallic: f32, roughness: f32, base_reflectivity: f32,
                                     is_in_water_medium_flag: u32, global_id_xy: vec2<u32>) -> vec3<f32> {

                    var Lo = vec3<f32>(0.0f); // Total outgoing radiance
                    var ambient_color = albedo * 0.02f; // Simple ambient
                    if (is_in_water_medium_flag == 1u) { ambient_color = albedo * 0.04f; } // Slightly brighter ambient underwater

                    // F0 is base reflectivity, mix with albedo based on metallic
                    let F0 = mix(vec3<f32>(base_reflectivity), albedo, metallic);

                    let num_shadow_samples = max(1u, raytracerUBO.shadowSamples); // Ensure at least 1 sample
                    let light_center_dir = normalize(lightUBO.position.xyz - hit_pos);
                    let light_to_hit_dist = distance(lightUBO.position.xyz, hit_pos);

                    // Create an orthonormal basis for the light source for area light sampling
                    var light_basis_u = normalize(cross(light_center_dir, vec3<f32>(0.0f, 1.0f, 0.0f)));
                    if (length(light_basis_u) < 0.1f) { // Fallback if light_center_dir is close to up vector
                        light_basis_u = normalize(cross(light_center_dir, vec3<f32>(1.0f, 0.0f, 0.0f)));
                    }
                    let light_basis_v = cross(light_basis_u, light_center_dir); // V is orthogonal to U and L

                    for (var s_idx: u32 = 0u; s_idx < num_shadow_samples; s_idx = s_idx + 1u) {
                        // Generate random offsets for soft shadows (stratified sampling)
                        let rand_u_val = rand_float(vec2<f32>(f32(global_id_xy.x), f32(global_id_xy.y)), timeUBO.time * 1.3f + f32(s_idx) * 7.7f);
                        let rand_v_val = rand_float(vec2<f32>(f32(global_id_xy.y), f32(global_id_xy.x)), timeUBO.time * 0.7f + f32(s_idx) * 11.3f);

                        // Uniform sampling in a disk
                        let angle = rand_u_val * 2.0f * PI;
                        let radius_scale = sqrt(rand_v_val); // Correct radial distribution
                        let offset_x = cos(angle) * radius_scale * lightUBO.size;
                        let offset_y = sin(angle) * radius_scale * lightUBO.size;

                        let perturbed_light_pos = lightUBO.position.xyz + light_basis_u * offset_x + light_basis_v * offset_y;
                        let L = normalize(perturbed_light_pos - hit_pos); // Light direction from hit point to perturbed light source

                        let shadow_ray_origin = hit_pos + N * MIN_DIST; // Offset origin slightly along normal
                        let occluder_dist = raymarch(Ray(shadow_ray_origin, L), current_time, raytracerUBO.warpStrength).distance;

                        // Determine shadow factor: 0.0 if occluded, 1.0 if clear
                        // Check if an occluder is closer than the light source, considering MIN_DIST epsilon
                        let shadow_factor = select(0.0f, 1.0f, occluder_dist >= light_to_hit_dist - MIN_DIST);

                        if (shadow_factor > 0.0f) { // Only add light if not in full shadow
                            let H = normalize(V + L); // Halfway vector
                            let NdotL = max(dot(N, L), 0.0f);
                            let NdotV = max(dot(N, V), 0.0f);
                            let NdotH = max(dot(N, H), 0.0f);
                            let VdotH = max(dot(V, H), 0.0f);

                            // D = Normal Distribution Function (GGX)
                            let D = DistributionGGX(N, H, roughness);

                            // G = Geometry Function (Schlick-GGX)
                            let G = GeometrySmith(N, V, L, roughness);

                            // F = Fresnel (Schlick Approximation)
                            let F = FresnelSchlickPBR(VdotH, F0);

                            // Calculate specular BRDF
                            let numerator = D * G * F;
                            let denominator = 4.0f * NdotV * NdotL;
                            let specular_brdf = numerator / max(denominator, 0.0000001f);

                            // kS = specular contribution, kD = diffuse contribution
                            let kS = F;
                            var kD = vec3<f32>(1.0f) - kS; // Remaining energy for diffuse
                            kD *= (1.0f - metallic); // Diffuse contribution is zero for full metallic

                            // Calculate diffuse BRDF
                            let diffuse_brdf = kD * albedo / PI; // Lambertian diffuse

                            // Radiance from light source
                            let radiance = lightUBO.brightness * lightUBO.color;

                            Lo += (diffuse_brdf + specular_brdf) * radiance * NdotL * shadow_factor;
                        }
                    }
                    Lo /= f32(num_shadow_samples); // Average contributions from all shadow samples
                    return ambient_color + Lo;
                }

                // Snell's Law for refraction
                fn snellsLaw(incident_dir: vec3<f32>, normal: vec3<f32>, n1: f32, n2: f32) -> vec3<f32> {
                    let cosThetaI = dot(-incident_dir, normal); // cos(angle of incidence)
                    let clamped_cosThetaI = clamp(cosThetaI, -1.0f, 1.0f);

                    let eta = n1 / n2; // Ratio of refractive indices
                    let sinThetaT2 = eta * eta * (1.0f - clamped_cosThetaI * clamped_cosThetaI); // sin^2(angle of refraction)

                    // Total internal reflection if sinThetaT2 > 1.0
                    if (sinThetaT2 > 1.0f) { return vec3<f32>(0.0f); }

                    let cosThetaT = sqrt(1.0f - sinThetaT2); // cos(angle of refraction)
                    return eta * incident_dir + (eta * clamped_cosThetaI - cosThetaT) * normal;
                }

                // Fresnel reflectance (Schlick's approximation) for dielectrics
                fn fresnelSchlick(cos_theta_i: f32, n1: f32, n2: f32) -> f32 {
                    let R0 = pow((n1 - n2) / (n1 + n2), 2.0f); // R0 for normal incidence
                    return R0 + (1.0f - R0) * pow(1.0f - cos_theta_i, 5.0f);
                }

                // Determines IORs and normal direction based on whether ray is entering or exiting
                fn get_ior_and_normal(incident_dir: vec3<f32>, normal: vec3<f32>, current_medium_ior: f32, object_ior: f32) -> array<f32, 6> {
                    var n1 = current_medium_ior;
                    var n2 = object_ior;
                    var adjusted_normal = normal;
                    var is_entering_object_float: f32 = 1.0f; // Return as float for consistent array type

                    if (dot(incident_dir, normal) > 0.0f) { // Ray is inside object, exiting
                        adjusted_normal = -normal; // Flip normal
                        n1 = object_ior;
                        n2 = current_medium_ior;
                        is_entering_object_float = 0.0f;
                    }
                    return array<f32, 6>(n1, n2, adjusted_normal.x, adjusted_normal.y, adjusted_normal.z, is_entering_object_float);
                }

                // Gets color for a sub-ray (reflected or refracted ray)
                // global_id_xy parameter is crucial for per-pixel random numbers
                fn get_color_from_sub_hit(ray: Ray, current_time: f32, is_sub_ray_in_water_medium_flag: u32, global_id_xy: vec2<u32>) -> vec3<f32> {
                    let hit_info = raymarch(ray, current_time, raytracerUBO.warpStrength);
                    let max_prim_idx_sub = select(0u, raytracerUBO.numPrimitives - 1u, raytracerUBO.numPrimitives > 0u);

                    if (!hit_info.is_hit) {
                        return getSkyColor(ray.direction, raytracerUBO.skyPreset);
                    } else if (hit_info.object_id == 0u) { // Hit terrain
                        let terrain_albedo = vec3<f32>(0.4f, 0.3f, 0.2f);
                        let terrain_metallic = 0.0f;
                        let terrain_roughness = 0.9f;
                        let terrain_base_reflectivity = 0.04f;
                        return calculateLighting(hit_info.hit_pos, hit_info.normal, -ray.direction, current_time, terrain_albedo, terrain_metallic, terrain_roughness, terrain_base_reflectivity, is_sub_ray_in_water_medium_flag, global_id_xy);
                    } else if (hit_info.object_id == 1u) { // Hit water
                        let water_albedo = vec3<f32>(0.1f, 0.3f, 0.5f);
                        let water_metallic = 0.0f;
                        let water_roughness = 0.1f;
                        let water_base_reflectivity = 0.04f;
                        return calculateLighting(hit_info.hit_pos, hit_info.normal, -ray.direction, current_time, water_albedo, water_metallic, water_roughness, water_base_reflectivity, is_sub_ray_in_water_medium_flag, global_id_xy);
                    } else { // Hit sphere
                        if (raytracerUBO.numPrimitives == 0u) { return vec3<f32>(0.0f, 0.0f, 1.0f); /* Blue for error: no primitives */ }
                        let safe_sphere_idx = clamp(hit_info.sphere_idx, 0u, max_prim_idx_sub); // Safeguard spheres access
                        let s = spheres[safe_sphere_idx];
                        let albedo = s.albedo_metallic.xyz;
                        let metallic = s.albedo_metallic.w;
                        let roughness = s.pbr_properties.x;
                        let base_reflectivity = s.pbr_properties.y;
                        return calculateLighting(hit_info.hit_pos, hit_info.normal, -ray.direction, current_time, albedo, metallic, roughness, base_reflectivity, is_sub_ray_in_water_medium_flag, global_id_xy);
                    }
                }

                // Main raytracing function for a single ray
                // global_id_xy parameter is crucial for per-pixel random numbers
                fn traceRay(initial_ray: Ray, current_time: f32, global_id_xy: vec2<u32>) -> vec4<f32> {
                    var final_color = vec3<f32>(0.0f);
                    var current_ray = initial_ray;
                    var current_weight = vec3<f32>(1.0f); // Ray contribution weight
                    var current_ior = 1.0f; // Current medium's Index of Refraction (IOR). Air is 1.0
                    let water_ior = 1.33f; // IOR for water
                    var is_in_water_medium_trace: u32 = 0u; // Flag for if current ray is inside water (u32 for WGSL)
                    let max_prim_idx_trace = select(0u, raytracerUBO.numPrimitives - 1u, raytracerUBO.numPrimitives > 0u);

                    for (var bounce_count: u32 = 0u; bounce_count < raytracerUBO.maxBounces; bounce_count = bounce_count + 1u) {
                        let hit_info = raymarch(current_ray, current_time, raytracerUBO.warpStrength);

                        if (!hit_info.is_hit) {
                            final_color += current_weight * getSkyColor(current_ray.direction, raytracerUBO.skyPreset);
                            break; // Ray escaped the scene
                        }

                        let N = hit_info.normal;
                        let hit_pos = hit_info.hit_pos;
                        let V = -current_ray.direction; // View direction (from hit point to ray origin)

                        // Update water medium flag
                        is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f); // If IOR is greater than air, assume in water

                        if (hit_info.object_id == 0u) { // Hit terrain
                            let terrain_albedo = vec3<f32>(0.4f, 0.3f, 0.2f);
                            let terrain_metallic = 0.0f;
                            let terrain_roughness = 0.9f;
                            let terrain_base_reflectivity = 0.04f;
                            final_color += current_weight * calculateLighting(hit_pos, N, V, current_time, terrain_albedo, terrain_metallic, terrain_roughness, terrain_base_reflectivity, is_in_water_medium_trace, global_id_xy);
                            break; // Diffuse surfaces terminate ray
                        }
                        else if (hit_info.object_id == 1u) { // Hit water surface
                            let water_surface_albedo = vec3<f32>(0.1f, 0.3f, 0.5f); // Color of water surface for diffuse/specular
                            let water_body_color_absorption = vec3<f32>(0.1f, 0.2f, 0.3f); // Color absorption through water
                            let water_metallic = 0.0f;
                            let water_roughness = 0.1f;
                            let water_base_reflectivity = 0.04f;

                            // Calculate IORs and normal for refraction/reflection
                            let iors_info = get_ior_and_normal(current_ray.direction, N, current_ior, water_ior);
                            let n1 = iors_info[0];
                            let n2 = iors_info[1];
                            let adjusted_normal = vec3<f32>(iors_info[2], iors_info[3], iors_info[4]);
                            let is_entering_object = u32(iors_info[5]); // 1 if entering water, 0 if exiting

                            // Add direct lighting to final color (surface properties)
                            final_color += current_weight * calculateLighting(hit_pos, N, V, current_time, water_surface_albedo, water_metallic, water_roughness, water_base_reflectivity, is_in_water_medium_trace, global_id_xy);

                            let reflected_dir = reflect(current_ray.direction, adjusted_normal);
                            let reflected_ray = Ray(hit_pos + reflected_dir * EPSILON, reflected_dir);

                            let refracted_dir = snellsLaw(current_ray.direction, adjusted_normal, n1, n2);
                            let cos_theta_i = dot(-current_ray.direction, adjusted_normal);
                            let fresnel_reflectance = fresnelSchlick(cos_theta_i, n1, n2);

                            // Handle refraction or total internal reflection
                            if (length(refracted_dir) > 0.0f && length(refracted_dir) > 0.001f) { // If refraction is possible (not TIR)
                                final_color += current_weight * fresnel_reflectance * get_color_from_sub_hit(reflected_ray, current_time, is_in_water_medium_trace, global_id_xy);
                                current_ray = Ray(hit_pos + refracted_dir * EPSILON * -1.0f, refracted_dir); // New ray for refraction
                                current_weight *= water_body_color_absorption * (1.0f - fresnel_reflectance); // Attenuate weight
                                current_ior = n2; // Update current medium IOR
                                is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);
                            } else { // Total Internal Reflection (TIR)
                                current_ray = reflected_ray; // Only reflection occurs
                                final_color += current_weight * fresnel_reflectance * get_color_from_sub_hit(reflected_ray, current_time, is_in_water_medium_trace, global_id_xy);
                                current_weight *= water_surface_albedo; // Apply surface albedo for reflection
                                break; // Ray terminated after reflection
                            }
                        }
                        else { // Hit a sphere
                            if (raytracerUBO.numPrimitives == 0u) { final_color += current_weight * vec3<f32>(1.0f,0.0f,1.0f); break; /* Magenta for error: no primitives */ }
                            let safe_sphere_idx = clamp(hit_info.sphere_idx, 0u, max_prim_idx_trace); // Safeguard spheres access
                            let s = spheres[safe_sphere_idx];
                            let albedo = s.albedo_metallic.xyz;
                            let metallic = s.albedo_metallic.w;
                            let roughness = s.pbr_properties.x;
                            let base_reflectivity = s.pbr_properties.y;
                            let material_type = u32(s.pbr_properties.z); // Convert float back to u32
                            let refractive_index_object = s.pbr_properties.w;

                            // Add direct lighting
                            final_color += current_weight * calculateLighting(hit_pos, N, V, current_time, albedo, metallic, roughness, base_reflectivity, is_in_water_medium_trace, global_id_xy);

                            if (material_type == MATERIAL_DIFFUSE) {
                                break; // Diffuse surfaces terminate ray
                            } else if (material_type == MATERIAL_REFLECTIVE) {
                                let reflected_dir = reflect(current_ray.direction, N);
                                current_ray = Ray(hit_pos + reflected_dir * EPSILON, reflected_dir); // New ray for reflection
                                current_weight *= albedo; // Attenuate weight by albedo
                            } else if (material_type == MATERIAL_REFRACTIVE) {
                                let iors_info = get_ior_and_normal(current_ray.direction, N, current_ior, refractive_index_object);
                                let n1 = iors_info[0];
                                let n2 = iors_info[1];
                                let adjusted_normal = vec3<f32>(iors_info[2], iors_info[3], iors_info[4]);

                                let cos_theta_i = dot(-current_ray.direction, adjusted_normal);
                                let fresnel_reflectance = fresnelSchlick(cos_theta_i, n1, n2);
                                let reflected_dir = reflect(current_ray.direction, adjusted_normal);
                                let reflected_ray_for_calc = Ray(hit_pos + reflected_dir * EPSILON, reflected_dir);

                                // Add reflected component
                                let reflected_contrib_color = get_color_from_sub_hit(reflected_ray_for_calc, current_time, is_in_water_medium_trace, global_id_xy);
                                final_color += current_weight * fresnel_reflectance * reflected_contrib_color;

                                let refracted_dir = snellsLaw(current_ray.direction, adjusted_normal, n1, n2);

                                // If refraction is possible (not TIR)
                                if (length(refracted_dir) > 0.0f && length(refracted_dir) > 0.001f) {
                                    let refracted_ray_for_calc = Ray(hit_pos + refracted_dir * EPSILON * -1.0f, refracted_dir); // Offset for exit
                                    let refracted_contrib_color = get_color_from_sub_hit(refracted_ray_for_calc, current_time, select(0u, 1u, n2 > 1.01f), global_id_xy); // Pass new IOR state
                                    final_color += current_weight * (1.0f - fresnel_reflectance) * albedo * refracted_contrib_color; // Attenuate by albedo for colored glass
                                    current_ior = n2; // Update current medium IOR
                                    is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);
                                }
                                break; // After refraction/reflection, ray terminates (for simplicity of this example)
                            }
                        }
                        // Stop if ray weight becomes too small
                        if (max(max(current_weight.x, current_weight.y), current_weight.z) < 0.01f) {
                            break;
                        }
                    }
                    return vec4<f32>(final_color, 1.0f);
                }

                // Main compute shader entry point. Dispatches one workgroup per pixel.
                @compute @workgroup_size(8, 8)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let screen_width = cameraUBO.resolution.x;
                    let screen_height = cameraUBO.resolution.y;

                    // Bounds check to avoid out-of-bounds writes
                    if (global_id.x >= u32(screen_width) || global_id.y >= u32(screen_height)) {
                        return;
                    }

                    var final_accumulated_color = vec3<f32>(0.0f);
                    let frag_coord_xy = vec2<f32>(f32(global_id.x), f32(global_id.y)); // Convert u32 to f32 for random functions

                    for (var dof_idx: u32 = 0u; dof_idx < raytracerUBO.dofSamples; dof_idx = dof_idx + 1u) {
                        // Generate random offsets for depth of field sampling
                        let rand_u_dof = rand_float(frag_coord_xy, timeUBO.time * 2.1f + f32(dof_idx) * 5.9f);
                        let rand_v_dof = rand_float(frag_coord_xy.yx, timeUBO.time * 1.7f + f32(dof_idx) * 9.1f);

                        // Concentric disk sampling for DOF
                        let angle_dof = rand_u_dof * 2.0f * PI;
                        let radius_scale = sqrt(rand_v_dof); // Correct radial distribution
                        let aperture_offset_x = cos(angle_dof) * radius_scale * raytracerUBO.apertureSize;
                        let aperture_offset_y = sin(angle_dof) * radius_scale * raytracerUBO.apertureSize;

                        // Perturb ray origin based on aperture size
                        let perturbed_origin = cameraUBO.position.xyz +
                                               cameraUBO.right.xyz * aperture_offset_x +
                                               cameraUBO.up.xyz * aperture_offset_y;

                        // Calculate ray direction through a virtual pixel on the image plane
                        let ndc_x: f32 = (f32(global_id.x) / screen_width) * 2.0f - 1.0f;
                        let ndc_y: f32 = (1.0f - f32(global_id.y) / screen_height) * 2.0f - 1.0f; // Invert Y for typical screen coords

                        let aspect_ratio = cameraUBO.aspect;
                        let fov_rad = cameraUBO.fovy;

                        // Ray direction in camera space
                        let ray_x = ndc_x * aspect_ratio * tan(fov_rad / 2.0f);
                        let ray_y = ndc_y * tan(fov_rad / 2.0f);
                        let ray_z = -1.0f; // Focal plane is at z=-1 in camera space

                        let ray_dir_camera_space = normalize(vec3<f32>(ray_x, ray_y, ray_z));

                        // Convert ideal ray direction to world space
                        let ideal_ray_direction_world = normalize(
                            ray_dir_camera_space.x * cameraUBO.right.xyz +
                            ray_dir_camera_space.y * cameraUBO.up.xyz +
                            ray_dir_camera_space.z * cameraUBO.forward.xyz
                        );

                        // Calculate focal point
                        let focal_point = cameraUBO.position.xyz + ideal_ray_direction_world * raytracerUBO.focalDistance;

                        // Calculate new ray direction from perturbed origin to focal point
                        let dof_ray_direction = normalize(focal_point - perturbed_origin);
                        let dof_ray = Ray(perturbed_origin, dof_ray_direction);

                        final_accumulated_color += traceRay(dof_ray, timeUBO.time, global_id.xy).xyz; // Pass global_id.xy for per-pixel randomness
                    }

                    let final_color_per_pixel = final_accumulated_color / f32(raytracerUBO.dofSamples);

                    // Accumulation: Blend current frame with previous frames (Ping-pong)
                    // FIX: Added '0u' for the mipmap level, required for textureLoad with texture_2d types.
                    let previous_color_vec4 = textureLoad(inputTexture, vec2<i32>(global_id.xy), 0u);
                    let current_frame_f32 = f32(timeUBO.frame_count);
                    // Blend factor for accumulation: 1 / (frame_count + 1)
                    let blend_factor = 1.0f / (current_frame_f32 + 1.0f);
                    let new_accumulated_color = mix(previous_color_vec4.rgb, final_color_per_pixel, blend_factor);

                    textureStore(outputTexture, vec2<i32>(global_id.xy), vec4<f32>(new_accumulated_color, 1.0f));
                }
                `;

                const renderShaderCode = `
                @group(0) @binding(0) var mainSampler: sampler;
                @group(0) @binding(1) var mainTexture: texture_2d<f32>; // Samples output of compute shader (unfilterable-float type)

                // UV coordinates for the full-screen quad (must match vertex positions)
                var<private> uvs: array<vec2<f32>, 6> = array<vec2<f32>, 6>(
                    vec2<f32>(0.0f, 1.0f), // Bottom-left
                    vec2<f32>(1.0f, 1.0f), // Bottom-right
                    vec2<f32>(0.0f, 0.0f), // Top-left

                    vec2<f32>(0.0f, 0.0f), // Top-left (duplicate for second triangle)
                    vec2<f32>(1.0f, 1.0f), // Bottom-right (duplicate for second triangle)
                    vec2<f32>(1.0f, 0.0f)  // Top-right
                );

                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) uv: vec2<f32>,
                };

                @vertex
                fn vert_main(@builtin(vertex_index) vertIndex: u32) -> VertexOutput {
                    // Vertices for a full-screen quad (two triangles)
                    let positions = array<vec2<f32>, 6>(
                    vec2<f32>(-1.0f, -1.0f), // Bottom-left
                    vec2<f32>( 1.0f, -1.0f), // Bottom-right
                    vec2<f32>(-1.0f,  1.0f), // Top-left

                    vec2<f32>(-1.0f,  1.0f), // Top-left (duplicate for second triangle)
                    vec2<f32>( 1.0f, -1.0f), // Bottom-right (duplicate for second triangle)
                    vec2<f32>( 1.0f,  1.0f)  // Top-right
                    );

                    var output: VertexOutput;
                    output.position = vec4<f32>(positions[vertIndex], 0.0f, 1.0f);
                    output.uv = uvs[vertIndex]; // This line will now work!
                    return output;
                }

                @fragment
                fn frag_main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
                    // Sample the texture generated by the compute shader
                    return textureSample(mainTexture, mainSampler, uv);
                }
                `;

                const computeShaderModule = device.createShaderModule({ label: 'Raytracer Compute Shader', code: computeShaderCode });
                console.log("Compute shader module created.");
                computePipeline = device.createComputePipeline({
                    layout: device.createPipelineLayout({
                        bindGroupLayouts: [
                            device.createBindGroupLayout({ // Group 0
                                entries: [
                                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, // CameraUniform
                                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, // LightUniform
                                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, // RaytracerParams
                                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, // TimeUniform
                                    { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, // WaterParams
                                    { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, // TerrainParams
                                    { binding: 6, visibility: GPUShaderStage.COMPUTE, storageTexture: { format: 'rgba32float', access: 'write-only' } }, // Output (ping-pong)
                                    // FIX: Removed 'resource: currentReadTextureView' as this is for bindGroup creation, not layout
                                    { binding: 7, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: 'unfilterable-float' } }, // Input (ping-pong)
                                ]
                            }),
                            device.createBindGroupLayout({ // Group 1 for Spheres & BVH
                                entries: [
                                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // Spheres
                                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // BVH Nodes
                                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // Primitive Indices
                                ]
                            }),
                        ]
                    }),
                    compute: {
                        module: computeShaderModule,
                        entryPoint: 'main',
                    },
                });
                console.log("Compute pipeline created.");

                loadingStatusP.textContent = "Compute pipeline created. Compiling render shader...";
                const renderShaderModule = device.createShaderModule({ label: 'Raytracer Render Shader', code: renderShaderCode });
                console.log("Render shader module created.");
                renderPipeline = device.createRenderPipeline({
                    layout: device.createPipelineLayout({
                        bindGroupLayouts: [
                            device.createBindGroupLayout({ // Group 0 for render
                                entries: [
                                    // FIX: Explicitly set sampler type to 'non-filtering' to match 'unfilterable-float' texture
                                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'non-filtering' } },
                                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'unfilterable-float' } },
                                ]
                            })
                        ]
                    }),
                    vertex: {
                        module: renderShaderModule,
                        entryPoint: 'vert_main',
                        buffers: [{ // Define vertex buffer layout for the quad
                            arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT, // x, y (2 floats)
                            attributes: [{
                                shaderLocation: 0, // @location(0) in vertex shader
                                offset: 0,
                                format: 'float32x2',
                            }],
                        }],
                    },
                    fragment: {
                        module: renderShaderModule,
                        entryPoint: 'frag_main',
                        targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }], // Output to canvas format
                    },
                    primitive: {
                        topology: 'triangle-list', // Drawing a quad with two triangles
                    },
                });
                console.log("Render pipeline created.");

                loadingStatusP.textContent = "Render pipeline created. Resizing canvas and preparing assets...";

                // --- IMPORTANT CHANGE: Moved resizeCanvasAndAssets() here ---
                // Now that both computePipeline and renderPipeline are defined,
                // resizeCanvasAndAssets can successfully create bind groups.
                resizeCanvasAndAssets();
                // --- END IMPORTANT CHANGE ---

                loadingStatusP.textContent = "Initializing scene data...";
                updateCameraUniformBuffer();
                light.color = hsvToRgb(sunHue); // Set initial light color based on initial sunHue
                updateLightUniformBuffer();
                updateTimeUniformBuffer(0);
                updateWaterUniformBuffer();
                updateTerrainUniformBuffer();

                // Initialize sphere data and BVH based on initial settings
                // manageSpheres internally calls updateGPUBuffers -> createComputeBindGroups.
                manageSpheres();

                // resizeCanvasAndAssets also calls createComputeBindGroups and createRenderBindGroup.
                // The call to resizeCanvasAndAssets earlier should have configured textures.
                // The call to manageSpheres should have configured sphere/BVH buffers and their compute bind groups.
                // A final call to createRenderBindGroup here ensures it's up-to-date with any texture changes from resize.
                // Redundant calls to createComputeBindGroups are avoided.
                createRenderBindGroup(); // Ensures render bind group is set up with final texture views.


                console.log("WebGPU initialization complete.");
                loadingStatusP.textContent = "Initialization complete. Ready to render!";

                // Transition to scene after a brief delay
                setTimeout(() => {
                    switchView('scene');
                    // Initialize scene controls UI values to match current state
                    initSceneControlsUI();
                }, 1000);

            } catch (error) {
                console.error("WebGPU initialization failed:", error);
                displayErrorMessage(`Error: ${error.message}`);
                switchView('menu'); // Go back to menu on error
            }
        }

        // Initialize scene control UI values to match current global variables
        function initSceneControlsUI() {
            sphereCountSlider.value = targetSphereCount; sphereCountValue.textContent = targetSphereCount;
            lightXSlider.value = light.position[0]; lightYSlider.value = light.position[1]; lightZSlider.value = light.position[2];
            lightBrightnessSlider.value = light.brightness; lightSizeSlider.value = light.size;
            lightXValue.textContent = light.position[0].toFixed(1); lightYValue.textContent = light.position[1].toFixed(1);
            lightZValue.textContent = light.position[2].toFixed(1); lightBrightnessValue.textContent = light.brightness.toFixed(1);
            lightSizeValue.textContent = light.size.toFixed(1);
            sunHueSlider.value = sunHue; sunHueValueSpan.textContent = sunHue.toFixed(2); // Set new slider value
            waveStrengthSlider.value = waveStrength; waveFrequencySlider.value = waveFrequency; waveSpeedSlider.value = waveSpeed;
            waveStrengthValue.textContent = waveStrength.toFixed(2); waveFrequencyValue.textContent = waveFrequency.toFixed(1);
            waveSpeedValue.textContent = waveSpeed.toFixed(2);
            refractiveIndexSlider.value = globalRefractiveIndex; refractiveIndexValue.textContent = globalRefractiveIndex.toFixed(2);
            warpStrengthSlider.value = globalWarpStrength; warpStrengthValue.textContent = globalWarpStrength.toFixed(2);
            terrainHeightSlider.value = terrainHeightScale; terrainHeightValue.textContent = terrainHeightScale.toFixed(1);
            terrainFrequencySlider.value = terrainFrequency; terrainFrequencyValue.textContent = terrainFrequency.toFixed(2);
            bouncesSlider.value = maxBounces; bouncesValue.textContent = maxBounces;
            raymarchStepsSlider.value = maxRaymarchSteps; raymarchStepsValue.textContent = maxRaymarchSteps;
            shadowSamplesSlider.value = shadowSamples; shadowSamplesValue.textContent = shadowSamples;
            dofSamplesSlider.value = dofSamples; dofSamplesValue.textContent = dofSamples;
            focalDistanceSlider.value = camera.focalDistance; focalDistanceValue.textContent = camera.focalDistance.toFixed(1);
            apertureSizeSlider.value = camera.apertureSize; apertureSizeValue.textContent = camera.apertureSize.toFixed(2);
            if (skyPreset === 0) { sunnyDayButton.classList.add('active'); duskButton.classList.remove('active'); }
            else { duskButton.classList.add('active'); sunnyDayButton.classList.remove('active'); }
        }

        // Main render loop
        function renderLoop(currentTime) {
            // Check if device is lost at the start of the loop
            if (!device || device.lost) {
                console.error("WebGPU device lost or not initialized. Stopping render loop.");
                if (device && device.lost) {
                    displayErrorMessage("WebGPU device lost. This often happens if the rendering is too complex for your GPU or browser. Please try reducing 'Max Bounces', 'Max Raymarch Steps', 'Shadow Samples', and 'DOF Samples' in the controls, then refresh the page.");
                }
                animationFrameId = null;
                return;
            }

            // If not in the scene view, stop the render loop
            if (appState !== 'scene') {
                animationFrameId = null;
                return;
            }

            const current_time_seconds = currentTime / 1000.0;
            const deltaTime = (current_time_seconds - lastFrameTime);
            lastFrameTime = current_time_seconds;
            totalTime += deltaTime;

            // Camera movement (WASD, Space, Ctrl)
            if (keysPressed['w'] || keysPressed['W'] || keysPressed['ArrowUp']) { camera.position[0] += camera.forward[0] * camera.movementSpeed; camera.position[1] += camera.forward[1] * camera.movementSpeed; camera.position[2] += camera.forward[2] * camera.movementSpeed; resetAccumulation(); }
            if (keysPressed['s'] || keysPressed['S'] || keysPressed['ArrowDown']) { camera.position[0] -= camera.forward[0] * camera.movementSpeed; camera.position[1] -= camera.forward[1] * camera.movementSpeed; camera.position[2] -= camera.forward[2] * camera.movementSpeed; resetAccumulation(); }
            if (keysPressed['a'] || keysPressed['A'] || keysPressed['ArrowLeft']) { camera.position[0] -= camera.right[0] * camera.movementSpeed; camera.position[1] -= camera.right[1] * camera.movementSpeed; camera.position[2] -= camera.right[2] * camera.movementSpeed; resetAccumulation(); }
            if (keysPressed['d'] || keysPressed['D'] || keysPressed['ArrowRight']) { camera.position[0] += camera.right[0] * camera.movementSpeed; camera.position[1] += camera.right[1] * camera.movementSpeed; camera.position[2] += camera.right[2] * camera.movementSpeed; resetAccumulation(); }
            if (keysPressed[' ']) { camera.position[1] += camera.up[1] * camera.movementSpeed; resetAccumulation(); } // Space for up
            if (keysPressed['Control'] || keysPressed['control']) { camera.position[1] -= camera.up[1] * camera.movementSpeed; resetAccumulation(); } // Ctrl for down
            updateCameraUniformBuffer();
            updateTimeUniformBuffer(totalTime); // Pass totalTime and frameCount for accumulation

            // --- Ping-ponging logic ---
            const currentWriteTexture = (currentTextureIndex === 0) ? outputTexture0 : outputTexture1;
            const currentReadTexture = (currentTextureIndex === 0) ? outputTexture1 : outputTexture0;
            const currentWriteTextureView = (currentTextureIndex === 0) ? outputTextureView0 : outputTextureView1;
            const currentReadTextureView = (currentTextureIndex === 0) ? outputTextureView1 : outputTextureView0;

            // Increment frame count for accumulation blending in shader
            frameCount++;

            // Recreate compute bind group 0 to bind the correct textures for this frame
            createComputeBindGroups();

            // --- Error Scope for Command Encoder ---
            device.pushErrorScope('validation');
            device.pushErrorScope('internal');
            // --- End New ---

            const commandEncoder = device.createCommandEncoder();

            // 1. Compute Pass
            const computePassEncoder = commandEncoder.beginComputePass();
            computePassEncoder.setPipeline(computePipeline);
            // Bind group 0 now uses the dynamically chosen read/write textures
            computePassEncoder.setBindGroup(0, computeBindGroup0);
            computePassEncoder.setBindGroup(1, computeBindGroup1);
            const workgroup_size_x = 8;
            const workgroup_size_y = 8;
            const dispatchX = Math.ceil(canvas.width / workgroup_size_x);
            const dispatchY = Math.ceil(canvas.height / workgroup_size_y);
            computePassEncoder.dispatchWorkgroups(dispatchX, dispatchY, 1);
            computePassEncoder.end();
            console.log("Compute pass dispatched.");

            // 2. Render Pass (Blit from the *just written* compute output to canvas)
            const textureView = context.getCurrentTexture().createView();
            const renderPassDescriptor = {
                colorAttachments: [{
                    view: textureView,
                    loadOp: 'clear', // Clear the canvas before drawing
                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                    storeOp: 'store', // Store the result to the canvas
                }],
            };

            const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);
            renderPass.setPipeline(renderPipeline);
            // Recreate render bind group to sample from the texture that was just written to
            createRenderBindGroup(); // This function will get the correct 'currentTextureToDisplay'
            renderPass.setBindGroup(0, renderBindGroup);
            renderPass.setVertexBuffer(0, renderQuadVertexBuffer); // Set the vertex buffer for the quad
            renderPass.draw(6); // Draw 6 vertices (2 triangles) for the full-screen quad
            renderPass.end();
            console.log("Render pass encoded.");

            device.queue.submit([commandEncoder.finish()]);
            console.log("Command buffer submitted.");

            // --- Pop Error Scopes after submission ---
            device.popErrorScope().then((error) => {
                if (error) {
                    console.error('WebGPU Error (internal scope during renderLoop command submission):', error);
                    displayErrorMessage(`WebGPU Internal Error during frame submission: ${error.message}. This may indicate an issue with the GPU, drivers, or browser. Try refreshing. If persistent, check console for details.`);
                }
            });
            device.popErrorScope().then((error) => {
                if (error) {
                    console.error('WebGPU Error (validation scope during renderLoop command submission):', error);
                    displayErrorMessage(`WebGPU Validation Error during frame submission: ${error.message}. This usually means the application is using the WebGPU API incorrectly (e.g., invalid buffer state, incorrect texture usage). Check console for details.`);
                }
            });
            // --- End New ---

            // FPS counter update
            // fps is calculated from total accumulated frames per second for display purposes
            const currentSamples = 1; // Each frame contributes 1 sample
            if (current_time_seconds * 1000 - lastFpsUpdateTime >= 1000) {
                fps = (frameCount / (current_time_seconds * 1000 - lastFpsUpdateTime)) * 1000;
                fpsCounterElement.textContent = `FPS: ${fps.toFixed(0)}`;
                frameCount = 0; // Reset frameCount for FPS calculation
                lastFpsUpdateTime = current_time_seconds * 1000;
            }

            // Swap textures for next frame
            currentTextureIndex = 1 - currentTextureIndex; // Toggle between 0 and 1

            animationFrameId = requestAnimationFrame(renderLoop);
        }

        // Function to start the render loop
        function startRenderLoop() {
            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(renderLoop);
            }
        }

        // --- Input Event Listeners for Camera (Scene View) ---
        canvas.addEventListener('mousedown', (e) => {
            if (appState === 'scene') {
                isMouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
                canvas.requestPointerLock();
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (appState === 'scene') {
                isMouseDown = false;
                document.exitPointerLock();
                canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (appState === 'scene' && document.pointerLockElement === canvas) {
                const movementX = e.movementX || e.mozMovementX || 0;
                const movementY = e.movementY || e.mozMovementY || 0;
                const sensitivity = camera.rotationSpeed;

                camera.rotationY -= movementX * sensitivity; // Yaw
                camera.rotationX -= movementY * sensitivity; // Pitch

                // Clamp pitch to prevent flipping
                camera.rotationX = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, camera.rotationX));
                resetAccumulation(); // Camera rotation also resets accumulation
            }
        });

        document.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
        });
        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        // --- Selected Sphere UI Manager Module (IIFE) ---
        const SelectedSphereUIManager = (function() {
            // Private variables to cache DOM elements
            let controlsDiv;
            let header;
            let albedoColorInput;
            let radiusSlider;
            let radiusValueSpan;
            let metallicSlider;
            let metallicValueSpan;
            let roughnessSlider;
            let roughnessValueSpan;
            let reflectivitySlider;
            let reflectivityValueSpan;
            let materialTypeSelect;
            let refractiveIndexControlGroup;
            let refractiveIndexSlider;
            let refractiveIndexValueSpan;

            // Private helper function to convert RGB array to HEX color string
            function _rgbArrayToHex(rgbArray) {
                if (!rgbArray || !Array.isArray(rgbArray) || rgbArray.length < 3) {
                    console.warn("Invalid rgbArray in _rgbArrayToHex, defaulting to #000000. Received:", rgbArray);
                    return '#000000';
                }
                const r = Math.round(Math.max(0, Math.min(1, rgbArray[0])) * 255);
                const g = Math.round(Math.max(0, Math.min(1, rgbArray[1])) * 255);
                const b = Math.round(Math.max(0, Math.min(1, rgbArray[2])) * 255);
                return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0');
            }

            // Private helper function to convert HEX color string to RGB array (0-1 range)
            function _hexToRgbArray(hex) {
                if (!hex || typeof hex !== 'string' || !hex.startsWith('#')) {
                    console.warn("Invalid hex string in _hexToRgbArray, defaulting to [0,0,0]. Received:", hex);
                    return [0, 0, 0];
                }
                let bigint = parseInt(hex.slice(1), 16);
                let r = (bigint >> 16) & 255;
                let g = (bigint >> 8) & 255;
                let b = bigint & 255;
                return [r / 255, g / 255, b / 255];
            }

            // Private function to handle updates when a selected sphere's property changes
            function _handleSelectedSphereUpdate() {
                if (globalSelectedSphereIndex === -1 || !spheres[globalSelectedSphereIndex]) {
                    console.warn("_handleSelectedSphereUpdate called with no valid sphere selected.");
                    return;
                }
                // Assumes spheres array is already updated by specific input listeners.
                if (typeof updateGPUBuffers === "function" && typeof resetAccumulation === "function") {
                    updateGPUBuffers(spheres, currentBvhResult); // Uses global currentBvhResult
                    resetAccumulation();
                    console.log(`Sphere ${globalSelectedSphereIndex} updated on GPU and accumulation reset by SelectedSphereUIManager.`);
                } else {
                    console.error("updateGPUBuffers or resetAccumulation is not defined globally for SelectedSphereUIManager.");
                }
            }

            // Public method to update the UI panel
            function updateUI(sphereIndex) {
                if (!controlsDiv || !header || !albedoColorInput) { // Basic check if elements are cached
                    console.error("Selected sphere UI elements not cached in SelectedSphereUIManager. Cannot update UI.");
                    if(controlsDiv) controlsDiv.style.display = 'none';
                    return;
                }

                if (sphereIndex === -1 || sphereIndex >= spheres.length) {
                    controlsDiv.style.display = 'none';
                    header.textContent = 'Selected Sphere (-1)';
                } else {
                    const sphere = spheres[sphereIndex]; // Access global spheres array
                    if (!sphere) {
                        console.error(`Sphere at index ${sphereIndex} is undefined. Hiding UI.`);
                        controlsDiv.style.display = 'none';
                        header.textContent = 'Selected Sphere (-1)';
                        return;
                    }

                    controlsDiv.style.display = 'block';
                    header.textContent = `Selected Sphere (${sphereIndex})`;

                    albedoColorInput.value = _rgbArrayToHex(sphere.color);
                    radiusSlider.value = sphere.radius;
                    radiusValueSpan.textContent = sphere.radius.toFixed(1);
                    metallicSlider.value = sphere.metallic;
                    metallicValueSpan.textContent = sphere.metallic.toFixed(2);
                    roughnessSlider.value = sphere.perPixelRoughness;
                    roughnessValueSpan.textContent = sphere.perPixelRoughness.toFixed(2);
                    reflectivitySlider.value = sphere.baseReflectivity;
                    reflectivityValueSpan.textContent = sphere.baseReflectivity.toFixed(2);
                    materialTypeSelect.value = sphere.materialType;
                    refractiveIndexSlider.value = sphere.refractiveIndex;
                    refractiveIndexValueSpan.textContent = sphere.refractiveIndex.toFixed(2);

                    if (sphere.materialType == MATERIAL_REFRACTIVE) { // Access global MATERIAL_REFRACTIVE
                        refractiveIndexControlGroup.style.display = 'block';
                    } else {
                        refractiveIndexControlGroup.style.display = 'none';
                    }
                }
            }

            // Public method to initialize the module
            function init() {
                controlsDiv = document.getElementById('selected-sphere-controls');
                if (!controlsDiv) {
                    console.error("Failed to find #selected-sphere-controls div. Selected Sphere UI will not function.");
                    return;
                }
                header = controlsDiv.querySelector('h3');
                albedoColorInput = document.getElementById('selected-albedo-color');
                radiusSlider = document.getElementById('selected-radius-slider');
                radiusValueSpan = document.getElementById('selected-radius-value');
                metallicSlider = document.getElementById('selected-metallic-slider');
                metallicValueSpan = document.getElementById('selected-metallic-value');
                roughnessSlider = document.getElementById('selected-roughness-slider');
                roughnessValueSpan = document.getElementById('selected-roughness-value');
                reflectivitySlider = document.getElementById('selected-reflectivity-slider');
                reflectivityValueSpan = document.getElementById('selected-reflectivity-value');
                materialTypeSelect = document.getElementById('selected-material-type');
                refractiveIndexControlGroup = document.getElementById('selected-refractive-index-control-group');
                refractiveIndexSlider = document.getElementById('selected-refractive-index-slider');
                refractiveIndexValueSpan = document.getElementById('selected-refractive-index-value');

                // Initially hide the panel
                updateUI(-1);

                // Event Listeners
                if (albedoColorInput) {
                    albedoColorInput.addEventListener('input', (event) => {
                        if (globalSelectedSphereIndex === -1 || !spheres[globalSelectedSphereIndex]) return;
                        spheres[globalSelectedSphereIndex].color = _hexToRgbArray(event.target.value);
                        _handleSelectedSphereUpdate();
                    });
                }
                if (radiusSlider) {
                    radiusSlider.addEventListener('input', (event) => {
                        if (globalSelectedSphereIndex === -1 || !spheres[globalSelectedSphereIndex]) return;
                        const value = validateAndClampInput(event, true); // Uses global validateAndClampInput
                        spheres[globalSelectedSphereIndex].radius = value;
                        if(radiusValueSpan) radiusValueSpan.textContent = value.toFixed(1);
                        _handleSelectedSphereUpdate();
                    });
                }
                if (metallicSlider) {
                    metallicSlider.addEventListener('input', (event) => {
                        if (globalSelectedSphereIndex === -1 || !spheres[globalSelectedSphereIndex]) return;
                        const value = validateAndClampInput(event, true);
                        spheres[globalSelectedSphereIndex].metallic = value;
                        if(metallicValueSpan) metallicValueSpan.textContent = value.toFixed(2);
                        _handleSelectedSphereUpdate();
                    });
                }
                 if (roughnessSlider) {
                    roughnessSlider.addEventListener('input', (event) => {
                        if (globalSelectedSphereIndex === -1 || !spheres[globalSelectedSphereIndex]) return;
                        const value = validateAndClampInput(event, true);
                        spheres[globalSelectedSphereIndex].perPixelRoughness = value;
                        if(roughnessValueSpan) roughnessValueSpan.textContent = value.toFixed(2);
                        _handleSelectedSphereUpdate();
                    });
                }
                if (reflectivitySlider) {
                    reflectivitySlider.addEventListener('input', (event) => {
                        if (globalSelectedSphereIndex === -1 || !spheres[globalSelectedSphereIndex]) return;
                        const value = validateAndClampInput(event, true);
                        spheres[globalSelectedSphereIndex].baseReflectivity = value;
                        if(reflectivityValueSpan) reflectivityValueSpan.textContent = value.toFixed(2);
                        _handleSelectedSphereUpdate();
                    });
                }
                if (materialTypeSelect) {
                    materialTypeSelect.addEventListener('change', (event) => {
                        if (globalSelectedSphereIndex === -1 || !spheres[globalSelectedSphereIndex]) return;
                        const value = parseInt(event.target.value);
                        spheres[globalSelectedSphereIndex].materialType = value;
                        if (refractiveIndexControlGroup) {
                            refractiveIndexControlGroup.style.display = (value === MATERIAL_REFRACTIVE) ? 'block' : 'none';
                        }
                        _handleSelectedSphereUpdate();
                    });
                }
                if (selectedRefractiveIndexSlider) { // Corrected variable name
                    selectedRefractiveIndexSlider.addEventListener('input', (event) => {
                        if (globalSelectedSphereIndex === -1 || !spheres[globalSelectedSphereIndex]) return;
                        const value = validateAndClampInput(event, true);
                        spheres[globalSelectedSphereIndex].refractiveIndex = value;
                        if(refractiveIndexValueSpan) refractiveIndexValueSpan.textContent = value.toFixed(2); // Corrected variable name
                        _handleSelectedSphereUpdate();
                    });
                }
                console.log("SelectedSphereUIManager initialized.");
            }

            // Expose public methods
            return {
                init: init,
                updateUI: updateUI
            };
        })();

        // --- Initial Setup ---
        window.onload = () => {
            switchView('menu'); // Start in the main menu

            // Set initial values for menu sliders based on global defaults
            numSpheresRange.value = targetSphereCount;
            numSpheresValueSpan.textContent = targetSphereCount;
            maxBouncesRange.value = maxBounces;
            maxBouncesValueSpan.textContent = maxBounces;
            samplesPerPixelRange.value = shadowSamples; // Both shadow and dof samples
            samplesPerPixelValueSpan.textContent = samplesPerPixelRange.value;

            // Initialize the Selected Sphere UI Manager
            SelectedSphereUIManager.init();
        };

        // --- Global variable for selected sphere ---
        let globalSelectedSphereIndex = -1;
        let highlightedSphereIndex = -1;
        let originalHighlightedSphereColor = null;

        // --- Vector Math Utilities (3D) ---
        function normalizeVector3D(v) {
            let len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            if (len > 0.00001) {
                return [v[0]/len, v[1]/len, v[2]/len];
            }
            // console.warn("normalizeVector3D: vector length is zero.");
            return [0,0,0];
        }

        function crossProduct3D(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        // dotProduct is defined further down, and should be suitable for 3D vectors.
        // normalizeVector is also defined further down.

        // --- Matrix Math Functions ---

        // Returns a 16-element Float32Array representing a 4x4 perspective projection matrix
        // in column-major order. WebGPU NDC Z range is [0, 1].
        // Parameters: fovy (vertical field of view in radians), aspect (width/height), near, far clipping planes.
        function getProjectionMatrix(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const out = new Float32Array(16);

            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;

            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;

            out[8] = 0;
            out[9] = 0;
            out[10] = far / (far - near); // Remaps Z to [0,1] for WebGPU
            out[11] = 1;                  // Convention from libraries like gl-matrix for perspectiveZO ( oznacza kierunek osi Z )

            out[12] = 0;
            out[13] = 0;
            out[14] = -(far * near) / (far - near); // Remaps Z to [0,1]
            out[15] = 0;
            return out;
        }

        // Multiplies two 4x4 matrices (Float32Arrays, column-major).
        // out = a * b
        function multiplyMatrices4x4(a, b) {
            const out = new Float32Array(16);

            const a00 = a[0], a01 = a[4], a02 = a[8], a03 = a[12];
            const a10 = a[1], a11 = a[5], a12 = a[9], a13 = a[13];
            const a20 = a[2], a21 = a[6], a22 = a[10], a23 = a[14];
            const a30 = a[3], a31 = a[7], a32 = a[11], a33 = a[15];

            const b00 = b[0], b01 = b[4], b02 = b[8], b03 = b[12];
            const b10 = b[1], b11 = b[5], b12 = b[9], b13 = b[13];
            const b20 = b[2], b21 = b[6], b22 = b[10], b23 = b[14];
            const b30 = b[3], b31 = b[7], b32 = b[11], b33 = b[15];

            out[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;
            out[1] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;
            out[2] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;
            out[3] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;

            out[4] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;
            out[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;
            out[6] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;
            out[7] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;

            out[8] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;
            out[9] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;
            out[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;
            out[11] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;

            out[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;
            out[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;
            out[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;
            out[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;

            return out;
        }

        // Returns a 16-element Float32Array representing a 4x4 view matrix (lookAt)
        // in column-major order.
        // cameraPosition: Array[3]
        // cameraForward: Array[3] (direction camera is looking)
        // cameraUp: Array[3] (up vector for the camera)
        function getViewMatrix(cameraPosition, cameraForward, cameraUp) {
            // P = cameraPosition
            // U = cameraUp
            // viewForward = cameraForward (direction vector)

            // zAxis of the view coordinate system is the inverse of the direction the camera is looking.
            const zAxis = normalizeVector3D([-cameraForward[0], -cameraForward[1], -cameraForward[2]]);
            const xAxis = normalizeVector3D(crossProduct3D(cameraUp, zAxis));
            const yAxis = normalizeVector3D(crossProduct3D(zAxis, xAxis));

            const out = new Float32Array(16);

            out[0] = xAxis[0];  out[4] = xAxis[1];  out[8] = xAxis[2];  out[12] = -dotProduct(xAxis, cameraPosition);
            out[1] = yAxis[0];  out[5] = yAxis[1];  out[9] = yAxis[2];  out[13] = -dotProduct(yAxis, cameraPosition);
            out[2] = zAxis[0];  out[6] = zAxis[1];  out[10] = zAxis[2]; out[14] = -dotProduct(zAxis, cameraPosition);
            out[3] = 0;         out[7] = 0;         out[11] = 0;        out[15] = 1;

            return out;
        }

        // Inverts a 4x4 matrix (Float32Array, column-major).
        // This is a more robust version than the previous placeholder, but still not a full general inversion.
        // It handles typical view and projection matrices better.
        function invertMatrix(m) {
            const out = new Float32Array(16);

            const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
            const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
            const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
            const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];

            const b00 = m00 * m11 - m01 * m10;
            const b01 = m00 * m12 - m02 * m10;
            const b02 = m00 * m13 - m03 * m10;
            const b03 = m01 * m12 - m02 * m11;
            const b04 = m01 * m13 - m03 * m11;
            const b05 = m02 * m13 - m03 * m12;
            const b06 = m20 * m31 - m21 * m30;
            const b07 = m20 * m32 - m22 * m30;
            const b08 = m20 * m33 - m23 * m30;
            const b09 = m21 * m32 - m22 * m31;
            const b10 = m21 * m33 - m23 * m31;
            const b11 = m22 * m33 - m23 * m32;

            let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

            if (!det) {
                console.warn("invertMatrix: Matrix is not invertible (determinant is zero). Returning identity.");
                out.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
                return out;
            }
            det = 1.0 / det;

            out[0] = (m11 * b11 - m12 * b10 + m13 * b09) * det;
            out[1] = (m02 * b10 - m01 * b11 - m03 * b09) * det;
            out[2] = (m31 * b05 - m32 * b04 + m33 * b03) * det;
            out[3] = (m22 * b04 - m21 * b05 - m23 * b03) * det;
            out[4] = (m12 * b08 - m10 * b11 - m13 * b07) * det;
            out[5] = (m00 * b11 - m02 * b08 + m03 * b07) * det;
            out[6] = (m32 * b02 - m30 * b05 - m33 * b01) * det;
            out[7] = (m20 * b05 - m22 * b02 + m23 * b01) * det;
            out[8] = (m10 * b10 - m11 * b08 + m13 * b06) * det;
            out[9] = (m01 * b08 - m00 * b10 - m03 * b06) * det;
            out[10] = (m30 * b04 - m31 * b02 + m33 * b00) * det;
            out[11] = (m21 * b02 - m20 * b04 - m23 * b00) * det;
            out[12] = (m11 * b07 - m10 * b09 - m12 * b06) * det;
            out[13] = (m00 * b09 - m01 * b07 + m02 * b06) * det;
            out[14] = (m31 * b01 - m30 * b03 - m32 * b00) * det;
            out[15] = (m20 * b03 - m21 * b01 + m22 * b00) * det;

            return out;
        }

        // Multiplies a 4D vector by a 4x4 matrix (Float32Array, column-major).
        function multiplyVectorByMatrix(matrix, vector) {
            const [x, y, z, w] = vector; // vector is an Array[4]
            const out = [0,0,0,0];

            // Matrix is column-major:
            // m[0] m[4] m[8]  m[12]
            // m[1] m[5] m[9]  m[13]
            // m[2] m[6] m[10] m[14]
            // m[3] m[7] m[11] m[15]
            out[0] = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12] * w;
            out[1] = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13] * w;
            out[2] = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14] * w;
            out[3] = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15] * w;

            return out;
        }

        // Normalizes a vector (Array of 3 or 4 elements). Only considers XYZ for length.
        function normalizeVector(vec) {
            const x = vec[0], y = vec[1], z = vec[2];
            let len = Math.sqrt(x*x + y*y + z*z);
            if (len > 0.00001) {
                len = 1.0 / len;
                const out = [x*len, y*len, z*len];
                if (vec.length > 3) out.push(vec[3]); // Preserve W if it exists
                return out;
            }
            const out = [0,0,0];
            if (vec.length > 3) out.push(vec[3]); // Preserve W
            // console.warn("normalizeVector: vector length is zero.");
            return out;
        }

        // --- Vector Math Helper Functions ---
        function subtractVectors(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
        }

        function dotProduct(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }

        // --- Ray-Sphere Intersection ---
        function intersectRayWithSpheres(rayOrigin, rayDirection) {
            let closestT = Infinity;
            let selectedSphereIndex = -1;
            const epsilon = 0.0001; // To avoid self-intersection or hits slightly behind origin

            for (let i = 0; i < spheres.length; i++) {
                const sphere = spheres[i];
                const L = subtractVectors(sphere.position, rayOrigin);
                const tca = dotProduct(L, rayDirection);

                // If origin is outside sphere and sphere is behind ray, no positive t intersection.
                // A simpler check: if tca < 0, center of sphere is behind ray origin along ray direction.
                // We only care about forward intersections for picking.
                if (tca < 0) {
                    // More precise check if origin is inside or outside for this case:
                    // If dot(L,L) > sphere.radius * sphere.radius, then origin is outside.
                    // In that scenario, if tca < 0, sphere is entirely behind.
                    // If origin is inside (dot(L,L) <= radius^2), then tca < 0 is still possible for one of the intersection points.
                    // However, the standard algorithm handles this: t0 would be negative, t1 positive.
                }

                const d2 = dotProduct(L, L) - tca * tca;
                if (d2 > sphere.radius * sphere.radius) {
                    continue; // Ray misses the sphere
                }

                const thc = Math.sqrt(sphere.radius * sphere.radius - d2);
                let t0 = tca - thc;
                let t1 = tca + thc;

                let t = -1;
                if (t0 > epsilon) {
                    t = t0;
                } else if (t1 > epsilon) {
                    t = t1; // Ray origin is inside the sphere, or t0 was too small
                }

                if (t > 0 && t < closestT) {
                    closestT = t;
                    selectedSphereIndex = i;
                }
            }

            return {
                hit: (selectedSphereIndex !== -1),
                sphereIndex: selectedSphereIndex,
                distance: closestT
            };
        }


        // --- Canvas Click Listener for Ray Unprojection ---
        canvas.addEventListener('click', (event) => {
            if (appState !== 'scene' || !device) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Convert to NDC
            const ndcX = (mouseX / canvas.clientWidth) * 2 - 1;
            const ndcY = (1 - (mouseY / canvas.clientHeight)) * 2 - 1; // Y is inverted

            console.log("NDC Coords: ", ndcX, ndcY);

            // Ensure camera vectors and aspect ratio are up-to-date
            calculateCameraVectors(); // Updates camera.forward, camera.up, camera.right
            camera.aspect = canvas.clientWidth / canvas.clientHeight;

            // 1. Get Projection and View Matrices
            const projectionMatrix = getProjectionMatrix(camera.fovy, camera.aspect, camera.near, camera.far);
            const viewMatrix = getViewMatrix(camera.position, camera.forward, camera.up);

            // 2. Get Inverse Projection and Inverse View Matrices
            const invProjectionMatrix = invertMatrix(projectionMatrix);
            if (!invProjectionMatrix || invProjectionMatrix[0] === undefined ) { // Basic check if inversion failed (e.g. returned identity on error)
                console.error("Failed to invert projection matrix. Aborting ray generation.");
                return;
            }
            const invViewMatrix = invertMatrix(viewMatrix);
             if (!invViewMatrix || invViewMatrix[0] === undefined) {
                console.error("Failed to invert view matrix. Aborting ray generation.");
                return;
            }

            // 3. Unproject NDC to View Space
            // For WebGPU NDC Z is [0, 1], so near plane is at Z = 0.
            const nearPointNDC = [ndcX, ndcY, 0.0, 1.0];

            let nearPointCamera = multiplyVectorByMatrix(invProjectionMatrix, nearPointNDC);

            // Perform perspective divide
            if (nearPointCamera[3] !== 0) {
                nearPointCamera[0] /= nearPointCamera[3];
                nearPointCamera[1] /= nearPointCamera[3];
                nearPointCamera[2] /= nearPointCamera[3];
                // nearPointCamera[3] = 1.0; // After division, W is 1
            } else {
                console.error("Ray generation: W component is zero after invProjectionMatrix multiplication. Cannot perform perspective divide.");
                return;
            }

            // 4. Unproject View Space to World Space
            const pointToTransformToWorld = [nearPointCamera[0], nearPointCamera[1], nearPointCamera[2], 1.0];
            const nearPointWorld = multiplyVectorByMatrix(invViewMatrix, pointToTransformToWorld);
            // nearPointWorld is now a 4-component vector [x,y,z,w]. For a point, w should be 1.

            // Ray origin is the camera's position in world space.
            const worldRayOrigin = [...camera.position];

            // Calculate world space direction vector
            // Direction = normalize(nearPointWorld_xyz - cameraPosition_xyz)
            const rayDirWorldUnnormalized = subtractVectors( // subtractVectors works for 3D
                [nearPointWorld[0], nearPointWorld[1], nearPointWorld[2]],
                worldRayOrigin
            );
            const finalRayDirection = normalizeVector3D(rayDirWorldUnnormalized);

            lastClickedRay.origin = worldRayOrigin;
            lastClickedRay.direction = finalRayDirection;

            console.log("Clicked Ray Origin (World):", worldRayOrigin);
            console.log("Clicked Ray Direction (World):", finalRayDirection);

            const intersectionResult = intersectRayWithSpheres(lastClickedRay.origin, lastClickedRay.direction);
            let needsGPUUpdate = false;

            // Revert previous highlight if any
            if (highlightedSphereIndex !== -1 && spheres[highlightedSphereIndex]) { // Check if sphere still exists
                spheres[highlightedSphereIndex].color = originalHighlightedSphereColor;
                needsGPUUpdate = true; // Color was changed back
            }
            highlightedSphereIndex = -1;
            originalHighlightedSphereColor = null;

            if (intersectionResult.hit) {
                globalSelectedSphereIndex = intersectionResult.sphereIndex;
                const selectedSphere = spheres[intersectionResult.sphereIndex];
                console.log("Hit sphere at index:", intersectionResult.sphereIndex, "Distance:", intersectionResult.distance);
                console.log("Selected Sphere Details:", {
                    position: selectedSphere.position,
                    radius: selectedSphere.radius,
                    color: selectedSphere.color,
                    materialType: selectedSphere.materialType,
                    metallic: selectedSphere.metallic,
                    roughness: selectedSphere.perPixelRoughness,
                    baseReflectivity: selectedSphere.baseReflectivity,
                    refractiveIndex: selectedSphere.refractiveIndex
                });

                // Apply new highlight
                highlightedSphereIndex = intersectionResult.sphereIndex;
                originalHighlightedSphereColor = [...selectedSphere.color]; // Store a copy
                selectedSphere.color = [1.0, 0.0, 1.0]; // Highlight with magenta
                needsGPUUpdate = true;

            } else {
                globalSelectedSphereIndex = -1;
                console.log("No sphere hit.");
                // If needsGPUUpdate was true from reverting a previous selection, but no new selection is made,
                // the GPU update will still happen, which is correct.
            }

            if (needsGPUUpdate) {
                if (typeof updateGPUBuffers === "function" && typeof resetAccumulation === "function") {
                    updateGPUBuffers(spheres, currentBvhResult); // Assumes currentBvhResult is accessible
                    resetAccumulation();
                } else {
                    console.error("updateGPUBuffers or resetAccumulation is not defined globally or in accessible scope.");
                }
            }
            // Update the UI based on the selection
            SelectedSphereUIManager.updateUI(globalSelectedSphereIndex);

        });

    </script>
</body>
</html>
