<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Raytracer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #1a1a2e; /* Dark background */
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        /* View management */
        #app-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; /* For absolute positioning of views */
        }
        .view {
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.5s ease-in-out; /* Faster transition for general views */
        }
        .view.active {
            display: flex;
            opacity: 1;
        }

        /* Specific view layouts */
        #menu-view {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: #1a1a2e;
            z-index: 10;
        }
        #scene-view {
            justify-content: center;
            align-items: center;
            background-color: #0d0d1e;
            z-index: 5;
        }
        #loading-view {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #1a1a2e;
            z-index: 15; /* Highest z-index to overlay everything during loading */
            text-align: center;
        }

        /* Canvas */
        canvas {
            display: block;
            background-color: #0d0d1e; /* Darker background for canvas */
            width: 100%; /* Take full width of parent */
            height: 100%; /* Take full height of parent */
            cursor: grab; /* Cursor for camera control */
        }
        canvas:active {
            cursor: grabbing;
        }
        /* UI Components - Tailwind based */
        .button-primary {
            @apply px-8 py-4 m-4 text-lg font-semibold text-white bg-indigo-600 rounded-lg shadow-lg hover:bg-indigo-700 transition-all duration-300 transform hover:scale-105 border-2 border-indigo-500;
        }
        .button-secondary {
            @apply px-6 py-3 m-2 text-md font-medium text-indigo-200 bg-gray-800 rounded-md shadow-md hover:bg-gray-700 transition-all duration-300 transform hover:scale-105 border-2 border-gray-700;
        }
        .panel {
            @apply bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-700 max-w-xl w-full;
        }
        .input-range {
            @apply w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer;
            -webkit-appearance: none; /* Override default appearance */
        }
        .input-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5; /* Tailwind indigo-600 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.4); /* Focus ring effect */
        }
        .input-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.4);
        }

        /* Specific UI element styling */
        #menu-view h1 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #4CAF50; /* A nice green for the title */
        }
        #menu-view p {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        #settings-panel {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(20px);
            max-width: 700px; /* Use max-width directly */
        }
        #settings-panel.active {
            opacity: 1;
            pointer-events: all;
            transform: translateY(0);
        }
        #settings-panel h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        #settings-panel label {
            display: block;
            margin-bottom: 5px;
            text-align: left;
            font-weight: 600;
        }
        #settings-panel select {
            @apply w-full p-3 rounded-md bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500;
        }

        /* Loading view specific styles */
        #loading-view .spinner {
            animation: spin 1s linear infinite;
            border-top-color: #6366f1; /* Tailwind indigo-500 */
            border-right-color: transparent;
            border-bottom-color: #6366f1;
            border-left-color: transparent;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-view p {
            margin-top: 20px;
            font-size: 1.2em;
            color: #a0a0a0;
        }
        /* Scene view UI */
        #fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #0f0;
            z-index: 20;
            font-family: monospace;
            display: none; /* Hidden by default, activated when scene is active */
        }
        #back-to-main-menu-from-scene {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 20;
        }
        /* Error Display */
        #error-message-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ef4444; /* Tailwind red-500 */
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10000; /* Very high to ensure visibility */
            display: none; /* Hidden by default */
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #error-message-display.active {
            display: block;
            opacity: 1;
        }
        /* Collapsible sections for scene controls */
        #scene-controls-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: #e0e0e0;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transition: width 0.3s ease;
            width: 300px; /* Default width */
            z-index: 1000; /* Ensure panel is above canvas */
            display: none; /* Hidden by default */
        }
        #scene-controls-panel.active {
            display: block;
        }
        #toggle-panel-button {
            background: none;
            border: none;
            color: #00ffff;
            font-size: 24px;
            cursor: pointer;
            position: absolute;
            top: 5px;
            left: 5px;
            line-height: 20px;
        }
        #scene-controls-panel.collapsed {
            width: 40px;
            overflow: hidden;
        }
        #scene-controls-panel.collapsed #toggle-panel-button {
            left: auto; /* reset left property to allow automatic positioning */
            right: 5px; /* Adjust button position when collapsed */
            transform: scaleX(-1); /* Flip caret horizontally */
        }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-weight: bold; color: #00ffff; }
        .control-group input[type="range"] { width: 100%; -webkit-appearance: none; appearance: none; height: 8px; background: #555; border-radius: 512px; outline: none; }
        .control-group input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00ffff; cursor: pointer; border: 2px solid #fff; }
        .control-group input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00ffff; cursor: pointer; border: 2px solid #fff; }
        .current-value { float: right; font-weight: normal; color: #e0e0e0; }
        #scene-controls-panel h2 { color: #00ffff; border-bottom: 2px solid #00ffff; padding-bottom: 5px; margin-top: 0; }
        .github-link {
            display: block;
            margin-top: 20px;
            text-align: center;
        }
        .github-link a {
            color: #00ffff;
            text-decoration: none;
            font-weight: bold;
        }
        .github-link a:hover {
            text-decoration: underline;
        }
        details {
            margin-bottom: 10px;
            border: 1px solid #0056b3;
            border-radius: 5px;
        }
        summary {
            background-color: #007bff;
            color: white;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        summary:hover {
            background-color: #0056b3;
        }
        details[open] summary {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        .details-content {
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-top: 1px solid #0056b3;
        }
        .button-group {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            margin-bottom: 15px;
        }
        .button-group button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        .button-group button:hover {
            background-color: #0056b3;
        }
        .button-group button.active {
            background-color: #00c0ff;
            box-shadow: 0 0 8px rgba(0, 192, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Main Menu View -->
        <div id="menu-view" class="view active">
            <div class="panel">
                <h1 class="text-4xl font-bold mb-6 text-indigo-300">WebGPU Raytracer</h1>
                <p class="mb-8 text-lg text-gray-300">Experience physically-based rendering on your GPU.</p>
                <button id="start-button" class="button-primary">Start Raytracing</button>
                <button id="settings-button" class="button-primary">Settings</button>
            </div>
            <!-- Settings Panel (hidden initially) -->
            <div id="settings-panel" class="panel absolute opacity-0 pointer-events-none transition-all duration-500 scale-95" style="transform: translateY(20px);">
                <h2 class="text-3xl font-bold mb-6 text-indigo-300">Settings</h2>
                <div class="mb-6">
                    <label for="quality-preset" class="block text-gray-300 text-left mb-2">Quality Preset:</label>
                    <select id="quality-preset" class="w-full p-3 rounded-md bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="low">Low (Fewer Samples, Less Bounces)</option>
                        <option value="medium" selected>Medium (Balanced)</option>
                        <option value="high">High (More Samples, More Bounces)</option>
                    </select>
                </div>
                <div class="mb-6">
                    <label for="num-spheres" class="block text-gray-300 text-left mb-2">Number of Spheres: <span id="num-spheres-value">5</span></label>
                    <input type="range" id="num-spheres" min="1" max="100" value="5" class="input-range">
                </div>
                 <div class="mb-6">
                    <label for="max-bounces" class="block text-gray-300 text-left mb-2">Max Bounces: <span id="max-bounces-value">2</span></label>
                    <input type="range" id="max-bounces" min="1" max="10" value="2" class="input-range">
                </div>
                <div class="mb-6">
                    <label for="samples-per-pixel" class="block text-gray-300 text-left mb-2">Samples per Pixel: <span id="samples-per-pixel-value">4</span></label>
                    <input type="range" id="samples-per-pixel" min="1" max="64" value="4" class="input-range">
                </div>
                <button id="apply-settings-button" class="button-primary">Apply & Start</button>
                <button id="back-to-menu-button" class="button-secondary mt-4">Back to Main Menu</button>
            </div>
        </div>
        <!-- Loading View -->
        <div id="loading-view" class="view">
            <div class="text-center">
                <div class="spinner rounded-full h-16 w-16 border-t-4 border-b-4 border-indigo-500 mb-4 mx-auto"></div>
                <p id="loading-status" class="text-xl text-gray-300">Initializing WebGPU and compiling shaders...</p>
            </div>
        </div>
        <!-- Scene View (contains canvas and scene-specific UI) -->
        <div id="scene-view" class="view">
            <canvas id="webgpu-canvas"></canvas>
            <div id="fps-counter" class="fps-counter">FPS: --</div>
            <button id="back-to-main-menu-from-scene" class="button-secondary absolute bottom-8 right-8">Back to Menu</button>
            <!-- Scene Controls Panel -->
            <div id="scene-controls-panel">
                <button id="toggle-panel-button">&lt;</button>
                <h2>Raytracer Controls</h2>
                <details open>
                    <summary>Camera & Scene</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="sphereCountSlider">Number of Spheres: <span id="sphereCountValue" class="current-value">1</span></label>
                            <input type="range" id="sphereCountSlider" min="1" max="100" value="1">
                        </div>
                        <div class="control-group">
                            <label for="warpStrengthSlider">Domain Warp Strength: <span id="warpStrengthValue" class="current-value">0.0</span></label>
                            <input type="range" id="warpStrengthSlider" min="0.0" max="2.0" step="0.01" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="focalDistanceSlider">Focal Distance: <span id="focalDistanceValue" class="current-value">10.0</span></label>
                            <input type="range" id="focalDistanceSlider" min="0.1" max="50.0" step="0.1" value="10.0">
                        </div>
                        <div class="control-group">
                            <label for="apertureSizeSlider">Aperture Size: <span id="apertureSizeValue" class="current-value">0.00</span></label>
                            <input type="range" id="apertureSizeSlider" min="0.0" max="1.0" step="0.01" value="0.00">
                        </div>
                        <div class="control-group">
                            <label>Sky Preset:</label>
                            <div class="button-group">
                                <button id="sunnyDayButton" class="active">Sunny Day</button>
                                <button id="duskButton">Dusk</button>
                            </div>
                        </div>
                    </div>
                </details>
                <details>
                    <summary>Procedural Rock Controls</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="rockCountSlider">Rock Count: <span id="rockCountValue" class="current-value">2</span></label>
                            <input type="range" id="rockCountSlider" min="0" max="10" step="1" value="2">
                        </div>
                        <div class="control-group">
                            <label for="rockSubdivisionsSlider">Subdivisions: <span id="rockSubdivisionsValue" class="current-value">1</span></label>
                            <input type="range" id="rockSubdivisionsSlider" min="0" max="3" step="1" value="1">
                        </div>
                        <div class="control-group">
                            <label for="rockNumScrapesSlider">Number of Scrapes: <span id="rockNumScrapesValue" class="current-value">15</span></label>
                            <input type="range" id="rockNumScrapesSlider" min="0" max="50" step="1" value="15">
                        </div>
                        <div class="control-group">
                            <label for="rockScrapeStrengthSlider">Scrape Strength: <span id="rockScrapeStrengthValue" class="current-value">0.30</span></label>
                            <input type="range" id="rockScrapeStrengthSlider" min="0.01" max="1.0" step="0.01" value="0.3">
                        </div>
                        <div class="control-group">
                            <label for="rockScrapeRadiusMinSlider">Scrape Radius Min: <span id="rockScrapeRadiusMinValue" class="current-value">0.40</span></label>
                            <input type="range" id="rockScrapeRadiusMinSlider" min="0.1" max="1.0" step="0.05" value="0.4">
                        </div>
                        <div class="control-group">
                            <label for="rockScrapeRadiusMaxSlider">Scrape Radius Max: <span id="rockScrapeRadiusMaxValue" class="current-value">0.80</span></label>
                            <input type="range" id="rockScrapeRadiusMaxSlider" min="0.1" max="2.0" step="0.05" value="0.8">
                        </div>
                        <div class="control-group">
                            <label for="rockVertexNoiseStrengthSlider">Vertex Noise: <span id="rockVertexNoiseStrengthValue" class="current-value">0.050</span></label>
                            <input type="range" id="rockVertexNoiseStrengthSlider" min="0.0" max="0.5" step="0.005" value="0.05">
                        </div>
                    </div>
                </details>
                <details open>
                    <summary>Sun</summary> <!-- Renamed from Lighting -->
                    <div class="details-content">
                        <div class="control-group">
                            <label for="lightXSlider">Light X: <span id="lightXValue" class="current-value">0.0</span></label>
                            <input type="range" id="lightXSlider" min="-10.0" max="10.0" step="0.1" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="lightYSlider">Light Y: <span id="lightYValue" class="current-value">10.0</span></label>
                            <input type="range" id="lightYSlider" min="0.1" max="20.0" step="0.1" value="10.0">
                        </div>
                        <div class="control-group">
                            <label for="lightZSlider">Light Z: <span id="lightZValue" class="current-value">2.8</span></label>
                            <input type="range" id="lightZSlider" min="-10.0" max="10.0" step="0.1" value="2.8">
                        </div>
                        <div class="control-group">
                            <label for="lightBrightnessSlider">Light Brightness: <span id="lightBrightnessValue" class="current-value">1.0</span></label>
                            <input type="range" id="lightBrightnessSlider" min="0.1" max="5.0" step="0.1" value="1.0">
                        </div>
                        <div class="control-group">
                            <label for="lightSizeSlider">Light Size: <span id="lightSizeValue" class="current-value">0.4</span></label>
                            <input type="range" id="lightSizeSlider" min="0.0" max="5.0" step="0.1" value="0.4">
                        </div>
                        <!-- New Sun Color/Hue Slider -->
                        <div class="control-group">
                            <label for="sunHueSlider">Sun Color/Hue: <span id="sunHueValue" class="current-value">0.00</span></label>
                            <input type="range" id="sunHueSlider" min="0" max="1" step="0.01" value="0">
                        </div>
                    </div>
                </details>
                <details>
                    <summary>Water</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="waveStrengthSlider">Wave Strength: <span id="waveStrengthValue" class="current-value">0.24</span></label>
                            <input type="range" id="waveStrengthSlider" min="0.005" max="0.5" step="0.005" value="0.24">
                        </div>
                        <div class="control-group">
                            <label for="waveFrequencySlider">Wave Frequency: <span id="waveFrequencyValue" class="current-value">0.5</span></label>
                            <input type="range" id="waveFrequencySlider" min="0.5" max="20.0" step="0.1" value="0.5">
                        </div>
                        <div class="control-group">
                            <label for="waveSpeedSlider">Wave Speed: <span id="waveSpeedValue" class="current-value">0.01</span></label>
                            <input type="range" id="waveSpeedSlider" min="0.01" max="2.0" step="0.01" value="0.01">
                        </div>
                        <div class="control-group">
                            <label for="refractiveIndexSlider">Refractive Index: <span id="refractiveIndexValue" class="current-value">1.3</span></label>
                            <input type="range" id="refractiveIndexSlider" min="1.0" max="2.0" step="0.01" value="1.50">
                        </div>
                    </div>
                </details>
                <details>
                    <summary>Terrain</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="terrainHeightSlider">Terrain Height: <span id="terrainHeightValue" class="current-value">0.0</span></label>
                            <input type="range" id="terrainHeightSlider" min="0.0" max="20.0" step="0.1" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="terrainFrequencySlider">Terrain Frequency: <span id="terrainFrequencyValue" class="current-value">0.15</span></label>
                            <input type="range" id="terrainFrequencySlider" min="0.01" max="1.0" step="0.01" value="0.15">
                        </div>
                    </div>
                </details>
                <details open>
                    <summary>Raytracing Settings</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="bouncesSlider">Max Bounces: <span id="bouncesValue" class="current-value">2</span></label>
                            <input type="range" id="bouncesSlider" min="1" max="10" step="1" value="2">
                        </div>
                        <div class="control-group">
                            <label for="raymarchStepsSlider">Max Raymarch Steps: <span id="raymarchStepsValue" class="current-value">150</span></label>
                            <input type="range" id="raymarchStepsSlider" min="100" max="1000" step="50" value="150">
                        </div>
                        <div class="control-group">
                            <label for="shadowSamplesSlider">Shadow Samples: <span id="shadowSamplesValue" class="current-value">2</span></label>
                            <input type="range" id="shadowSamplesSlider" min="1" max="32" step="1" value="2">
                        </div>
                        <div class="control-group">
                            <label for="dofSamplesSlider">DOF Samples: <span id="dofSamplesValue" class="current-value">4</span></label>
                            <input type="range" id="dofSamplesSlider" min="1" max="32" step="1" value="4">
                        </div>
                    </div>
                </details>
                <details>
                    <summary>Cloud Controls</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="cloudLayerMinYSlider">Layer Min Y: <span id="cloudLayerMinYValue" class="current-value">20.0</span></label>
                            <input type="range" id="cloudLayerMinYSlider" min="0.0" max="50.0" step="0.5" value="20.0">
                        </div>
                        <div class="control-group">
                            <label for="cloudLayerMaxYSlider">Layer Max Y: <span id="cloudLayerMaxYValue" class="current-value">30.0</span></label>
                            <input type="range" id="cloudLayerMaxYSlider" min="0.0" max="50.0" step="0.5" value="30.0">
                        </div>
                        <div class="control-group">
                            <label for="cloudNoiseScaleSlider">Noise Scale: <span id="cloudNoiseScaleValue" class="current-value">0.05</span></label>
                            <input type="range" id="cloudNoiseScaleSlider" min="0.001" max="0.5" step="0.001" value="0.05">
                        </div>
                        <div class="control-group">
                            <label for="cloudDensityThresholdSlider">Density Threshold: <span id="cloudDensityThresholdValue" class="current-value">0.3</span></label>
                            <input type="range" id="cloudDensityThresholdSlider" min="0.0" max="1.0" step="0.01" value="0.3">
                        </div>
                        <div class="control-group">
                            <label for="cloudDensityMultiplierSlider">Density Multiplier: <span id="cloudDensityMultiplierValue" class="current-value">1.0</span></label>
                            <input type="range" id="cloudDensityMultiplierSlider" min="0.0" max="5.0" step="0.1" value="1.0">
                        </div>
                        <div class="control-group">
                            <label for="cloudMarchStepsSlider">March Steps: <span id="cloudMarchStepsValue" class="current-value">64</span></label>
                            <input type="range" id="cloudMarchStepsSlider" min="8" max="256" step="8" value="64">
                        </div>
                        <div class="control-group">
                            <label for="cloudScatteringCoeffSlider">Scattering: <span id="cloudScatteringCoeffValue" class="current-value">0.7</span></label>
                            <input type="range" id="cloudScatteringCoeffSlider" min="0.0" max="1.0" step="0.01" value="0.7">
                        </div>
                        <div class="control-group">
                            <label for="cloudAbsorptionCoeffSlider">Absorption: <span id="cloudAbsorptionCoeffValue" class="current-value">0.3</span></label>
                            <input type="range" id="cloudAbsorptionCoeffSlider" min="0.0" max="1.0" step="0.01" value="0.3">
                        </div>
                        <div class="control-group">
                            <label for="cloudColorRSlider">Base Color R: <span id="cloudColorRValue" class="current-value">0.8</span></label>
                            <input type="range" id="cloudColorRSlider" min="0.0" max="1.0" step="0.01" value="0.8">
                        </div>
                        <div class="control-group">
                            <label for="cloudColorGSlider">Base Color G: <span id="cloudColorGValue" class="current-value">0.8</span></label>
                            <input type="range" id="cloudColorGSlider" min="0.0" max="1.0" step="0.01" value="0.8">
                        </div>
                        <div class="control-group">
                            <label for="cloudColorBSlider">Base Color B: <span id="cloudColorBValue" class="current-value">0.85</span></label>
                            <input type="range" id="cloudColorBSlider" min="0.0" max="1.0" step="0.01" value="0.85">
                        </div>
                        <div class="control-group">
                            <label for="cloudAnimationSpeedSlider">Animation Speed: <span id="cloudAnimationSpeedValue" class="current-value">0.03</span></label>
                            <input type="range" id="cloudAnimationSpeedSlider" min="0.0" max="0.5" step="0.005" value="0.03">
                        </div>
                    </div>
                </details>
                <div class="github-link">
                    <a href="https://github.com/your-repo-link" target="_blank">View on GitHub</a>
                </div>
            </div>
        </div>
    </div>
    <div id="error-message-display" class="error-message"></div>
    <script type="text/javascript">
        // NovaRay Iteration: 5 - Knowledge Base Setup, Documentation & Framework Solidification
        // --- IMPORTANT: Core Directives & Troubleshooting Log References ---
        // This section ensures adherence to the core development principles and leverages
        // our historical knowledge base for robust, high-quality code.
        //
        // Document: 'NOVARAY_CORE_DIRECTIVES.md'
        // This document contains the fundamental principles and quality standards for all development.
        //
        // Document: 'NOVARAY_TROUBLESHOOTING_LOG.md'
        // This document serves as the comprehensive history and detailed solutions for all encountered issues.
        // It should be consulted for in-depth understanding of recurring problems.
        //
        // Document: 'NOVARAY_WEBGPU_RESOURCES.md'
        // This document collects external resources, tools, and general tips for debugging WebGPU applications.
        //
        // --- End References & Checks ---
        //
        // Troubleshooting Log (In-Code Summary):
        // This section provides a brief summary of the most recent and relevant troubleshooting steps directly related to this file.
        // For the complete and detailed troubleshooting history, refer to the 'NOVARAY_TROUBLESHOOTING_LOG.md' document.
        //
        // - NovaRay Phase 3 & 4 (Completed): Modularized engine into NovaRayEngine, ResourceManager, ShaderManager, SceneManager (with Async BVH), UIManager.
        //   Implemented foundation for 3D noise texture generation. Refer to NOVARAY_PROGRESS_LOG.md for details.
        // - NovaRay Phase 5 (Current): Knowledge Base file creation and full documentation pass. Integration of 3D noise into main raytracer.
        //
        // - Previous Critical (WebGPUTracer): Persistent `textureLoad` and sampler/texture type errors.
        //   Resolved by ensuring explicit mipmap levels, correct texture usage flags (STORAGE_BINDING | TEXTURE_BINDING),
        //   and compatible sampler/texture `sampleType` ('unfilterable-float' with 'non-filtering' sampler) for rgba32float.

const bvhWorkerScript = `
    // --- BVH Data Structures and Logic (CPU side, for Worker) ---
    // This script is intended to be run in a Web Worker.
    // It does not have access to the DOM or global variables from the main thread.

    class AABB {
        constructor(min, max) {
            this.min = min; // [x, y, z]
            this.max = max; // [x, y, z]
        }

        static fromSphere(sphere) {
            return new AABB(
                [sphere.position[0] - sphere.radius, sphere.position[1] - sphere.radius, sphere.position[2] - sphere.radius],
                [sphere.position[0] + sphere.radius, sphere.position[1] + sphere.radius, sphere.position[2] + sphere.radius]
            );
        }

        expand(point) {
            this.min[0] = Math.min(this.min[0], point[0]);
            this.min[1] = Math.min(this.min[1], point[1]);
            this.min[2] = Math.min(this.min[2], point[2]);
            this.max[0] = Math.max(this.max[0], point[0]);
            this.max[1] = Math.max(this.max[1], point[1]);
            this.max[2] = Math.max(this.max[2], point[2]);
        }

        union(other) {
            this.min[0] = Math.min(this.min[0], other.min[0]);
            this.min[1] = Math.min(this.min[1], other.min[1]);
            this.min[2] = Math.min(this.min[2], other.min[2]);
            this.max[0] = Math.max(this.max[0], other.max[0]);
            this.max[1] = Math.max(this.max[1], other.max[1]);
            this.max[2] = Math.max(this.max[2], other.max[2]);
        }

        centroid() {
            return [
                (this.min[0] + this.max[0]) * 0.5,
                (this.min[1] + this.max[1]) * 0.5,
                (this.min[2] + this.max[2]) * 0.5
            ];
        }

        longestAxis() {
            const dx = this.max[0] - this.min[0];
            const dy = this.max[1] - this.min[1];
            const dz = this.max[2] - this.min[2];
            if (dx > dy && dx > dz) return 0;
            if (dy > dz) return 1;
            return 2;
        }

        surfaceArea() {
            const dx = this.max[0] - this.min[0];
            const dy = this.max[1] - this.min[1];
            const dz = this.max[2] - this.min[2];
            return 2 * (dx * dy + dx * dz + dy * dz);
        }
    }

    class BvhNode {
        constructor() {
            this.minBounds = [Infinity, Infinity, Infinity];
            this.maxBounds = [-Infinity, -Infinity, -Infinity];
            this.isLeaf = 0; // 0 for internal, 1 for leaf
            this.primitiveCount = 0;
            // For internal nodes: index of the left child in flattenedNodes. Right child is leftChild + 1.
            // For leaf nodes: index of the first primitive in the original primitiveIndices array.
            this.leftChildOrFirstPrimitiveIndex = 0;
        }
    }

    const BVH_LEAF_SIZE = 4; // Max number of primitives in a leaf node

    // Build the BVH recursively using Surface Area Heuristic (SAH)
    function buildBvhRecursive(primitives, primitiveInfos, start, end, totalPrimitives, flattenedNodes, orderedPrimitiveIndices) {
        const nodeIndex = flattenedNodes.length;
        const node = new BvhNode();
        flattenedNodes.push(node); // Add node to the list

        // Calculate bounds for all primitives in this range
        let bounds = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
        for (let i = start; i < end; ++i) {
            bounds.union(primitiveInfos[i].bounds);
        }
        node.minBounds = bounds.min;
        node.maxBounds = bounds.max;

        const nPrimitives = end - start;

        if (nPrimitives <= BVH_LEAF_SIZE) {
            // Create leaf node
            node.isLeaf = 1;
            node.primitiveCount = nPrimitives;
            node.leftChildOrFirstPrimitiveIndex = orderedPrimitiveIndices.length; // Store start index in the global ordered list
            for (let i = start; i < end; ++i) {
                orderedPrimitiveIndices.push(primitiveInfos[i].originalIndex);
            }
        } else {
            // Create internal node
            node.isLeaf = 0;
            node.primitiveCount = 0; // Internal nodes don't store primitive count directly like leaves

            // Calculate centroid bounds for SAH partitioning
            let centroidBounds = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
            for (let i = start; i < end; ++i) {
                centroidBounds.expand(primitiveInfos[i].centroid);
            }
            const dim = centroidBounds.longestAxis();

            // Partition primitives based on SAH
            let mid = start; // Default mid if no good split found
            if (centroidBounds.max[dim] === centroidBounds.min[dim]) {
                // If centroids are all aligned on this axis, just split in the middle
                mid = start + Math.floor(nPrimitives / 2);
            } else {
                // Use SAH to find the best split
                const nBuckets = 12;
                const buckets = Array(nBuckets).fill(null).map(() => ({ count: 0, bounds: new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]) }));

                for (let i = start; i < end; ++i) {
                    let b = Math.floor(nBuckets * ((primitiveInfos[i].centroid[dim] - centroidBounds.min[dim]) / (centroidBounds.max[dim] - centroidBounds.min[dim])));
                    b = Math.max(0, Math.min(nBuckets - 1, b)); // Clamp b to [0, nBuckets-1]
                    buckets[b].count++;
                    buckets[b].bounds.union(primitiveInfos[i].bounds);
                }

                const cost = Array(nBuckets - 1).fill(0);
                for (let i = 0; i < nBuckets - 1; ++i) {
                    let b0 = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
                    let b1 = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
                    let count0 = 0, count1 = 0;
                    for (let j = 0; j <= i; ++j) {
                        b0.union(buckets[j].bounds);
                        count0 += buckets[j].count;
                    }
                    for (let j = i + 1; j < nBuckets; ++j) {
                        b1.union(buckets[j].bounds);
                        count1 += buckets[j].count;
                    }
                    cost[i] = 0.1 + (count0 * b0.surfaceArea() + count1 * b1.surfaceArea()) / bounds.surfaceArea();
                }

                let minCost = cost[0];
                let minCostSplitBucket = 0;
                for (let i = 1; i < nBuckets - 1; ++i) {
                    if (cost[i] < minCost) {
                        minCost = cost[i];
                        minCostSplitBucket = i;
                    }
                }

                // Partition primitives based on the best split
                const pmid = primitiveInfos.slice(start, end).sort((a, b) => a.centroid[dim] - b.centroid[dim]);
                primitiveInfos.splice(start, nPrimitives, ...pmid);

                let currentMid = start;
                for(let i = start; i < end; ++i) {
                    let b = Math.floor(nBuckets * ((primitiveInfos[i].centroid[dim] - centroidBounds.min[dim]) / (centroidBounds.max[dim] - centroidBounds.min[dim])));
                    b = Math.max(0, Math.min(nBuckets - 1, b));
                    if (b <= minCostSplitBucket) {
                        [primitiveInfos[i], primitiveInfos[currentMid]] = [primitiveInfos[currentMid], primitiveInfos[i]];
                        currentMid++;
                    }
                }
                mid = currentMid;

                // If SAH fails to produce a good split, fallback to middle split
                if (mid === start || mid === end) {
                    mid = start + Math.floor(nPrimitives / 2);
                     // Sort along the chosen axis before splitting if falling back
                    const pmidFallback = primitiveInfos.slice(start, end).sort((a, b) => a.centroid[dim] - b.centroid[dim]);
                    primitiveInfos.splice(start, nPrimitives, ...pmidFallback);
                }
            }

            node.leftChildOrFirstPrimitiveIndex = flattenedNodes.length; // Left child will be next in the array
            buildBvhRecursive(primitives, primitiveInfos, start, mid, totalPrimitives, flattenedNodes, orderedPrimitiveIndices);
            buildBvhRecursive(primitives, primitiveInfos, mid, end, totalPrimitives, flattenedNodes, orderedPrimitiveIndices);
        }
        return nodeIndex;
    }

    function buildBvhStructure(primitives) {
        // Primitives here are expected to be simplified: { position: [x,y,z], radius: r, originalIndex: i }
        if (!primitives || primitives.length === 0) {
            return { bvhNodes: [], primitiveIndices: [] };
        }

        const primitiveInfos = primitives.map((p, i) => {
            const bounds = AABB.fromSphere(p);
            return {
                originalIndex: p.originalIndex !== undefined ? p.originalIndex : i, // Use originalIndex if provided
                bounds: bounds,
                centroid: bounds.centroid()
            };
        });

        const flattenedNodes = [];
        const orderedPrimitiveIndices = []; // This will store the reordered primitive indices for leaf nodes

        buildBvhRecursive(primitives, primitiveInfos, 0, primitiveInfos.length, primitiveInfos.length, flattenedNodes, orderedPrimitiveIndices);

        const bvhNodesFlat = new Float32Array(flattenedNodes.length * 12);
        flattenedNodes.forEach((node, i) => {
            let offset = i * 12;
            bvhNodesFlat[offset + 0] = node.minBounds[0];
            bvhNodesFlat[offset + 1] = node.minBounds[1];
            bvhNodesFlat[offset + 2] = node.minBounds[2];
            bvhNodesFlat[offset + 3] = node.isLeaf;

            bvhNodesFlat[offset + 4] = node.maxBounds[0];
            bvhNodesFlat[offset + 5] = node.maxBounds[1];
            bvhNodesFlat[offset + 6] = node.maxBounds[2];
            bvhNodesFlat[offset + 7] = node.primitiveCount;

            bvhNodesFlat[offset + 8] = node.leftChildOrFirstPrimitiveIndex;
        });

        const primitiveIndicesFlat = new Uint32Array(orderedPrimitiveIndices);

        return {
            bvhNodesFlat: bvhNodesFlat,
            primitiveIndicesFlat: primitiveIndicesFlat
        };
    }

    self.onmessage = function(event) {
        const { spheresData } = event.data;
        try {
            const { bvhNodesFlat, primitiveIndicesFlat } = buildBvhStructure(spheresData);
            self.postMessage({
                status: 'success',
                bvhNodes: bvhNodesFlat.buffer,
                primitiveIndices: primitiveIndicesFlat.buffer
            }, [bvhNodesFlat.buffer, primitiveIndicesFlat.buffer]);
        } catch (error) {
            console.error('BVH Worker Error:', error);
            self.postMessage({ status: 'error', message: error.message, stack: error.stack });
        }
    };
`;

        /**
         * @file NovaRay.html
         * @description Main HTML file for the NovaRay WebGPU compute-based raytracer.
         * This file encapsulates all HTML, CSS, JavaScript, and WGSL shader code.
         * Developed with AI assistance, focusing on modularity and high performance.
         */

        // NovaRay Iteration: 5 - Knowledge Base Setup, Documentation & Framework Solidification

        /**
         * @object NovaRayEngine
         * @description The central orchestrator for the NovaRay WebGPU raytracer.
         * Manages WebGPU device, context, resources, shaders, scene, UI, and the main render loop.
         * It also holds global state related to rendering and input.
         */
        const NovaRayEngine = {
            /** @type {GPUAdapter?} The WebGPU adapter. */
            adapter: null,
            /** @type {GPUDevice?} The WebGPU logical device. */
            device: null,
            /** @type {GPUCanvasContext?} The context for the WebGPU canvas. */
            context: null,
            /** @type {GPUTextureFormat?} The preferred format for the canvas presentation. */
            presentationFormat: null,
            /** @type {HTMLCanvasElement?} The HTML canvas element for rendering. */
            canvas: null,

            /** @type {Worker?} Web Worker for asynchronous BVH construction. */
            bvhWorker: null,
            /** @type {boolean} Flag indicating if BVH construction is currently in progress. */
            isBVHBuilding: false,
            /** @type {Array<Object>} Stores the latest sphere data for the BVH worker. */
            latestSphereDataForWorker: [],
            /** @type {Promise?} Promise for managing BVH update completion. */
            bvhUpdatePromise: null,

            /** @type {object?} Manages GPU resource creation (buffers, textures, samplers). */
            resourceManager: null,
            /** @type {object?} Manages WGSL shader code and pipeline compilation. */
            shaderManager: null,
            /** @type {SceneManager?} Manages scene data, objects, and related logic. */
            sceneManager: null,
            /** @type {UIManager?} Manages UI elements, interactions, and view state. */
            uiManager: null,

            /** @type {GPUComputePipeline?} Main compute pipeline for raytracing. */
            computePipeline: null,
            /** @type {GPURenderPipeline?} Pipeline for rendering the final image to canvas. */
            renderPipeline: null,
            /** @type {GPUComputePipeline?} Pipeline for the 3D noise generation compute shader. */
            noise3DComputePipeline: null,

            /** @type {GPUTexture?} Primary output texture for ping-pong accumulation. */
            outputTexture0: null,
            /** @type {GPUTexture?} Secondary output texture for ping-pong accumulation. */
            outputTexture1: null,
            /** @type {GPUTextureView?} View for outputTexture0. */
            outputTextureView0: null,
            /** @type {GPUTextureView?} View for outputTexture1. */
            outputTextureView1: null,
            /** @type {GPUSampler?} Sampler for the final render pass. */
            outputSampler: null,
            /** @type {GPUSampler?} Sampler for the 3D noise texture. */
            noiseSampler: null,

            /** @type {GPUTexture?} 3D texture to store generated noise. */
            noiseTexture3D: null,
            /** @type {GPUTextureView?} View for the 3D noise texture. */
            noiseTexture3DView: null,
            /** @type {{width: number, height: number, depth: number}} Dimensions of the 3D noise texture. */
            noiseTextureSize: { width: 32, height: 32, depth: 32 },


            /** @type {GPUBindGroup?} Bind group 0 for main compute pass (UBOs, textures). */
            computeBindGroup0: null,
            /** @type {GPUBindGroup?} Bind group 1 for main compute pass (scene data). */
            computeBindGroup1: null,
            /** @type {GPUBindGroup?} Bind group for the render pass. */
            renderBindGroup: null,
            /** @type {GPUBuffer?} Vertex buffer for the full-screen quad in the render pass. */
            renderQuadVertexBuffer: null,

            // UBO Buffers
            cameraUBOBuffer: null,
            lightUBOBuffer: null,
            timeUBOBuffer: null,
            waterUBOBuffer: null,
            terrainUBOBuffer: null,
            raytracerUBOBuffer: null,
            cloudParamsUBOBuffer: null, // Added for cloud parameters

            // Storage Buffers
            bvhNodesBuffer: null,
            primitiveIndicesBuffer: null,
            sphereDataBuffer: null, // Also used for bounding spheres of procedural meshes
            meshInstanceDataBuffer: null, // Stores metadata for each mesh instance
            vertexDataBuffer: null,       // Stores all vertices for all meshes
            triangleIndexDataBuffer: null,// Stores all triangle indices for all meshes


            // Frame / Time / Input State
            /** @type {number} Current frame count for accumulation rendering. */
            frameCount: 0,
            /** @type {number} Total elapsed time since rendering started, in seconds. */
            totalTime: 0,
            /** @type {number} Timestamp of when rendering started, for calculating totalTime. */
            startTimeForTotalTime: 0,
            /** @type {number} Index (0 or 1) indicating the current target texture for ping-ponging. */
            currentTextureIndex: 0,
            /** @type {number?} ID for the requestAnimationFrame loop. */
            animationFrameId: null,
            /** @type {boolean} Flag indicating if render accumulation needs to be reset. */
            accumulationNeedsReset: true,

            /** @type {object} State of currently pressed keys. */
            keysPressed: {},
            /** @type {boolean} Whether the mouse button is currently pressed down on the canvas. */
            isMouseDown: false,
            /** @type {number} Last recorded X coordinate of the mouse. */
            lastMouseX: 0,
            /** @type {number} Last recorded Y coordinate of the mouse. */
            lastMouseY: 0,

            /**
             * Initializes the NovaRayEngine, including WebGPU setup, manager instantiation,
             * resource creation (including 3D noise texture), pipeline compilation, and scene setup.
             * @async
             * @param {HTMLCanvasElement} canvasElement - The canvas element for rendering.
             * @param {HTMLElement} loadingStatusElement - DOM element to display loading status (passed to UIManager).
             * @param {HTMLElement} errorDisplayElement - DOM element to display error messages (passed to UIManager).
             * @returns {Promise<boolean>} True if initialization was successful, false otherwise.
             */
            async initialize(canvasElement, loadingStatusElement, errorDisplayElement) {
                this.canvas = canvasElement;

                this.uiManager = new UIManager(this);
                this.uiManager.initDOMElements();
                this.uiManager.loadingStatusP = loadingStatusElement; // Allow UIManager to use these specific elements initially
                this.uiManager.errorMessageDisplay = errorDisplayElement;

                this.uiManager.setLoadingStatus("Initializing NovaRay Engine...");

                try {
                    if (this.device) {
                        console.log("Destroying previous WebGPU device (simplified)...");
                         await this.device.queue.onSubmittedWorkDone().catch(e => console.warn("Error during queue sync before destroy:", e));
                        this.device.destroy();
                        console.log("Previous device destroyed.");
                        this.device = null;
                    }

                    this.uiManager.setLoadingStatus("Checking WebGPU support...");
                    if (!navigator.gpu) {
                        throw new Error("WebGPU not supported in your browser.");
                    }

                    this.uiManager.setLoadingStatus("Requesting GPU adapter...");
                    this.adapter = await navigator.gpu.requestAdapter();
                    if (!this.adapter) {
                        throw new Error("No appropriate GPU adapter found.");
                    }

                    this.uiManager.setLoadingStatus("Requesting GPU device...");
                    const requiredFeatures = [];
                    this.device = await this.adapter.requestDevice({requiredFeatures});
                    if (!this.device) {
                        throw new Error("Could not acquire a WebGPU device.");
                    }
                    console.log("WebGPU device successfully acquired.");
                    this.uiManager.setLoadingStatus("GPU device acquired. Initializing Resource Manager...");

                    /**
                     * @object NovaRayEngine.resourceManager
                     * @description Manages the creation of GPU resources like buffers, textures, and samplers.
                     * It ensures that resource creation is centralized and uses the correct GPUDevice.
                     */
                    this.resourceManager = {
                        device: this.device,
                        /**
                         * Creates a GPU buffer.
                         * @param {GPUBufferDescriptor} descriptor - The buffer descriptor.
                         * @param {string} [label="Buffer"] - Optional label for debugging.
                         * @returns {GPUBuffer} The created GPU buffer.
                         */
                        createBuffer: function(descriptor, label = "Buffer") {
                            return this.device.createBuffer(descriptor);
                        },
                        /**
                         * Creates a GPU texture.
                         * @param {GPUTextureDescriptor} descriptor - The texture descriptor.
                         * @param {string} [label="Texture"] - Optional label for debugging.
                         * @returns {GPUTexture} The created GPU texture.
                         */
                        createTexture: function(descriptor, label = "Texture") {
                            return this.device.createTexture(descriptor);
                        },
                        /**
                         * Creates a GPU sampler.
                         * @param {GPUSamplerDescriptor} descriptor - The sampler descriptor.
                         * @param {string} [label="Sampler"] - Optional label for debugging.
                         * @returns {GPUSampler} The created GPU sampler.
                         */
                        createSampler: function(descriptor, label = "Sampler") {
                            return this.device.createSampler(descriptor);
                        }
                    };
                    console.log("ResourceManager initialized.");
                    this.uiManager.setLoadingStatus("ResourceManager initialized. Initializing ShaderManager...");

                    /**
                     * @object NovaRayEngine.shaderManager
                     * @description Manages WGSL shader code strings, creation of GPUShaderModule objects,
                     * and asynchronous compilation of GPUComputePipeline and GPURenderPipeline objects.
                     */
                    this.shaderManager = {
                        device: this.device,
                        /** @type {string} WGSL code for the main raytracing compute shader. */
                        wgslCompute: ``,
                        /** @type {string} WGSL code for the render shader (displays final image). */
                        wgslRender: ``,
                        /** @type {string} WGSL code for the 3D noise generation compute shader. */
                        wgslNoise3DCompute: ``,

                        /**
                         * Creates a GPU shader module from WGSL code.
                         * @async
                         * @param {string} code - The WGSL shader code.
                         * @param {string} label - A label for the shader module (for debugging).
                         * @returns {Promise<GPUShaderModule>} The created shader module.
                         * @throws Will throw an error if shader code is empty.
                         */
                        createShaderModule: async function(code, label) {
                            if (!code || code.trim() === "") {
                                throw new Error(\`ShaderManager: Shader code for \${label} is empty.\`);
                            }
                            return this.device.createShaderModule({ label, code });
                        },
                        /**
                         * Creates a GPU compute pipeline asynchronously.
                         * @async
                         * @param {GPUComputePipelineDescriptor} descriptor - The pipeline descriptor.
                         * @param {string} [label="Compute Pipeline"] - Optional label for debugging.
                         * @returns {Promise<GPUComputePipeline>} The created compute pipeline.
                         * @throws Will throw an error if pipeline creation fails validation.
                         */
                        createComputePipeline: async function(descriptor, label = "Compute Pipeline") {
                            this.device.pushErrorScope('validation');
                            const pipeline = await this.device.createComputePipelineAsync(descriptor);
                            const error = await this.device.popErrorScope();
                            if (error) {
                                throw new Error(\`ShaderManager: \${label} creation failed: \${error.message}\`);
                            }
                            return pipeline;
                        },
                        /**
                         * Creates a GPU render pipeline asynchronously.
                         * @async
                         * @param {GPURenderPipelineDescriptor} descriptor - The pipeline descriptor.
                         * @param {string} [label="Render Pipeline"] - Optional label for debugging.
                         * @returns {Promise<GPURenderPipeline>} The created render pipeline.
                         * @throws Will throw an error if pipeline creation fails validation.
                         */
                        createRenderPipeline: async function(descriptor, label = "Render Pipeline") {
                            this.device.pushErrorScope('validation');
                            const pipeline = await this.device.createRenderPipelineAsync(descriptor);
                            const error = await this.device.popErrorScope();
                            if (error) {
                                throw new Error(\`ShaderManager: \${label} creation failed: \${error.message}\`);
                            }
                            return pipeline;
                        }
                    };
                    this.shaderManager.wgslCompute = \`
                // WGSL Compute Shader for Raytracing
                // Main raytracing logic, including material evaluation, lighting, and BVH traversal.

                // Perlin Noise (existing, used by domainWarp and procedural elements)
                var<private> perm: array<u32, 512> = array<u32, 512>(/* ... Perlin table ... */);
                var<private> grad3: array<vec3<f32>, 12> = array<vec3<f32>, 12>(/* ... Perlin gradients ... */);
                fn mod289(x: vec3<f32>) -> vec3<f32> { return x - floor(x / 289.0f) * 289.0f; }
                fn mod289_f(x: f32) -> f32 { return x - floor(x / 289.0f) * 289.0f; }
                fn hash_grad(x: u32, y: u32, z: u32) -> u32 { return perm[ (perm[ (perm[x % 256u] + y) % 256u ] + z) % 256u ]; }
                fn snoise(p: vec3<f32>) -> f32 { /* ... Classic Perlin snoise implementation ... */
                    let F3 = 1.0f/3.0f; let G3 = 1.0f/6.0f;
                    let s = (p.x + p.y + p.z) * F3; let i_float = floor(p + vec3<f32>(s)); let t = (i_float.x + i_float.y + i_float.z) * G3;
                    let x0 = p - i_float + vec3<f32>(t); let g = step(x0.xyz, x0.yzx); let l = 1.0f - g;
                    let i1 = min(g.xyz, l.yzx); let i2 = max(g.xyz, l.yzx);
                    let i_u32 = vec3<u32>(i_float); let ii = i_u32 % 256u;
                    let x1 = x0 - i1 + G3; let x2 = x0 - i2 + 2.0f * G3; let x3 = x0 - 1.0f + 3.0f * G3;
                    let gi0 = hash_grad(ii.x, ii.y, ii.z); let gi1 = hash_grad(ii.x + u32(i1.x), ii.y + u32(i1.y), ii.z + u32(i1.z));
                    let gi2 = hash_grad(ii.x + u32(i2.x), ii.y + u32(i2.y), ii.z + u32(i2.z)); let gi3 = hash_grad(ii.x + 1u, ii.y + 1u, ii.z + 1u);
                    var sum: f32 = 0.0f;
                    var t0 = 0.5f - dot(x0, x0); if (t0 >= 0.0f) { sum += pow(t0, 4.0f) * dot(grad3[gi0 % 12u], x0); }
                    var t1 = 0.5f - dot(x1, x1); if (t1 >= 0.0f) { sum += pow(t1, 4.0f) * dot(grad3[gi1 % 12u], x1); }
                    var t2 = 0.5f - dot(x2, x2); if (t2 >= 0.0f) { sum += pow(t2, 4.0f) * dot(grad3[gi2 % 12u], x2); }
                    var t3 = 0.5f - dot(x3, x3); if (t3 >= 0.0f) { sum += pow(t3, 4.0f) * dot(grad3[gi3 % 12u], x3); }
                    return 32.0f * sum;
                }
                fn rand_float(co: vec2<f32>, seed: f32) -> f32 { return fract(sin(dot(co.xy + vec3<f32>(seed).xy, vec2<f32>(12.9898f, 78.233f))) * 43758.5453f); }
                fn fBm(p: vec3<f32>) -> f32 { var t:f32=0.0; var f:f32=1.0; var a:f32=0.5; for(var i:u32=0u;i<8u;i=i+1u){t+=snoise(p*f)*a;f*=2.0;a*=0.5;} return t;}

                struct CameraUniform{position:vec3<f32>,_pad0:f32,forward:vec3<f32>,_pad1:f32,right:vec3<f32>,_pad2:f32,up:vec3<f32>,_pad3:f32,resolution:vec2<f32>,aspect:f32,fovy:f32,near:f32,far:f32,_pad4:vec2<f32>,};
                struct LightUniform{position:vec3<f32>,brightness:f32,size:f32,_pad0:vec3<f32>,color:vec3<f32>,_pad1:f32,};
                struct Sphere{position_radius:vec4<f32>,albedo_metallic:vec4<f32>,pbr_properties:vec4<f32>,};
                struct BvhNode{minBounds:vec3<f32>,isLeaf:u32,maxBounds:vec3<f32>,primitiveCount:u32,leftChildOrFirstPrimitiveIndex:u32,_pad0:u32,_pad1:u32,_pad2:u32,};
                struct WaterParams{strength:f32,frequency:f32,speed:f32,_pad0:f32,};
                struct TerrainParams{heightScale:f32,frequency:f32,_pad0:f32,_pad1:f32,};
                struct TimeUniform{time:f32,frame_count:u32,_pad0:vec2<f32>,};
                struct RaytracerParams{
                    maxBounces:u32,maxRaymarchSteps:u32,shadowSamples:u32,dofSamples:u32, // 16 bytes
                    numBVHNodes:u32,numPrimitives:u32,skyPreset:u32,numMeshInstances:u32, // 16 bytes (numPrimitives is for BVH, numMeshInstances for actual meshes)
                    warpStrength:f32,focalDistance:f32,apertureSize:f32,_pad1:f32, // 16 bytes
                }; // Total 48 bytes
                struct Ray{origin:vec3<f32>,direction:vec3<f32>,};
                struct HitInfo{hit_pos:vec3<f32>,normal:vec3<f32>,distance:f32,is_hit:bool,object_id:u32,sphere_idx:u32,is_water:bool,}; // sphere_idx will become instance_idx (sphere or mesh)

                // Mesh Data Structures
                struct Vertex {
                    position: vec3<f32>,
                    normal: vec3<f32>,
                    // uv: vec2<f32>, // Add later if needed
                };

                struct Triangle { // Represents indices into a mesh's specific vertex list
                    i0: u32,
                    i1: u32,
                    i2: u32,
                };

                struct MeshInstance { // Metadata for a single mesh instance in the scene
                    vertex_offset: u32, // Offset into the global vertexDataBuffer
                    index_offset: u32,  // Offset into the global triangleIndexDataBuffer
                    num_triangles: u32,
                    material_id: u32, // Could index into a global material buffer or use Sphere struct convention
                    // Bounding sphere for broad phase, if not using BVH for meshes directly
                    // bounding_sphere_center: vec3<f32>,
                    // bounding_sphere_radius: f32,
                };

                // Cloud Parameters UBO
                struct CloudParamsUBO {
                    layerMinY: f32,
                    layerMaxY: f32,
                    noiseScale: f32,
                    densityThreshold: f32,
                    densityMultiplier: f32,
                    marchSteps: u32,
                    scatteringCoeff: f32,
                    absorptionCoeff: f32,
                    baseColorR: f32,
                    baseColorG: f32,
                    baseColorB: f32,
                    animationSpeed: f32,
                };

                const MATERIAL_DIFFUSE:u32=0u;const MATERIAL_REFLECTIVE:u32=1u;const MATERIAL_REFRACTIVE:u32=2u;
                const MIN_DIST:f32=0.0001f;const MAX_DIST:f32=1000.0f;const EPSILON:f32=0.001f;const STACK_SIZE:u32=64u;const PI:f32=3.14159265359f;

                @group(0) @binding(0) var<uniform> cameraUBO: CameraUniform;
                @group(0) @binding(1) var<uniform> lightUBO: LightUniform;
                @group(0) @binding(2) var<uniform> raytracerUBO: RaytracerParams;
                @group(0) @binding(3) var<uniform> timeUBO: TimeUniform;
                @group(0) @binding(4) var<uniform> waterUBO: WaterParams;
                @group(0) @binding(5) var<uniform> terrainUBO: TerrainParams;
                @group(0) @binding(6) var outputTexture: texture_storage_2d<rgba32float, write>;
                @group(0) @binding(7) var inputTexture: texture_2d<f32>;
                @group(0) @binding(8) var noiseSampler: sampler;
                @group(0) @binding(9) var noiseTexture3D: texture_3d<f32>;
                @group(0) @binding(10) var<uniform> cloudParamsUBO: CloudParamsUBO;

                @group(1) @binding(0) var<storage, read> spheres: array<Sphere>; // Also used for mesh bounding spheres if isProceduralRock is true
                @group(1) @binding(1) var<storage, read> bvhNodes: array<BvhNode>;
                @group(1) @binding(2) var<storage, read> primitiveIndices: array<u32>; // Points to sphereDataBuffer indices
                @group(1) @binding(3) var<storage, read> meshInstances: array<MeshInstance>;
                @group(1) @binding(4) var<storage, read> vertexData: array<Vertex>;
                @group(1) @binding(5) var<storage, read> triangleIndexData: array<Triangle>; // Stores all triangles for all meshes

                fn sample3DNoiseTexture(world_pos: vec3<f32>, noise_texture_scale: f32) -> f32 {
                    let scaled_pos = world_pos * noise_texture_scale;
                    return textureSampleLevel(noiseTexture3D, noiseSampler, scaled_pos, 0.0f).r;
                }

                fn domainWarp(p:vec3<f32>,time:f32,strength:f32)->vec3<f32>{if(strength==0.0f){return p;}let offset_factor=vec3<f32>(snoise(p*0.5f+time*0.1f+vec3<f32>(10.0,20.0,30.0)),snoise(p*0.7f-time*0.2f+vec3<f32>(40.0,50.0,60.0)),snoise(p*0.9f+time*0.3f+vec3<f32>(70.0,80.0,90.0)));return p+offset_factor*strength;}
                fn terrainHeight(x:f32,z:f32,time:f32)->f32{if(terrainUBO.heightScale==0.0f){return -100000.0f;}let p_large=vec3<f32>(x,z,time*0.01f)*0.05f;let large_noise=fBm(p_large);let p_detail=vec3<f32>(x,z,time*0.05f)*terrainUBO.frequency;let detail_noise=fBm(p_detail);let center_dist=distance(vec2<f32>(x,z),vec2<f32>(0.0,0.0));let island_factor=smoothstep(150.0f,0.0f,center_dist);let base_h=(0.5f+0.5f*large_noise*0.6f)+(0.5f+0.5f*detail_noise*0.4f);let scaled_h=(base_h/2.0f)*terrainUBO.heightScale;return max(-2.0f,scaled_h*island_factor);}
                fn calculateWaveHeight(x:f32,z:f32,time:f32)->f32{var h:f32=0.0f;let freq=waterUBO.frequency;let str=waterUBO.strength;h+=sin(x*freq+time*waterUBO.speed)*str*0.7f;h+=cos(z*freq*1.5f+time*waterUBO.speed*0.8f)*str*0.5f;h+=sin((x+z)*freq*0.8f+time*waterUBO.speed*1.2f)*str*0.3f;return h;}
                fn sdWaterPlane(p:vec3<f32>,time:f32,warp_strength:f32)->f32{let warped_p=domainWarp(p,time*0.5f,warp_strength);return warped_p.y-calculateWaveHeight(warped_p.x,warped_p.z,time);}
                fn sdSphere(p:vec3<f32>,s:Sphere,warp_strength:f32)->f32{let warped_center=domainWarp(s.position_radius.xyz,timeUBO.time*0.5f,warp_strength);return distance(p,warped_center)-s.position_radius.w;}
                fn intersect_aabb(ro:vec3<f32>,inv_dir:vec3<f32>,min_b:vec3<f32>,max_b:vec3<f32>)->f32{let t1=(min_b-ro)*inv_dir;let t2=(max_b-ro)*inv_dir;let t_min=min(t1,t2);let t_max=max(t1,t2);let te=max(max(t_min.x,t_min.y),t_min.z);let tx=min(min(t_max.x,t_max.y),t_max.z);if(te>tx||tx<0.0f){return -1.0f;}return max(0.0f,te);}
                fn bvh_scene_sdf_spheres(ro:vec3<f32>,rd:vec3<f32>,time:f32,warp_str:f32,closest_d:ptr<function,f32>,closest_idx:ptr<function,u32>){if(raytracerUBO.numPrimitives==0u||raytracerUBO.numBVHNodes==0u){return;}var inv_dir=1.0f/rd;var stack:array<u32,STACK_SIZE>;var stack_ptr:u32=0u;var curr_node_idx=0u;for(var iter:u32=0u;iter<1024u;iter=iter+1u){if(stack_ptr>=STACK_SIZE||curr_node_idx>=raytracerUBO.numBVHNodes){break;}let node=bvhNodes[curr_node_idx];let t=intersect_aabb(ro,inv_dir,node.minBounds,node.maxBounds);if(t==-1.0f||t>*closest_d){if(stack_ptr==0u){break;}stack_ptr=stack_ptr-1u;curr_node_idx=stack[stack_ptr];continue;}if(node.isLeaf==1u){for(var i:u32=0u;i<node.primitiveCount;i=i+1u){let sph_idx=primitiveIndices[node.leftChildOrFirstPrimitiveIndex+i];if(sph_idx>=raytracerUBO.numPrimitives){continue;}let s=spheres[sph_idx];let d=sdSphere(ro,s,warp_str);if(d<*closest_d){*closest_d=d;*closest_idx=sph_idx;}}if(stack_ptr==0u){break;}stack_ptr=stack_ptr-1u;curr_node_idx=stack[stack_ptr];}else{let left_child=node.leftChildOrFirstPrimitiveIndex;let right_child=node.leftChildOrFirstPrimitiveIndex+1u;if(left_child>=raytracerUBO.numBVHNodes||right_child>=raytracerUBO.numBVHNodes){if(stack_ptr==0u){break;}stack_ptr=stack_ptr-1u;curr_node_idx=stack[stack_ptr];continue;}let t_l=intersect_aabb(ro,inv_dir,bvhNodes[left_child].minBounds,bvhNodes[left_child].maxBounds);let t_r=intersect_aabb(ro,inv_dir,bvhNodes[right_child].minBounds,bvhNodes[right_child].maxBounds);if(t_l!=-1.0f&&t_r!=-1.0f){if(t_l<t_r){stack[stack_ptr]=right_child;stack_ptr=stack_ptr+1u;curr_node_idx=left_child;}else{stack[stack_ptr]=left_child;stack_ptr=stack_ptr+1u;curr_node_idx=right_child;}}else if(t_l!=-1.0f){curr_node_idx=left_child;}else if(t_r!=-1.0f){curr_node_idx=right_child;}else{if(stack_ptr==0u){break;}stack_ptr=stack_ptr-1u;curr_node_idx=stack[stack_ptr];}}}}
                fn sceneSDF(p:vec3<f32>,time:f32,warp_str:f32,obj_id:ptr<function,u32>)->f32{var min_d:f32=MAX_DIST;*obj_id=999u;let terrain_d=p.y-terrainHeight(p.x,p.z,time);if(terrain_d<min_d){min_d=terrain_d;*obj_id=0u;}let water_d=sdWaterPlane(p,time,warp_str);if(water_d<min_d){min_d=water_d;*obj_id=1u;}var closest_sph_d=MAX_DIST;var closest_sph_idx:u32=0u;bvh_scene_sdf_spheres(p,vec3<f32>(0.0f),time,warp_str,&closest_sph_d,&closest_sph_idx);if(closest_sph_d<min_d){min_d=closest_sph_d;*obj_id=closest_sph_idx+2u;}return min_d;}
                fn estimateNormal(p:vec3<f32>,time:f32,warp_str:f32,obj_id_hint:u32)->vec3<f32>{var id_dummy:u32=0u;let gx=sceneSDF(p+vec3<f32>(EPSILON,0.0,0.0),time,warp_str,&id_dummy)-sceneSDF(p-vec3<f32>(EPSILON,0.0,0.0),time,warp_str,&id_dummy);let gy=sceneSDF(p+vec3<f32>(0.0,EPSILON,0.0),time,warp_str,&id_dummy)-sceneSDF(p-vec3<f32>(0.0,EPSILON,0.0),time,warp_str,&id_dummy);let gz=sceneSDF(p+vec3<f32>(0.0,0.0,EPSILON),time,warp_str,&id_dummy)-sceneSDF(p-vec3<f32>(0.0,0.0,EPSILON),time,warp_str,&id_dummy);return normalize(vec3<f32>(gx,gy,gz));}
                fn calculateWaterNormal(p:vec3<f32>,time:f32,warp_str:f32)->vec3<f32>{let wp=domainWarp(p,time*0.5f,warp_str);let x=wp.x;let z=wp.z;let hb=calculateWaveHeight(x,z,time);let eps=0.001f;let hx=calculateWaveHeight(x+eps,z,time);let hz=calculateWaveHeight(x,z+eps,time);return normalize(vec3<f32>(-(hx-hb)/eps,1.0f,-(hz-hb)/eps));}
                fn calculateTerrainNormal(p:vec3<f32>,time:f32,warp_str:f32)->vec3<f32>{let wp=domainWarp(p,time*0.5f,warp_str);let x=wp.x;let z=wp.z;let hb=terrainHeight(x,z,time);let eps=0.001f;let hx=terrainHeight(x+eps,z,time);let hz=terrainHeight(x,z+eps,time);return normalize(vec3<f32>(-(hx-hb)/eps,1.0f,-(hz-hb)/eps));}
                fn raymarch(ray:Ray,time:f32,warp_str:f32)->HitInfo{var hi:HitInfo;hi.is_hit=false;hi.distance=MAX_DIST;hi.sphere_idx=0u;hi.is_water=false;var total_dist:f32=0.0f;var curr_obj_id:u32=999u;for(var i:u32=0u;i<raytracerUBO.maxRaymarchSteps;i=i+1u){let cp=ray.origin+ray.direction*total_dist;let d=sceneSDF(cp,time,warp_str,&curr_obj_id);if(d<MIN_DIST){hi.is_hit=true;hi.hit_pos=cp;hi.distance=total_dist;hi.object_id=curr_obj_id;if(curr_obj_id==1u){hi.normal=calculateWaterNormal(cp,time,warp_str);hi.is_water=true;}else if(curr_obj_id==0u){hi.normal=calculateTerrainNormal(cp,time,warp_str);hi.is_water=false;}else{hi.sphere_idx=curr_obj_id-2u;hi.normal=estimateNormal(cp,time,warp_str,curr_obj_id);hi.is_water=false;}break;}total_dist+=d;if(total_dist>=MAX_DIST){break;}}return hi;}

                fn getSkyColor(rd:vec3<f32>,sky_preset:u32)->vec3<f32>{let sun_dir=normalize(lightUBO.position.xyz);let sun_dot=dot(rd,sun_dir);let sun_i=smoothstep(0.99f,1.0f,sun_dot);let sun_c=lightUBO.color*sun_i*lightUBO.brightness;var sky_top:vec3<f32>;var sky_hor:vec3<f32>;if(sky_preset==0u){sky_top=vec3<f32>(0.5,0.7,1.0);sky_hor=vec3<f32>(0.7,0.8,0.9);}else{sky_top=vec3<f32>(0.6,0.7,0.85);sky_hor=vec3<f32>(1.0,0.8,0.6);}let yf=max(0.0f,rd.y);let grad_c=mix(sky_hor,sky_top,yf);return grad_c+sun_c;}

                fn renderClouds(ray_origin: vec3<f32>, ray_direction: vec3<f32>, t_max_sky: f32, sky_preset_val: u32) -> vec4<f32> {
                    let base_sky_color = getSkyColor(ray_direction, sky_preset_val);
                    var accumulated_color = vec3<f32>(0.0f);
                    var accumulated_alpha = 0.0f;

                    var t_min_cloud_layer = (cloudParamsUBO.layerMinY - ray_origin.y) / ray_direction.y;
                    var t_max_cloud_layer = (cloudParamsUBO.layerMaxY - ray_origin.y) / ray_direction.y;

                    if (ray_direction.y == 0.0f) {
                        if (ray_origin.y < cloudParamsUBO.layerMinY || ray_origin.y > cloudParamsUBO.layerMaxY) {
                            return vec4<f32>(base_sky_color, 1.0f);
                        }
                        t_min_cloud_layer = 0.0f;
                        t_max_cloud_layer = t_max_sky;
                    }

                    if (t_min_cloud_layer > t_max_cloud_layer) {
                        let temp = t_min_cloud_layer;
                        t_min_cloud_layer = t_max_cloud_layer;
                        t_max_cloud_layer = temp;
                    }

                    let t_enter = max(0.0f, t_min_cloud_layer);
                    let t_exit = min(t_max_sky, t_max_cloud_layer);

                    if (t_enter >= t_exit || t_exit < 0.0f) {
                        return vec4<f32>(base_sky_color, 1.0f);
                    }

                    let march_steps_actual = cloudParamsUBO.marchSteps;
                    let step_size = (t_exit - t_enter) / f32(march_steps_actual);

                    for (var i: u32 = 0u; i < march_steps_actual; i = i + 1u) {
                        if (accumulated_alpha >= 0.99f) { break; }

                        let t = t_enter + (f32(i) + 0.5f) * step_size;
                        let current_pos = ray_origin + ray_direction * t;

                        let time_animated_offset = vec3<f32>(timeUBO.time * cloudParamsUBO.animationSpeed * 0.02f, 0.0f, timeUBO.time * cloudParamsUBO.animationSpeed * 0.01f);
                        let noise_val = sample3DNoiseTexture(current_pos + time_animated_offset, cloudParamsUBO.noiseScale);

                        if (noise_val > cloudParamsUBO.densityThreshold) {
                            let density_normalized = (noise_val - cloudParamsUBO.densityThreshold) / (1.0f - cloudParamsUBO.densityThreshold);
                            let actual_density = density_normalized * cloudParamsUBO.densityMultiplier;

                            let light_attenuation = exp(-actual_density * cloudParamsUBO.absorptionCoeff * step_size);

                            let sun_direction = normalize(lightUBO.position.xyz);
                            let light_intensity = max(0.0f, dot(sun_direction, ray_direction)) * lightUBO.brightness;

                            let current_cloud_base_color = vec3<f32>(cloudParamsUBO.baseColorR, cloudParamsUBO.baseColorG, cloudParamsUBO.baseColorB);
                            let cloud_color_lit = current_cloud_base_color * light_intensity * lightUBO.color;

                            let step_alpha = clamp(actual_density * cloudParamsUBO.scatteringCoeff * step_size, 0.0f, 1.0f);
                            accumulated_color += step_alpha * cloud_color_lit * light_attenuation * (1.0f - accumulated_alpha);
                            accumulated_alpha += step_alpha * (1.0f - accumulated_alpha);
                        }
                    }

                    let final_color = mix(base_sky_color, accumulated_color, accumulated_alpha);
                    return vec4<f32>(final_color, 1.0f);
                }

                fn DistributionGGX(N:vec3<f32>,H:vec3<f32>,roughness:f32)->f32{let a=roughness*roughness;let a2=a*a;let NdotH=max(dot(N,H),0.0f);let NdotH2=NdotH*NdotH;let nom=a2;var den=(NdotH2*(a2-1.0f)+1.0f);den=PI*den*den;return nom/max(den,0.0000001f);}
                fn GeometrySchlickGGX(NdotV:f32,roughness:f32)->f32{let r=(roughness+1.0f);let k=(r*r)/8.0f;let nom=NdotV;let den=NdotV*(1.0f-k)+k;return nom/max(den,0.0000001f);}
                fn GeometrySmith(N:vec3<f32>,V:vec3<f32>,L:vec3<f32>,roughness:f32)->f32{let NdotV=max(dot(N,V),0.0f);let NdotL=max(dot(N,L),0.0f);return GeometrySchlickGGX(NdotV,roughness)*GeometrySchlickGGX(NdotL,roughness);}
                fn FresnelSchlickPBR(cosTheta:f32,F0:vec3<f32>)->vec3<f32>{return F0+(vec3<f32>(1.0f)-F0)*pow(clamp(1.0f-cosTheta,0.0f,1.0f),5.0f);}
                fn calculateLighting(hit_pos:vec3<f32>,N:vec3<f32>,V:vec3<f32>,time:f32,albedo:vec3<f32>,metallic:f32,roughness:f32,base_reflectivity:f32,is_water_medium:u32,gid:vec2<u32>)->vec3<f32>{var Lo=vec3<f32>(0.0f);var ambient=albedo*0.02f;if(is_water_medium==1u){ambient=albedo*0.04f;}let F0=mix(vec3<f32>(base_reflectivity),albedo,metallic);let num_samples=max(1u,raytracerUBO.shadowSamples);let light_dir_center=normalize(lightUBO.position.xyz-hit_pos);let light_dist=distance(lightUBO.position.xyz,hit_pos);var light_basis_u=normalize(cross(light_dir_center,vec3<f32>(0.0,1.0,0.0)));if(length(light_basis_u)<0.1f){light_basis_u=normalize(cross(light_dir_center,vec3<f32>(1.0,0.0,0.0)));}let light_basis_v=cross(light_basis_u,light_dir_center);for(var s_idx:u32=0u;s_idx<num_samples;s_idx=s_idx+1u){let rand_u=rand_float(vec2<f32>(f32(gid.x),f32(gid.y)),time*1.3f+f32(s_idx)*7.7f);let rand_v=rand_float(vec2<f32>(f32(gid.y),f32(gid.x)),time*0.7f+f32(s_idx)*11.3f);let angle=rand_u*2.0f*PI;let radius_s=sqrt(rand_v);let offset_x=cos(angle)*radius_s*lightUBO.size;let offset_y=sin(angle)*radius_s*lightUBO.size;let perturbed_light_pos=lightUBO.position.xyz+light_basis_u*offset_x+light_basis_v*offset_y;let L=normalize(perturbed_light_pos-hit_pos);let shadow_ray_o=hit_pos+N*MIN_DIST;let occluder_d=raymarch(Ray(shadow_ray_o,L),time,raytracerUBO.warpStrength).distance;let shadow_f=select(0.0f,1.0f,occluder_d>=light_dist-MIN_DIST);if(shadow_f>0.0f){let H=normalize(V+L);let NdotL=max(dot(N,L),0.0f);let NdotV=max(dot(N,V),0.0f);let NdotH=max(dot(N,H),0.0f);let VdotH=max(dot(V,H),0.0f);let D=DistributionGGX(N,H,roughness);let G=GeometrySmith(N,V,L,roughness);let F=FresnelSchlickPBR(VdotH,F0);let num=D*G*F;let den=4.0f*NdotV*NdotL;let spec_brdf=num/max(den,0.0000001f);let kS=F;var kD=vec3<f32>(1.0f)-kS;kD*=(1.0f-metallic);let diff_brdf=kD*albedo/PI;let radiance=lightUBO.brightness*lightUBO.color;Lo+=(diff_brdf+spec_brdf)*radiance*NdotL*shadow_f;}}Lo/=f32(num_samples);return ambient+Lo;}
                fn snellsLaw(incident:vec3<f32>,normal:vec3<f32>,n1:f32,n2:f32)->vec3<f32>{let cosThetaI=dot(-incident,normal);let clamped_cos=clamp(cosThetaI,-1.0f,1.0f);let eta=n1/n2;let sinThetaT2=eta*eta*(1.0f-clamped_cos*clamped_cos);if(sinThetaT2>1.0f){return vec3<f32>(0.0f);}let cosThetaT=sqrt(1.0f-sinThetaT2);return eta*incident+(eta*clamped_cos-cosThetaT)*normal;}
                fn fresnelSchlick(cos_theta:f32,n1:f32,n2:f32)->f32{let R0=pow((n1-n2)/(n1+n2),2.0f);return R0+(1.0f-R0)*pow(1.0f-cos_theta,5.0f);}
                fn get_ior_and_normal(incident:vec3<f32>,normal:vec3<f32>,curr_ior:f32,obj_ior:f32)->array<f32,6>{var n1=curr_ior;var n2=obj_ior;var adj_norm=normal;var is_entering:f32=1.0f;if(dot(incident,normal)>0.0f){adj_norm=-normal;n1=obj_ior;n2=curr_ior;is_entering=0.0f;}return array<f32,6>(n1,n2,adj_norm.x,adj_norm.y,adj_norm.z,is_entering);}

                fn get_color_from_sub_hit(ray:Ray,time:f32,is_sub_water:u32,gid:vec2<u32>)->vec3<f32>{let hit=raymarch(ray,time,raytracerUBO.warpStrength);if(!hit.is_hit){return renderClouds(ray.origin, ray.direction, MAX_DIST, raytracerUBO.skyPreset).rgb;}else if(hit.object_id==0u){let alb=vec3<f32>(0.4,0.3,0.2);return calculateLighting(hit.hit_pos,hit.normal,-ray.direction,time,alb,0.0f,0.9f,0.04f,is_sub_water,gid);}else if(hit.object_id==1u){let alb=vec3<f32>(0.1,0.3,0.5);return calculateLighting(hit.hit_pos,hit.normal,-ray.direction,time,alb,0.0f,0.1f,0.04f,is_sub_water,gid);}else{let s=spheres[hit.sphere_idx];return calculateLighting(hit.hit_pos,hit.normal,-ray.direction,time,s.albedo_metallic.xyz,s.albedo_metallic.w,s.pbr_properties.x,s.pbr_properties.y,is_sub_water,gid);}}

                // Placeholder for Ray-Triangle Intersection (Moller-Trumbore)
                fn rayTriangleIntersect(ray: Ray, v0: vec3<f32>, v1: vec3<f32>, v2: vec3<f32>) -> f32 {
                    let edge1 = v1 - v0;
                    let edge2 = v2 - v0;
                    let h = cross(ray.direction, edge2);
                    let a = dot(edge1, h);

                    if (a > -EPSILON && a < EPSILON) { // Ray is parallel to triangle.
                        return -1.0;
                    }

                    let f = 1.0 / a;
                    let s = ray.origin - v0;
                    let u = f * dot(s, h);

                    if (u < 0.0 || u > 1.0) {
                        return -1.0;
                    }

                    let q = cross(s, edge1);
                    let v = f * dot(ray.direction, q);

                    if (v < 0.0 || u + v > 1.0) {
                        return -1.0;
                    }

                    // At this stage we can compute t to find out where the intersection point is on the line.
                    let t = f * dot(edge2, q);
                    if (t > EPSILON) { // Ray intersection
                        return t;
                    } else { // This means that there is a line intersection but not a ray intersection.
                        return -1.0;
                    }
                }

                // Mesh intersection logic
                fn intersectMesh(ray: Ray, mesh_instance_idx: u32, bounding_sphere_hit_dist: f32) -> HitInfo {
                    var closest_mesh_hit: HitInfo;
                    closest_mesh_hit.is_hit = false;
                    closest_mesh_hit.distance = bounding_sphere_hit_dist;
                    // object_id and sphere_idx will be set if a hit occurs, based on the placeholder sphere's original values.
                    // is_water will be false.

                    if (mesh_instance_idx >= raytracerUBO.numMeshInstances) {
                        return closest_mesh_hit; // Should not happen if logic is correct before calling
                    }

                    let mesh = meshInstances[mesh_instance_idx];

                    for (var i = 0u; i < mesh.num_triangles; i = i + 1u) {
                       let tri_data = triangleIndexData[mesh.index_offset + i]; // tri_data is a Triangle struct
                       let v0 = vertexData[mesh.vertex_offset + tri_data.i0];
                       let v1 = vertexData[mesh.vertex_offset + tri_data.i1];
                       let v2 = vertexData[mesh.vertex_offset + tri_data.i2];

                       let t = rayTriangleIntersect(ray, v0.position, v1.position, v2.position);
                       if (t > MIN_DIST && t < closest_mesh_hit.distance) {
                           closest_mesh_hit.is_hit = true;
                           closest_mesh_hit.distance = t;
                           closest_mesh_hit.hit_pos = ray.origin + ray.direction * t;
                           // Flat normal for now
                           closest_mesh_hit.normal = normalize(cross(v1.position - v0.position, v2.position - v0.position));
                           closest_mesh_hit.sphere_idx = mesh_instance_idx; // Store mesh_instance_idx here for material/shader logic
                           // Keep original object_id from sphere placeholder to use its materialType (3.0) for now
                           // closest_mesh_hit.object_id = ... ;
                           closest_mesh_hit.is_water = false;
                       }
                    }
                    return closest_mesh_hit;
                }


                fn traceRay(initial_ray: Ray, current_time: f32, global_id_xy: vec2<u32>) -> vec4<f32> {
                    var final_color = vec3<f32>(0.0f);
                    var current_ray = initial_ray;
                    var current_weight = vec3<f32>(1.0f);
                    var current_ior = 1.0f;
                    let water_ior = 1.33f;
                    var is_in_water_medium_trace: u32 = 0u;

                    for (var bounce_count: u32 = 0u; bounce_count < raytracerUBO.maxBounces; bounce_count = bounce_count + 1u) {
                        let hit_info = raymarch(current_ray, current_time, raytracerUBO.warpStrength);

                        if (!hit_info.is_hit) {
                            let cloud_result = renderClouds(current_ray.origin, current_ray.direction, MAX_DIST, raytracerUBO.skyPreset);
                            final_color += current_weight * cloud_result.rgb;
                            break;
                        }

                        var current_hit_info = hit_info; // Make a mutable copy
                        let sphere_material_type = spheres[current_hit_info.sphere_idx].pbr_properties.z;

                        if (sphere_material_type == 3.0f && raytracerUBO.numMeshInstances > 0u) { // materialType 3 indicates a rock placeholder
                            // pbr_properties.w for rock placeholders stores the meshInstanceIndex
                            let mesh_instance_idx = u32(spheres[current_hit_info.sphere_idx].pbr_properties.w);

                            if (mesh_instance_idx < raytracerUBO.numMeshInstances) {
                                let mesh_hit = intersectMesh(current_ray, mesh_instance_idx, current_hit_info.distance);
                                if (mesh_hit.is_hit) {
                                    current_hit_info = mesh_hit; // Update hit_info with mesh intersection details
                                    // The materialType (3.0f) is implicitly handled as sphere_material_type is already 3.0f.
                                    // current_hit_info.object_id from the original sphere hit is preserved.
                                    // current_hit_info.sphere_idx now holds mesh_instance_idx from intersectMesh.
                                } else {
                                    // Ray hit bounding sphere but missed the actual mesh. Treat as a sky hit.
                                    final_color += current_weight * renderClouds(current_ray.origin, current_ray.direction, MAX_DIST, raytracerUBO.skyPreset).rgb;
                                    break;
                                }
                            } else {
                                // Invalid mesh_instance_idx, this path should ideally not be hit if data is correct.
                                // Treat as if the ray missed this object and hit the sky.
                                final_color += current_weight * renderClouds(current_ray.origin, current_ray.direction, MAX_DIST, raytracerUBO.skyPreset).rgb;
                                break;
                            }
                        }

                        let N = current_hit_info.normal;
                        let hit_pos = current_hit_info.hit_pos; // Use current_hit_info
                        let V = -current_ray.direction;
                        var surface_color = vec3<f32>(0.0f);

                        is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);

                        if (current_hit_info.object_id == 0u) { // Terrain
                            let terrain_albedo = vec3<f32>(0.4f, 0.3f, 0.2f);
                            surface_color = calculateLighting(hit_pos, N, V, current_time, terrain_albedo, 0.0f, 0.9f, 0.04f, is_in_water_medium_trace, global_id_xy);
                            let noise_val = sample3DNoiseTexture(current_hit_info.hit_pos, 0.1f); // Use current_hit_info
                            surface_color.r += noise_val * 0.5f;
                            final_color += current_weight * surface_color;
                            break;
                        }
                        else if (current_hit_info.object_id == 1u) { // Water
                            let water_surface_albedo = vec3<f32>(0.1f, 0.3f, 0.5f);
                            let water_body_color_absorption = vec3<f32>(0.1f, 0.2f, 0.3f);
                            surface_color = calculateLighting(hit_pos, N, V, current_time, water_surface_albedo, 0.0f, 0.1f, 0.04f, is_in_water_medium_trace, global_id_xy);
                            let noise_val = sample3DNoiseTexture(current_hit_info.hit_pos, 0.05f); // Use current_hit_info
                            surface_color.g += noise_val * 0.3f;

                            let iors_info = get_ior_and_normal(current_ray.direction, N, current_ior, water_ior);
                            let n1 = iors_info[0]; let n2 = iors_info[1];
                            let adjusted_normal = vec3<f32>(iors_info[2], iors_info[3], iors_info[4]);

                            final_color += current_weight * surface_color;

                            let reflected_dir = reflect(current_ray.direction, adjusted_normal);
                            let reflected_ray = Ray(current_hit_info.hit_pos + reflected_dir * EPSILON, reflected_dir); // Use current_hit_info

                            let refracted_dir = snellsLaw(current_ray.direction, adjusted_normal, n1, n2);
                            let cos_theta_i = dot(-current_ray.direction, adjusted_normal);
                            let fresnel_reflectance = fresnelSchlick(cos_theta_i, n1, n2);

                            if (length(refracted_dir) > 0.001f) {
                                final_color += current_weight * fresnel_reflectance * get_color_from_sub_hit(reflected_ray, current_time, is_in_water_medium_trace, global_id_xy);
                                current_ray = Ray(current_hit_info.hit_pos + refracted_dir * EPSILON * -1.0f, refracted_dir); // Use current_hit_info
                                current_weight *= water_body_color_absorption * (1.0f - fresnel_reflectance);
                                current_ior = n2;
                                is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);
                            } else {
                                current_ray = reflected_ray;
                                final_color += current_weight * fresnel_reflectance * get_color_from_sub_hit(reflected_ray, current_time, is_in_water_medium_trace, global_id_xy);
                                current_weight *= water_surface_albedo;
                                break;
                            }
                        }
                        else { // Spheres or Rock Placeholders (current_hit_info.object_id >= 2u)
                            // Note: current_hit_info.sphere_idx is the original index from BVH if it was a direct sphere hit,
                            // or it's the mesh_instance_idx if it was a mesh hit.
                            let s = spheres[current_hit_info.sphere_idx]; // For materialType and initial properties
                            let material_type = u32(s.pbr_properties.z);

                            var albedo : vec3<f32>;
                            var metallic : f32;
                            var roughness : f32;
                            var base_reflectivity : f32;
                            var refractive_index_object : f32; // Only used if material_type is REFRACTIVE

                            if (material_type == 3u) { // Procedural Rock (materialType 3 from placeholder sphere)
                                albedo = vec3<f32>(0.45f, 0.42f, 0.4f);
                                metallic = 0.05f;
                                roughness = 0.85f;
                                base_reflectivity = 0.03f;
                                // Rock is opaque, so no refraction specific logic needed beyond this point for it.
                                surface_color = calculateLighting(hit_pos, N, V, current_time, albedo, metallic, roughness, base_reflectivity, is_in_water_medium_trace, global_id_xy);
                                final_color += current_weight * surface_color; // Apply lighting
                                break; // Rocks are opaque and don't reflect/refract further rays for now.
                            } else { // Regular Spheres
                                albedo = s.albedo_metallic.xyz;
                                metallic = s.albedo_metallic.w; // This is actually metallic for regular spheres
                                roughness = s.pbr_properties.x;
                                base_reflectivity = s.pbr_properties.y;
                                refractive_index_object = s.pbr_properties.w; // Actual IOR for transmissive spheres
                                surface_color = calculateLighting(hit_pos, N, V, current_time, albedo, metallic, roughness, base_reflectivity, is_in_water_medium_trace, global_id_xy);
                            }

                            let noise_val = sample3DNoiseTexture(current_hit_info.hit_pos, 0.2f); // Use current_hit_info
                            surface_color.r += noise_val * 0.5f;
                            final_color += current_weight * surface_color;

                            // Common reflection/refraction logic for non-rock spheres
                            if (material_type == MATERIAL_DIFFUSE) { // Already handled rock (material_type 3u)
                                break;
                            } else if (material_type == MATERIAL_REFLECTIVE) {
                                let reflected_dir = reflect(current_ray.direction, N);
                                current_ray = Ray(current_hit_info.hit_pos + reflected_dir * EPSILON, reflected_dir); // Use current_hit_info
                                current_weight *= albedo;
                            } else if (material_type == MATERIAL_REFRACTIVE) {
                                let iors_info = get_ior_and_normal(current_ray.direction, N, current_ior, refractive_index_object);
                                let n1 = iors_info[0]; let n2 = iors_info[1];
                                let adjusted_normal = vec3<f32>(iors_info[2], iors_info[3], iors_info[4]);

                                let cos_theta_i = dot(-current_ray.direction, adjusted_normal);
                                let fresnel_reflectance = fresnelSchlick(cos_theta_i, n1, n2);
                                let reflected_dir = reflect(current_ray.direction, adjusted_normal);
                                let reflected_ray_for_calc = Ray(current_hit_info.hit_pos + reflected_dir * EPSILON, reflected_dir); // Use current_hit_info

                                final_color += current_weight * fresnel_reflectance * get_color_from_sub_hit(reflected_ray_for_calc, current_time, is_in_water_medium_trace, global_id_xy);

                                let refracted_dir = snellsLaw(current_ray.direction, adjusted_normal, n1, n2);

                                if (length(refracted_dir) > 0.001f) {
                                    let refracted_ray_for_calc = Ray(current_hit_info.hit_pos + refracted_dir * EPSILON * -1.0f, refracted_dir); // Use current_hit_info
                                    let refracted_contrib_color = get_color_from_sub_hit(refracted_ray_for_calc, current_time, select(0u, 1u, n2 > 1.01f), global_id_xy);
                                    final_color += current_weight * (1.0f - fresnel_reflectance) * albedo * refracted_contrib_color;
                                    current_ior = n2;
                                    is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);
                                }
                                break;
                            }
                        }
                        if (max(max(current_weight.x, current_weight.y), current_weight.z) < 0.01f) {
                            break;
                        }
                    }
                    return vec4<f32>(final_color, 1.0f);
                }

                @compute @workgroup_size(8, 8)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let screen_width = cameraUBO.resolution.x;
                    let screen_height = cameraUBO.resolution.y;

                    if (global_id.x >= u32(screen_width) || global_id.y >= u32(screen_height)) {
                        return;
                    }

                    var final_accumulated_color = vec3<f32>(0.0f);
                    let frag_coord_xy = vec2<f32>(f32(global_id.x), f32(global_id.y));

                    for (var dof_idx: u32 = 0u; dof_idx < raytracerUBO.dofSamples; dof_idx = dof_idx + 1u) {
                        let rand_u_dof = rand_float(frag_coord_xy, timeUBO.time * 2.1f + f32(dof_idx) * 5.9f);
                        let rand_v_dof = rand_float(frag_coord_xy.yx, timeUBO.time * 1.7f + f32(dof_idx) * 9.1f);

                        let angle_dof = rand_u_dof * 2.0f * PI;
                        let radius_scale = sqrt(rand_v_dof);
                        let aperture_offset_x = cos(angle_dof) * radius_scale * raytracerUBO.apertureSize;
                        let aperture_offset_y = sin(angle_dof) * radius_scale * raytracerUBO.apertureSize;

                        let perturbed_origin = cameraUBO.position.xyz +
                                               cameraUBO.right.xyz * aperture_offset_x +
                                               cameraUBO.up.xyz * aperture_offset_y;

                        let ndc_x: f32 = (f32(global_id.x) / screen_width) * 2.0f - 1.0f;
                        let ndc_y: f32 = (1.0f - f32(global_id.y) / screen_height) * 2.0f - 1.0f;

                        let aspect_ratio = cameraUBO.aspect;
                        let fov_rad = cameraUBO.fovy;

                        let ray_x = ndc_x * aspect_ratio * tan(fov_rad / 2.0f);
                        let ray_y = ndc_y * tan(fov_rad / 2.0f);
                        let ray_z = -1.0f;

                        let ray_dir_camera_space = normalize(vec3<f32>(ray_x, ray_y, ray_z));

                        let ideal_ray_direction_world = normalize(
                            ray_dir_camera_space.x * cameraUBO.right.xyz +
                            ray_dir_camera_space.y * cameraUBO.up.xyz +
                            ray_dir_camera_space.z * cameraUBO.forward.xyz
                        );

                        let focal_point = cameraUBO.position.xyz + ideal_ray_direction_world * raytracerUBO.focalDistance;

                        let dof_ray_direction = normalize(focal_point - perturbed_origin);
                        let dof_ray = Ray(perturbed_origin, dof_ray_direction);

                        final_accumulated_color += traceRay(dof_ray, timeUBO.time, global_id.xy).xyz;
                    }

                    let final_color_per_pixel = final_accumulated_color / f32(raytracerUBO.dofSamples);

                    let previous_color_vec4 = textureLoad(inputTexture, vec2<i32>(global_id.xy), 0u);
                    let current_frame_f32 = f32(timeUBO.frame_count);
                    let blend_factor = 1.0f / (current_frame_f32 + 1.0f);
                    let new_accumulated_color = mix(previous_color_vec4.rgb, final_color_per_pixel, blend_factor);

                    textureStore(outputTexture, vec2<i32>(global_id.xy), vec4<f32>(new_accumulated_color, 1.0f));
                }
                \`;
                    this.shaderManager.wgslRender = \`
                // @group(0) @binding(0) var mainSampler: sampler;
                // @group(0) @binding(1) var mainTexture: texture_2d<f32>; // Samples output of compute shader (unfilterable-float type)

                var<private> uvs: array<vec2<f32>, 6> = array<vec2<f32>, 6>(
                    vec2<f32>(0.0f, 1.0f),
                    vec2<f32>(1.0f, 1.0f),
                    vec2<f32>(0.0f, 0.0f),

                    vec2<f32>(0.0f, 0.0f),
                    vec2<f32>(1.0f, 1.0f),
                    vec2<f32>(1.0f, 0.0f)
                );

                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) uv: vec2<f32>,
                };

                @vertex
                fn vert_main(@builtin(vertex_index) vertIndex: u32) -> VertexOutput {
                    let positions = array<vec2<f32>, 6>(
                    vec2<f32>(-1.0f, -1.0f),
                    vec2<f32>( 1.0f, -1.0f),
                    vec2<f32>(-1.0f,  1.0f),

                    vec2<f32>(-1.0f,  1.0f),
                    vec2<f32>( 1.0f, -1.0f),
                    vec2<f32>( 1.0f,  1.0f)
                    );

                    var output: VertexOutput;
                    output.position = vec4<f32>(positions[vertIndex], 0.0f, 1.0f);
                    output.uv = uvs[vertIndex];
                    return output;
                }

                @fragment
                fn frag_main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
                    return textureSample(mainTexture, mainSampler, uv);
                }
                \`;
                    this.shaderManager.wgslNoise3DCompute = \`
                // WGSL Compute Shader for generating 3D Value Noise

                // Simple hashing function for 3D unsigned integer coordinates.
                // Takes a 3D unsigned integer vector, permutes its components, and combines them
                // to produce a pseudo-random floating point value between 0.0 and 1.0.
                fn simple_hash_3d(p: vec3<u32>) -> f32 {
                    var n = p.x * 1u + p.y * 57u + p.z * 113u; // Combine components with arbitrary multipliers
                    n = (n << 13u) ^ n; // Bitwise operations to mix bits
                    n = (n * (n * n * 15731u + 789221u) + 1376312589u); // Further mixing with large prime numbers
                    return f32(n & 0x7fffffffu) / f32(0x7fffffff); // Convert to positive float and normalize to [0, 1)
                }

                // 3D Value Noise function.
                // Generates procedural noise by hashing the corners of a cube surrounding the sample point
                // and then performing trilinear interpolation between these hashed values.
                fn value_noise_3d(coord_normalized: vec3<f32>, scale: f32) -> f32 {
                    // Scale the normalized coordinate and find the integer (p) and fractional (f) parts.
                    let p = floor(coord_normalized * scale);
                    let f = fract(coord_normalized * scale);
                    let i = vec3<u32>(p); // Integer coordinates of the cube's origin corner.

                    // Interpolation weights (smoothstep for smoother results than linear interpolation).
                    // u = f * f * (3.0 - 2.0 * f) is the smoothstep function: 3f^2 - 2f^3
                    let u = f * f * (3.0f - 2.0f * f);

                    // Hash the 8 corners of the cube.
                    let n000 = simple_hash_3d(i + vec3<u32>(0u, 0u, 0u));
                    let n100 = simple_hash_3d(i + vec3<u32>(1u, 0u, 0u));
                    let n010 = simple_hash_3d(i + vec3<u32>(0u, 1u, 0u));
                    let n110 = simple_hash_3d(i + vec3<u32>(1u, 1u, 0u));
                    let n001 = simple_hash_3d(i + vec3<u32>(0u, 0u, 1u));
                    let n101 = simple_hash_3d(i + vec3<u32>(1u, 0u, 1u));
                    let n011 = simple_hash_3d(i + vec3<u32>(0u, 1u, 1u));
                    let n111 = simple_hash_3d(i + vec3<u32>(1u, 1u, 1u));

                    // Trilinear interpolation of hashed corner values.
                    // Interpolate along x-axis for each of the 4 "front" and "back" edges.
                    let n00 = mix(n000, n100, u.x);
                    let n01 = mix(n001, n101, u.x);
                    let n10 = mix(n010, n110, u.x);
                    let n11 = mix(n011, n111, u.x);

                    // Interpolate along y-axis for the results of the x-interpolations.
                    let n0 = mix(n00, n10, u.y);
                    let n1 = mix(n01, n11, u.y);

                    // Final interpolation along z-axis.
                    return mix(n0, n1, u.z);
                }

                // Output 3D texture for storing noise values (single float channel).
                // This texture will be written to by the compute shader.
                @group(0) @binding(0) var output_noise_texture: texture_storage_3d<r32float, write>;

                // Constant defining the scale of the noise. Larger values result in higher frequency noise.
                const NOISE_SCALE: f32 = 5.0f;

                // Main compute entry point.
                // Invoked for each workgroup. global_invocation_id (id) specifies the voxel coordinates.
                @compute @workgroup_size(4, 4, 4) // Workgroup size: 4x4x4 = 64 invocations per workgroup.
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    // Get the dimensions of the output texture.
                    let texture_dims_vec = textureDimensions(output_noise_texture);
                    let texture_dims = vec3<f32>(f32(texture_dims_vec.x), f32(texture_dims_vec.y), f32(texture_dims_vec.z));

                    // Prevent out-of-bounds writes if dispatch size doesn't perfectly match texture dimensions.
                    if (id.x >= u32(texture_dims.x) || id.y >= u32(texture_dims.y) || id.z >= u32(texture_dims.z)) {
                        return;
                    }

                    // Normalize coordinates to the [0, 1] range for the noise function.
                    // Adding 0.5f to sample at the center of the voxel.
                    let normalized_coord = vec3<f32>(
                        (f32(id.x) + 0.5f) / texture_dims.x,
                        (f32(id.y) + 0.5f) / texture_dims.y,
                        (f32(id.z) + 0.5f) / texture_dims.z
                    );

                    // Calculate the noise value using the 3D value noise function.
                    let noise_val = value_noise_3d(normalized_coord, NOISE_SCALE);

                    // Store the calculated noise value (0.0 to 1.0) in the red channel of the output texture.
                    // For r32float, only the first component (r) is used.
                    textureStore(output_noise_texture, id, vec4<f32>(noise_val, 0.0, 0.0, 1.0));
                }
                \`;
                    console.log("ShaderManager initialized and shader code moved.");
                    this.shaderManager.wgslCompute = \`
                // WGSL Compute Shader for Raytracing
                // Main raytracing logic, including material evaluation, lighting, and BVH traversal.

                // Perlin Noise (existing, used by domainWarp and procedural elements)
                var<private> perm: array<u32, 512> = array<u32, 512>(/* ... Perlin table ... */);
                var<private> grad3: array<vec3<f32>, 12> = array<vec3<f32>, 12>(/* ... Perlin gradients ... */);
                fn mod289(x: vec3<f32>) -> vec3<f32> { return x - floor(x / 289.0f) * 289.0f; }
                fn mod289_f(x: f32) -> f32 { return x - floor(x / 289.0f) * 289.0f; }
                fn hash_grad(x: u32, y: u32, z: u32) -> u32 { return perm[ (perm[ (perm[x % 256u] + y) % 256u ] + z) % 256u ]; }
                fn snoise(p: vec3<f32>) -> f32 { /* ... Classic Perlin snoise implementation ... */
                    let F3 = 1.0f/3.0f; let G3 = 1.0f/6.0f;
                    let s = (p.x + p.y + p.z) * F3; let i_float = floor(p + vec3<f32>(s)); let t = (i_float.x + i_float.y + i_float.z) * G3;
                    let x0 = p - i_float + vec3<f32>(t); let g = step(x0.xyz, x0.yzx); let l = 1.0f - g;
                    let i1 = min(g.xyz, l.yzx); let i2 = max(g.xyz, l.yzx);
                    let i_u32 = vec3<u32>(i_float); let ii = i_u32 % 256u;
                    let x1 = x0 - i1 + G3; let x2 = x0 - i2 + 2.0f * G3; let x3 = x0 - 1.0f + 3.0f * G3;
                    let gi0 = hash_grad(ii.x, ii.y, ii.z); let gi1 = hash_grad(ii.x + u32(i1.x), ii.y + u32(i1.y), ii.z + u32(i1.z));
                    let gi2 = hash_grad(ii.x + u32(i2.x), ii.y + u32(i2.y), ii.z + u32(i2.z)); let gi3 = hash_grad(ii.x + 1u, ii.y + 1u, ii.z + 1u);
                    var sum: f32 = 0.0f;
                    var t0 = 0.5f - dot(x0, x0); if (t0 >= 0.0f) { sum += pow(t0, 4.0f) * dot(grad3[gi0 % 12u], x0); }
                    var t1 = 0.5f - dot(x1, x1); if (t1 >= 0.0f) { sum += pow(t1, 4.0f) * dot(grad3[gi1 % 12u], x1); }
                    var t2 = 0.5f - dot(x2, x2); if (t2 >= 0.0f) { sum += pow(t2, 4.0f) * dot(grad3[gi2 % 12u], x2); }
                    var t3 = 0.5f - dot(x3, x3); if (t3 >= 0.0f) { sum += pow(t3, 4.0f) * dot(grad3[gi3 % 12u], x3); }
                    return 32.0f * sum;
                }
                fn rand_float(co: vec2<f32>, seed: f32) -> f32 { return fract(sin(dot(co.xy + vec3<f32>(seed).xy, vec2<f32>(12.9898f, 78.233f))) * 43758.5453f); }
                fn fBm(p: vec3<f32>) -> f32 { var t:f32=0.0; var f:f32=1.0; var a:f32=0.5; for(var i:u32=0u;i<8u;i=i+1u){t+=snoise(p*f)*a;f*=2.0;a*=0.5;} return t;}

                struct CameraUniform{position:vec3<f32>,_pad0:f32,forward:vec3<f32>,_pad1:f32,right:vec3<f32>,_pad2:f32,up:vec3<f32>,_pad3:f32,resolution:vec2<f32>,aspect:f32,fovy:f32,near:f32,far:f32,_pad4:vec2<f32>,};
                struct LightUniform{position:vec3<f32>,brightness:f32,size:f32,_pad0:vec3<f32>,color:vec3<f32>,_pad1:f32,};
                struct Sphere{position_radius:vec4<f32>,albedo_metallic:vec4<f32>,pbr_properties:vec4<f32>,};
                struct BvhNode{minBounds:vec3<f32>,isLeaf:u32,maxBounds:vec3<f32>,primitiveCount:u32,leftChildOrFirstPrimitiveIndex:u32,_pad0:u32,_pad1:u32,_pad2:u32,};
                struct WaterParams{strength:f32,frequency:f32,speed:f32,_pad0:f32,};
                struct TerrainParams{heightScale:f32,frequency:f32,_pad0:f32,_pad1:f32,};
                struct TimeUniform{time:f32,frame_count:u32,_pad0:vec2<f32>,};
                struct RaytracerParams{
                    maxBounces:u32,maxRaymarchSteps:u32,shadowSamples:u32,dofSamples:u32, // 16 bytes
                    numBVHNodes:u32,numPrimitives:u32,skyPreset:u32,numMeshInstances:u32, // 16 bytes
                    warpStrength:f32,focalDistance:f32,apertureSize:f32,_pad1:f32, // 16 bytes
                };
                struct Ray{origin:vec3<f32>,direction:vec3<f32>,};
                struct HitInfo{hit_pos:vec3<f32>,normal:vec3<f32>,distance:f32,is_hit:bool,object_id:u32,sphere_idx:u32,is_water:bool,};

                struct Vertex { position: vec3<f32>, normal: vec3<f32>, };
                struct Triangle { i0: u32, i1: u32, i2: u32, };
                struct MeshInstance { vertex_offset: u32, index_offset: u32, num_triangles: u32, material_id: u32, };

                struct CloudParamsUBO {
                    layerMinY: f32, layerMaxY: f32, noiseScale: f32, densityThreshold: f32,
                    densityMultiplier: f32, marchSteps: u32, scatteringCoeff: f32, absorptionCoeff: f32,
                    baseColorR: f32, baseColorG: f32, baseColorB: f32, animationSpeed: f32,
                };

                const MATERIAL_DIFFUSE:u32=0u;const MATERIAL_REFLECTIVE:u32=1u;const MATERIAL_REFRACTIVE:u32=2u;
                const MIN_DIST:f32=0.0001f;const MAX_DIST:f32=1000.0f;const EPSILON:f32=0.001f;const STACK_SIZE:u32=64u;const PI:f32=3.14159265359f;

                @group(0) @binding(0) var<uniform> cameraUBO: CameraUniform;
                @group(0) @binding(1) var<uniform> lightUBO: LightUniform;
                @group(0) @binding(2) var<uniform> raytracerUBO: RaytracerParams;
                @group(0) @binding(3) var<uniform> timeUBO: TimeUniform;
                @group(0) @binding(4) var<uniform> waterUBO: WaterParams;
                @group(0) @binding(5) var<uniform> terrainUBO: TerrainParams;
                @group(0) @binding(6) var outputTexture: texture_storage_2d<rgba32float, write>;
                @group(0) @binding(7) var inputTexture: texture_2d<f32>;
                @group(0) @binding(8) var noiseSampler: sampler;
                @group(0) @binding(9) var noiseTexture3D: texture_3d<f32>;
                @group(0) @binding(10) var<uniform> cloudParamsUBO: CloudParamsUBO;

                @group(1) @binding(0) var<storage, read> spheres: array<Sphere>;
                @group(1) @binding(1) var<storage, read> bvhNodes: array<BvhNode>;
                @group(1) @binding(2) var<storage, read> primitiveIndices: array<u32>;
                @group(1) @binding(3) var<storage, read> meshInstances: array<MeshInstance>;
                @group(1) @binding(4) var<storage, read> vertexData: array<Vertex>;
                @group(1) @binding(5) var<storage, read> triangleIndexData: array<Triangle>;

                fn sample3DNoiseTexture(world_pos: vec3<f32>, noise_texture_scale: f32) -> f32 {
                    let scaled_pos = world_pos * noise_texture_scale;
                    return textureSampleLevel(noiseTexture3D, noiseSampler, scaled_pos, 0.0f).r;
                }

                fn domainWarp(p:vec3<f32>,time:f32,strength:f32)->vec3<f32>{if(strength==0.0f){return p;}let offset_factor=vec3<f32>(snoise(p*0.5f+time*0.1f+vec3<f32>(10.0,20.0,30.0)),snoise(p*0.7f-time*0.2f+vec3<f32>(40.0,50.0,60.0)),snoise(p*0.9f+time*0.3f+vec3<f32>(70.0,80.0,90.0)));return p+offset_factor*strength;}
                fn terrainHeight(x:f32,z:f32,time:f32)->f32{if(terrainUBO.heightScale==0.0f){return -100000.0f;}let p_large=vec3<f32>(x,z,time*0.01f)*0.05f;let large_noise=fBm(p_large);let p_detail=vec3<f32>(x,z,time*0.05f)*terrainUBO.frequency;let detail_noise=fBm(p_detail);let center_dist=distance(vec2<f32>(x,z),vec2<f32>(0.0,0.0));let island_factor=smoothstep(150.0f,0.0f,center_dist);let base_h=(0.5f+0.5f*large_noise*0.6f)+(0.5f+0.5f*detail_noise*0.4f);let scaled_h=(base_h/2.0f)*terrainUBO.heightScale;return max(-2.0f,scaled_h*island_factor);}
                fn calculateWaveHeight(x:f32,z:f32,time:f32)->f32{var h:f32=0.0f;let freq=waterUBO.frequency;let str=waterUBO.strength;h+=sin(x*freq+time*waterUBO.speed)*str*0.7f;h+=cos(z*freq*1.5f+time*waterUBO.speed*0.8f)*str*0.5f;h+=sin((x+z)*freq*0.8f+time*waterUBO.speed*1.2f)*str*0.3f;return h;}
                fn sdWaterPlane(p:vec3<f32>,time:f32,warp_strength:f32)->f32{let warped_p=domainWarp(p,time*0.5f,warp_strength);return warped_p.y-calculateWaveHeight(warped_p.x,warped_p.z,time);}
                fn sdSphere(p:vec3<f32>,s:Sphere,warp_strength:f32)->f32{let warped_center=domainWarp(s.position_radius.xyz,timeUBO.time*0.5f,warp_strength);return distance(p,warped_center)-s.position_radius.w;}
                fn intersect_aabb(ro:vec3<f32>,inv_dir:vec3<f32>,min_b:vec3<f32>,max_b:vec3<f32>)->f32{let t1=(min_b-ro)*inv_dir;let t2=(max_b-ro)*inv_dir;let t_min=min(t1,t2);let t_max=max(t1,t2);let te=max(max(t_min.x,t_min.y),t_min.z);let tx=min(min(t_max.x,t_max.y),t_max.z);if(te>tx||tx<0.0f){return -1.0f;}return max(0.0f,te);}
                fn bvh_scene_sdf_spheres(ro:vec3<f32>,rd:vec3<f32>,time:f32,warp_str:f32,closest_d:ptr<function,f32>,closest_idx:ptr<function,u32>){if(raytracerUBO.numPrimitives==0u||raytracerUBO.numBVHNodes==0u){return;}var inv_dir=1.0f/rd;var stack:array<u32,STACK_SIZE>;var stack_ptr:u32=0u;var curr_node_idx=0u;for(var iter:u32=0u;iter<1024u;iter=iter+1u){if(stack_ptr>=STACK_SIZE||curr_node_idx>=raytracerUBO.numBVHNodes){break;}let node=bvhNodes[curr_node_idx];let t=intersect_aabb(ro,inv_dir,node.minBounds,node.maxBounds);if(t==-1.0f||t>*closest_d){if(stack_ptr==0u){break;}stack_ptr=stack_ptr-1u;curr_node_idx=stack[stack_ptr];continue;}if(node.isLeaf==1u){for(var i:u32=0u;i<node.primitiveCount;i=i+1u){let sph_idx=primitiveIndices[node.leftChildOrFirstPrimitiveIndex+i];if(sph_idx>=raytracerUBO.numPrimitives){continue;}let s=spheres[sph_idx];let d=sdSphere(ro,s,warp_str);if(d<*closest_d){*closest_d=d;*closest_idx=sph_idx;}}if(stack_ptr==0u){break;}stack_ptr=stack_ptr-1u;curr_node_idx=stack[stack_ptr];}else{let left_child=node.leftChildOrFirstPrimitiveIndex;let right_child=node.leftChildOrFirstPrimitiveIndex+1u;if(left_child>=raytracerUBO.numBVHNodes||right_child>=raytracerUBO.numBVHNodes){if(stack_ptr==0u){break;}stack_ptr=stack_ptr-1u;curr_node_idx=stack[stack_ptr];continue;}let t_l=intersect_aabb(ro,inv_dir,bvhNodes[left_child].minBounds,bvhNodes[left_child].maxBounds);let t_r=intersect_aabb(ro,inv_dir,bvhNodes[right_child].minBounds,bvhNodes[right_child].maxBounds);if(t_l!=-1.0f&&t_r!=-1.0f){if(t_l<t_r){stack[stack_ptr]=right_child;stack_ptr=stack_ptr+1u;curr_node_idx=left_child;}else{stack[stack_ptr]=left_child;stack_ptr=stack_ptr+1u;curr_node_idx=right_child;}}else if(t_l!=-1.0f){curr_node_idx=left_child;}else if(t_r!=-1.0f){curr_node_idx=right_child;}else{if(stack_ptr==0u){break;}stack_ptr=stack_ptr-1u;curr_node_idx=stack[stack_ptr];}}}}
                fn sceneSDF(p:vec3<f32>,time:f32,warp_str:f32,obj_id:ptr<function,u32>)->f32{var min_d:f32=MAX_DIST;*obj_id=999u;let terrain_d=p.y-terrainHeight(p.x,p.z,time);if(terrain_d<min_d){min_d=terrain_d;*obj_id=0u;}let water_d=sdWaterPlane(p,time,warp_str);if(water_d<min_d){min_d=water_d;*obj_id=1u;}var closest_sph_d=MAX_DIST;var closest_sph_idx:u32=0u;bvh_scene_sdf_spheres(p,vec3<f32>(0.0f),time,warp_str,&closest_sph_d,&closest_sph_idx);if(closest_sph_d<min_d){min_d=closest_sph_d;*obj_id=closest_sph_idx+2u;}return min_d;}
                fn estimateNormal(p:vec3<f32>,time:f32,warp_str:f32,obj_id_hint:u32)->vec3<f32>{var id_dummy:u32=0u;let gx=sceneSDF(p+vec3<f32>(EPSILON,0.0,0.0),time,warp_str,&id_dummy)-sceneSDF(p-vec3<f32>(EPSILON,0.0,0.0),time,warp_str,&id_dummy);let gy=sceneSDF(p+vec3<f32>(0.0,EPSILON,0.0),time,warp_str,&id_dummy)-sceneSDF(p-vec3<f32>(0.0,EPSILON,0.0),time,warp_str,&id_dummy);let gz=sceneSDF(p+vec3<f32>(0.0,0.0,EPSILON),time,warp_str,&id_dummy)-sceneSDF(p-vec3<f32>(0.0,0.0,EPSILON),time,warp_str,&id_dummy);return normalize(vec3<f32>(gx,gy,gz));}
                fn calculateWaterNormal(p:vec3<f32>,time:f32,warp_str:f32)->vec3<f32>{let wp=domainWarp(p,time*0.5f,warp_str);let x=wp.x;let z=wp.z;let hb=calculateWaveHeight(x,z,time);let eps=0.001f;let hx=calculateWaveHeight(x+eps,z,time);let hz=calculateWaveHeight(x,z+eps,time);return normalize(vec3<f32>(-(hx-hb)/eps,1.0f,-(hz-hb)/eps));}
                fn calculateTerrainNormal(p:vec3<f32>,time:f32,warp_str:f32)->vec3<f32>{let wp=domainWarp(p,time*0.5f,warp_str);let x=wp.x;let z=wp.z;let hb=terrainHeight(x,z,time);let eps=0.001f;let hx=terrainHeight(x+eps,z,time);let hz=terrainHeight(x,z+eps,time);return normalize(vec3<f32>(-(hx-hb)/eps,1.0f,-(hz-hb)/eps));}
                fn raymarch(ray:Ray,time:f32,warp_str:f32)->HitInfo{var hi:HitInfo;hi.is_hit=false;hi.distance=MAX_DIST;hi.sphere_idx=0u;hi.is_water=false;var total_dist:f32=0.0f;var curr_obj_id:u32=999u;for(var i:u32=0u;i<raytracerUBO.maxRaymarchSteps;i=i+1u){let cp=ray.origin+ray.direction*total_dist;let d=sceneSDF(cp,time,warp_str,&curr_obj_id);if(d<MIN_DIST){hi.is_hit=true;hi.hit_pos=cp;hi.distance=total_dist;hi.object_id=curr_obj_id;if(curr_obj_id==1u){hi.normal=calculateWaterNormal(cp,time,warp_str);hi.is_water=true;}else if(curr_obj_id==0u){hi.normal=calculateTerrainNormal(cp,time,warp_str);hi.is_water=false;}else{hi.sphere_idx=curr_obj_id-2u;hi.normal=estimateNormal(cp,time,warp_str,curr_obj_id);hi.is_water=false;}break;}total_dist+=d;if(total_dist>=MAX_DIST){break;}}return hi;}

                fn getSkyColor(rd:vec3<f32>,sky_preset:u32)->vec3<f32>{let sun_dir=normalize(lightUBO.position.xyz);let sun_dot=dot(rd,sun_dir);let sun_i=smoothstep(0.99f,1.0f,sun_dot);let sun_c=lightUBO.color*sun_i*lightUBO.brightness;var sky_top:vec3<f32>;var sky_hor:vec3<f32>;if(sky_preset==0u){sky_top=vec3<f32>(0.5,0.7,1.0);sky_hor=vec3<f32>(0.7,0.8,0.9);}else{sky_top=vec3<f32>(0.6,0.7,0.85);sky_hor=vec3<f32>(1.0,0.8,0.6);}let yf=max(0.0f,rd.y);let grad_c=mix(sky_hor,sky_top,yf);return grad_c+sun_c;}

                fn renderClouds(ray_origin: vec3<f32>, ray_direction: vec3<f32>, t_max_sky: f32, sky_preset_val: u32) -> vec4<f32> {
                    let base_sky_color = getSkyColor(ray_direction, sky_preset_val);
                    var accumulated_color = vec3<f32>(0.0f);
                    var accumulated_alpha = 0.0f;

                    var t_min_cloud_layer = (cloudParamsUBO.layerMinY - ray_origin.y) / ray_direction.y;
                    var t_max_cloud_layer = (cloudParamsUBO.layerMaxY - ray_origin.y) / ray_direction.y;

                    if (ray_direction.y == 0.0f) {
                        if (ray_origin.y < cloudParamsUBO.layerMinY || ray_origin.y > cloudParamsUBO.layerMaxY) {
                            return vec4<f32>(base_sky_color, 1.0f);
                        }
                        t_min_cloud_layer = 0.0f;
                        t_max_cloud_layer = t_max_sky;
                    }

                    if (t_min_cloud_layer > t_max_cloud_layer) {
                        let temp = t_min_cloud_layer;
                        t_min_cloud_layer = t_max_cloud_layer;
                        t_max_cloud_layer = temp;
                    }

                    let t_enter = max(0.0f, t_min_cloud_layer);
                    let t_exit = min(t_max_sky, t_max_cloud_layer);

                    if (t_enter >= t_exit || t_exit < 0.0f) {
                        return vec4<f32>(base_sky_color, 1.0f);
                    }

                    let march_steps_actual = cloudParamsUBO.marchSteps;
                    let step_size = (t_exit - t_enter) / f32(march_steps_actual);

                    for (var i: u32 = 0u; i < march_steps_actual; i = i + 1u) {
                        if (accumulated_alpha >= 0.99f) { break; }

                        let t = t_enter + (f32(i) + 0.5f) * step_size;
                        let current_pos = ray_origin + ray_direction * t;

                        let time_animated_offset = vec3<f32>(timeUBO.time * cloudParamsUBO.animationSpeed * 0.02f, 0.0f, timeUBO.time * cloudParamsUBO.animationSpeed * 0.01f);
                        let noise_val = sample3DNoiseTexture(current_pos + time_animated_offset, cloudParamsUBO.noiseScale);

                        if (noise_val > cloudParamsUBO.densityThreshold) {
                            let density_normalized = (noise_val - cloudParamsUBO.densityThreshold) / (1.0f - cloudParamsUBO.densityThreshold);
                            let actual_density = density_normalized * cloudParamsUBO.densityMultiplier;

                            let light_attenuation = exp(-actual_density * cloudParamsUBO.absorptionCoeff * step_size);

                            let sun_direction = normalize(lightUBO.position.xyz);
                            let light_intensity = max(0.0f, dot(sun_direction, ray_direction)) * lightUBO.brightness;

                            let current_cloud_base_color = vec3<f32>(cloudParamsUBO.baseColorR, cloudParamsUBO.baseColorG, cloudParamsUBO.baseColorB);
                            let cloud_color_lit = current_cloud_base_color * light_intensity * lightUBO.color;

                            let step_alpha = clamp(actual_density * cloudParamsUBO.scatteringCoeff * step_size, 0.0f, 1.0f);
                            accumulated_color += step_alpha * cloud_color_lit * light_attenuation * (1.0f - accumulated_alpha);
                            accumulated_alpha += step_alpha * (1.0f - accumulated_alpha);
                        }
                    }

                    let final_color = mix(base_sky_color, accumulated_color, accumulated_alpha);
                    return vec4<f32>(final_color, 1.0f);
                }

                fn DistributionGGX(N:vec3<f32>,H:vec3<f32>,roughness:f32)->f32{let a=roughness*roughness;let a2=a*a;let NdotH=max(dot(N,H),0.0f);let NdotH2=NdotH*NdotH;let nom=a2;var den=(NdotH2*(a2-1.0f)+1.0f);den=PI*den*den;return nom/max(den,0.0000001f);}
                fn GeometrySchlickGGX(NdotV:f32,roughness:f32)->f32{let r=(roughness+1.0f);let k=(r*r)/8.0f;let nom=NdotV;let den=NdotV*(1.0f-k)+k;return nom/max(den,0.0000001f);}
                fn GeometrySmith(N:vec3<f32>,V:vec3<f32>,L:vec3<f32>,roughness:f32)->f32{let NdotV=max(dot(N,V),0.0f);let NdotL=max(dot(N,L),0.0f);return GeometrySchlickGGX(NdotV,roughness)*GeometrySchlickGGX(NdotL,roughness);}
                fn FresnelSchlickPBR(cosTheta:f32,F0:vec3<f32>)->vec3<f32>{return F0+(vec3<f32>(1.0f)-F0)*pow(clamp(1.0f-cosTheta,0.0f,1.0f),5.0f);}
                fn calculateLighting(hit_pos:vec3<f32>,N:vec3<f32>,V:vec3<f32>,time:f32,albedo:vec3<f32>,metallic:f32,roughness:f32,base_reflectivity:f32,is_water_medium:u32,gid:vec2<u32>)->vec3<f32>{var Lo=vec3<f32>(0.0f);var ambient=albedo*0.02f;if(is_water_medium==1u){ambient=albedo*0.04f;}let F0=mix(vec3<f32>(base_reflectivity),albedo,metallic);let num_samples=max(1u,raytracerUBO.shadowSamples);let light_dir_center=normalize(lightUBO.position.xyz-hit_pos);let light_dist=distance(lightUBO.position.xyz,hit_pos);var light_basis_u=normalize(cross(light_dir_center,vec3<f32>(0.0,1.0,0.0)));if(length(light_basis_u)<0.1f){light_basis_u=normalize(cross(light_dir_center,vec3<f32>(1.0,0.0,0.0)));}let light_basis_v=cross(light_basis_u,light_dir_center);for(var s_idx:u32=0u;s_idx<num_samples;s_idx=s_idx+1u){let rand_u=rand_float(vec2<f32>(f32(gid.x),f32(gid.y)),time*1.3f+f32(s_idx)*7.7f);let rand_v=rand_float(vec2<f32>(f32(gid.y),f32(gid.x)),time*0.7f+f32(s_idx)*11.3f);let angle=rand_u*2.0f*PI;let radius_s=sqrt(rand_v);let offset_x=cos(angle)*radius_s*lightUBO.size;let offset_y=sin(angle)*radius_s*lightUBO.size;let perturbed_light_pos=lightUBO.position.xyz+light_basis_u*offset_x+light_basis_v*offset_y;let L=normalize(perturbed_light_pos-hit_pos);let shadow_ray_o=hit_pos+N*MIN_DIST;let occluder_d=raymarch(Ray(shadow_ray_o,L),time,raytracerUBO.warpStrength).distance;let shadow_f=select(0.0f,1.0f,occluder_d>=light_dist-MIN_DIST);if(shadow_f>0.0f){let H=normalize(V+L);let NdotL=max(dot(N,L),0.0f);let NdotV=max(dot(N,V),0.0f);let NdotH=max(dot(N,H),0.0f);let VdotH=max(dot(V,H),0.0f);let D=DistributionGGX(N,H,roughness);let G=GeometrySmith(N,V,L,roughness);let F=FresnelSchlickPBR(VdotH,F0);let num=D*G*F;let den=4.0f*NdotV*NdotL;let spec_brdf=num/max(den,0.0000001f);let kS=F;var kD=vec3<f32>(1.0f)-kS;kD*=(1.0f-metallic);let diff_brdf=kD*albedo/PI;let radiance=lightUBO.brightness*lightUBO.color;Lo+=(diff_brdf+spec_brdf)*radiance*NdotL*shadow_f;}}Lo/=f32(num_samples);return ambient+Lo;}
                fn snellsLaw(incident:vec3<f32>,normal:vec3<f32>,n1:f32,n2:f32)->vec3<f32>{let cosThetaI=dot(-incident,normal);let clamped_cos=clamp(cosThetaI,-1.0f,1.0f);let eta=n1/n2;let sinThetaT2=eta*eta*(1.0f-clamped_cos*clamped_cos);if(sinThetaT2>1.0f){return vec3<f32>(0.0f);}let cosThetaT=sqrt(1.0f-sinThetaT2);return eta*incident+(eta*clamped_cos-cosThetaT)*normal;}
                fn fresnelSchlick(cos_theta:f32,n1:f32,n2:f32)->f32{let R0=pow((n1-n2)/(n1+n2),2.0f);return R0+(1.0f-R0)*pow(1.0f-cos_theta,5.0f);}
                fn get_ior_and_normal(incident:vec3<f32>,normal:vec3<f32>,curr_ior:f32,obj_ior:f32)->array<f32,6>{var n1=curr_ior;var n2=obj_ior;var adj_norm=normal;var is_entering:f32=1.0f;if(dot(incident,normal)>0.0f){adj_norm=-normal;n1=obj_ior;n2=curr_ior;is_entering=0.0f;}return array<f32,6>(n1,n2,adj_norm.x,adj_norm.y,adj_norm.z,is_entering);}

                fn get_color_from_sub_hit(ray:Ray,time:f32,is_sub_water:u32,gid:vec2<u32>)->vec3<f32>{let hit=raymarch(ray,time,raytracerUBO.warpStrength);if(!hit.is_hit){return renderClouds(ray.origin, ray.direction, MAX_DIST, raytracerUBO.skyPreset).rgb;}else if(hit.object_id==0u){let alb=vec3<f32>(0.4,0.3,0.2);return calculateLighting(hit.hit_pos,hit.normal,-ray.direction,time,alb,0.0f,0.9f,0.04f,is_sub_water,gid);}else if(hit.object_id==1u){let alb=vec3<f32>(0.1,0.3,0.5);return calculateLighting(hit.hit_pos,hit.normal,-ray.direction,time,alb,0.0f,0.1f,0.04f,is_sub_water,gid);}else{let s=spheres[hit.sphere_idx];return calculateLighting(hit.hit_pos,hit.normal,-ray.direction,time,s.albedo_metallic.xyz,s.albedo_metallic.w,s.pbr_properties.x,s.pbr_properties.y,is_sub_water,gid);}}

                // Ray-Triangle Intersection (Moller-Trumbore)
                fn rayTriangleIntersect(ray: Ray, v0_pos: vec3<f32>, v1_pos: vec3<f32>, v2_pos: vec3<f32>) -> f32 {
                    let edge1 = v1_pos - v0_pos;
                    let edge2 = v2_pos - v0_pos;
                    let h = cross(ray.direction, edge2);
                    let a = dot(edge1, h);

                    if (a > -EPSILON && a < EPSILON) { // Ray is parallel to triangle.
                        return -1.0;
                    }

                    let f = 1.0 / a;
                    let s_vec = ray.origin - v0_pos;
                    let u = f * dot(s_vec, h);

                    if (u < 0.0 || u > 1.0) {
                        return -1.0;
                    }

                    let q = cross(s_vec, edge1);
                    let v = f * dot(ray.direction, q);

                    if (v < 0.0 || u + v > 1.0) {
                        return -1.0;
                    }

                    let t = f * dot(edge2, q);
                    if (t > EPSILON) { // Ray intersection
                        return t;
                    } else {
                        return -1.0;
                    }
                }

                // Mesh intersection logic
                fn intersectMesh(ray: Ray, mesh_instance_idx: u32, current_closest_dist: f32) -> HitInfo {
                    var mesh_hit_info: HitInfo;
                    mesh_hit_info.is_hit = false;
                    mesh_hit_info.distance = current_closest_dist;

                    if (mesh_instance_idx >= raytracerUBO.numMeshInstances) {
                        return mesh_hit_info;
                    }

                    let mesh_meta = meshInstances[mesh_instance_idx];

                    for (var i = 0u; i < mesh_meta.num_triangles; i = i + 1u) {
                       let tri_indices_struct = triangleIndexData[mesh_meta.index_offset + i];
                       let v0_data = vertexData[mesh_meta.vertex_offset + tri_indices_struct.i0];
                       let v1_data = vertexData[mesh_meta.vertex_offset + tri_indices_struct.i1];
                       let v2_data = vertexData[mesh_meta.vertex_offset + tri_indices_struct.i2];

                       let t_intersect = rayTriangleIntersect(ray, v0_data.position, v1_data.position, v2_data.position);

                       if (t_intersect > MIN_DIST && t_intersect < mesh_hit_info.distance) {
                           mesh_hit_info.is_hit = true;
                           mesh_hit_info.distance = t_intersect;
                           mesh_hit_info.hit_pos = ray.origin + ray.direction * t_intersect;
                           mesh_hit_info.normal = normalize(cross(v1_data.position - v0_data.position, v2_data.position - v0_data.position));
                           mesh_hit_info.sphere_idx = mesh_instance_idx;
                           mesh_hit_info.is_water = false;
                       }
                    }
                    return mesh_hit_info;
                }

                fn traceRay(initial_ray: Ray, current_time: f32, global_id_xy: vec2<u32>) -> vec4<f32> {
                    var final_color = vec3<f32>(0.0f);
                    var current_ray = initial_ray;
                    var current_weight = vec3<f32>(1.0f);
                    var current_ior = 1.0f;
                    let water_ior = 1.33f;
                    var is_in_water_medium_trace: u32 = 0u;

                    for (var bounce_count: u32 = 0u; bounce_count < raytracerUBO.maxBounces; bounce_count = bounce_count + 1u) {
                        var hit_info = raymarch(current_ray, current_time, raytracerUBO.warpStrength);

                        if (!hit_info.is_hit) {
                            let cloud_result = renderClouds(current_ray.origin, current_ray.direction, MAX_DIST, raytracerUBO.skyPreset);
                            final_color += current_weight * cloud_result.rgb;
                            break;
                        }

                        var current_hit_info = hit_info;
                        var placeholder_sphere_idx = hit_info.sphere_idx;
                        let sphere_material_type = spheres[placeholder_sphere_idx].pbr_properties.z;

                        if (sphere_material_type == 3.0f && raytracerUBO.numMeshInstances > 0u) {
                            let mesh_instance_idx = u32(spheres[placeholder_sphere_idx].pbr_properties.w);

                            if (mesh_instance_idx < raytracerUBO.numMeshInstances) {
                                let mesh_intersection_result = intersectMesh(current_ray, mesh_instance_idx, current_hit_info.distance);
                                if (mesh_intersection_result.is_hit) {
                                    current_hit_info = mesh_intersection_result;
                                    current_hit_info.object_id = hit_info.object_id;
                                } else {
                                    final_color += current_weight * renderClouds(current_ray.origin, current_ray.direction, MAX_DIST, raytracerUBO.skyPreset).rgb;
                                    break;
                                }
                            } else {
                                final_color += current_weight * renderClouds(current_ray.origin, current_ray.direction, MAX_DIST, raytracerUBO.skyPreset).rgb;
                                break;
                            }
                        }

                        let N = current_hit_info.normal;
                        let hit_pos = current_hit_info.hit_pos;
                        let V = -current_ray.direction;
                        var surface_color = vec3<f32>(0.0f);

                        is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);

                        if (current_hit_info.object_id == 0u) { // Terrain
                            let terrain_albedo = vec3<f32>(0.4f, 0.3f, 0.2f);
                            surface_color = calculateLighting(hit_pos, N, V, current_time, terrain_albedo, 0.0f, 0.9f, 0.04f, is_in_water_medium_trace, global_id_xy);
                            let noise_val_terrain = sample3DNoiseTexture(current_hit_info.hit_pos, 0.1f);
                            surface_color.r += noise_val_terrain * 0.5f;
                            final_color += current_weight * surface_color;
                            break;
                        }
                        else if (current_hit_info.object_id == 1u) { // Water
                            let water_surface_albedo = vec3<f32>(0.1f, 0.3f, 0.5f);
                            let water_body_color_absorption = vec3<f32>(0.1f, 0.2f, 0.3f);
                            surface_color = calculateLighting(hit_pos, N, V, current_time, water_surface_albedo, 0.0f, 0.1f, 0.04f, is_in_water_medium_trace, global_id_xy);
                            let noise_val_water = sample3DNoiseTexture(current_hit_info.hit_pos, 0.05f);
                            surface_color.g += noise_val_water * 0.3f;

                            let iors_info = get_ior_and_normal(current_ray.direction, N, current_ior, water_ior);
                            let n1 = iors_info[0]; let n2 = iors_info[1];
                            let adjusted_normal_water = vec3<f32>(iors_info[2], iors_info[3], iors_info[4]);

                            final_color += current_weight * surface_color;

                            let reflected_dir_water = reflect(current_ray.direction, adjusted_normal_water);
                            let reflected_ray_water = Ray(current_hit_info.hit_pos + reflected_dir_water * EPSILON, reflected_dir_water);

                            let refracted_dir_water = snellsLaw(current_ray.direction, adjusted_normal_water, n1, n2);
                            let cos_theta_i_water = dot(-current_ray.direction, adjusted_normal_water);
                            let fresnel_reflectance_water = fresnelSchlick(cos_theta_i_water, n1, n2);

                            if (length(refracted_dir_water) > 0.001f) {
                                final_color += current_weight * fresnel_reflectance_water * get_color_from_sub_hit(reflected_ray_water, current_time, is_in_water_medium_trace, global_id_xy);
                                current_ray = Ray(current_hit_info.hit_pos + refracted_dir_water * EPSILON * -1.0f, refracted_dir_water);
                                current_weight *= water_body_color_absorption * (1.0f - fresnel_reflectance_water);
                                current_ior = n2;
                                is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);
                            } else {
                                current_ray = reflected_ray_water;
                                final_color += current_weight * fresnel_reflectance_water * get_color_from_sub_hit(reflected_ray_water, current_time, is_in_water_medium_trace, global_id_xy);
                                current_weight *= water_surface_albedo;
                                break;
                            }
                        }
                        else {
                            let s_material_props = spheres[placeholder_sphere_idx];
                            let actual_material_type = u32(s_material_props.pbr_properties.z);

                            var albedo : vec3<f32>;
                            var metallic : f32;
                            var roughness : f32;
                            var base_reflectivity : f32;
                            var refractive_index_object : f32 = 1.0;

                            if (actual_material_type == 3u) {
                                let base_rock_albedo = vec3<f32>(0.25f, 0.22f, 0.20f);
                                let noise_albedo_variation = sample3DNoiseTexture(current_hit_info.hit_pos, 0.75f) * 0.15f;
                                albedo = base_rock_albedo + noise_albedo_variation;
                                metallic = 0.05f;
                                let base_rock_roughness = 0.75f;
                                let noise_roughness_variation = (sample3DNoiseTexture(current_hit_info.hit_pos, 1.5f) - 0.5f) * 0.2f;
                                roughness = clamp(base_rock_roughness + noise_roughness_variation, 0.1f, 0.95f);
                                base_reflectivity = 0.03f;

                                surface_color = calculateLighting(hit_pos, N, V, current_time, albedo, metallic, roughness, base_reflectivity, is_in_water_medium_trace, global_id_xy);
                                final_color += current_weight * surface_color;
                                break;
                            } else {
                                albedo = s_material_props.albedo_metallic.xyz;
                                metallic = s_material_props.albedo_metallic.w;
                                roughness = s_material_props.pbr_properties.x;
                                base_reflectivity = s_material_props.pbr_properties.y;
                                refractive_index_object = s_material_props.pbr_properties.w;

                                surface_color = calculateLighting(hit_pos, N, V, current_time, albedo, metallic, roughness, base_reflectivity, is_in_water_medium_trace, global_id_xy);
                                let noise_val_sphere = sample3DNoiseTexture(current_hit_info.hit_pos, 0.2f);
                                surface_color.r += noise_val_sphere * 0.5f;
                                final_color += current_weight * surface_color;

                                if (actual_material_type == MATERIAL_DIFFUSE) {
                                    break;
                                } else if (actual_material_type == MATERIAL_REFLECTIVE) {
                                    let reflected_dir_sphere = reflect(current_ray.direction, N);
                                    current_ray = Ray(current_hit_info.hit_pos + reflected_dir_sphere * EPSILON, reflected_dir_sphere);
                                    current_weight *= albedo;
                                } else if (actual_material_type == MATERIAL_REFRACTIVE) {
                                    let iors_info_sphere = get_ior_and_normal(current_ray.direction, N, current_ior, refractive_index_object);
                                    let n1_sphere = iors_info_sphere[0]; let n2_sphere = iors_info_sphere[1];
                                    let adjusted_normal_sphere = vec3<f32>(iors_info_sphere[2], iors_info_sphere[3], iors_info_sphere[4]);

                                    let cos_theta_i_sphere = dot(-current_ray.direction, adjusted_normal_sphere);
                                    let fresnel_reflectance_sphere = fresnelSchlick(cos_theta_i_sphere, n1_sphere, n2_sphere);

                                    let reflected_dir_sphere_refract = reflect(current_ray.direction, adjusted_normal_sphere);
                                    let reflected_ray_sphere_refract = Ray(current_hit_info.hit_pos + reflected_dir_sphere_refract * EPSILON, reflected_dir_sphere_refract);

                                    final_color += current_weight * fresnel_reflectance_sphere * get_color_from_sub_hit(reflected_ray_sphere_refract, current_time, is_in_water_medium_trace, global_id_xy);

                                    let refracted_dir_sphere = snellsLaw(current_ray.direction, adjusted_normal_sphere, n1_sphere, n2_sphere);

                                    if (length(refracted_dir_sphere) > 0.001f) {
                                        current_ray = Ray(current_hit_info.hit_pos + refracted_dir_sphere * EPSILON * -1.0f, refracted_dir_sphere);
                                        current_weight *= (1.0f - fresnel_reflectance_sphere) * albedo;
                                        current_ior = n2_sphere;
                                        is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);
                                    } else {
                                        current_ray = reflected_ray_sphere_refract;
                                        current_weight *= albedo; // Keep this as albedo for TIR reflection color
                                    }
                                }
                            }
                        }

                        if (max(max(current_weight.x, current_weight.y), current_weight.z) < 0.01f) {
                            break;
                        }
                    }
                    return vec4<f32>(final_color, 1.0f);
                }

                @compute @workgroup_size(8, 8)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let screen_width = cameraUBO.resolution.x;
                    let screen_height = cameraUBO.resolution.y;

                    if (global_id.x >= u32(screen_width) || global_id.y >= u32(screen_height)) {
                        return;
                    }

                    var final_accumulated_color = vec3<f32>(0.0f);
                    let frag_coord_xy = vec2<f32>(f32(global_id.x), f32(global_id.y));

                    for (var dof_idx: u32 = 0u; dof_idx < raytracerUBO.dofSamples; dof_idx = dof_idx + 1u) {
                        let rand_u_dof = rand_float(frag_coord_xy, timeUBO.time * 2.1f + f32(dof_idx) * 5.9f);
                        let rand_v_dof = rand_float(frag_coord_xy.yx, timeUBO.time * 1.7f + f32(dof_idx) * 9.1f);

                        let angle_dof = rand_u_dof * 2.0f * PI;
                        let radius_scale = sqrt(rand_v_dof);
                        let aperture_offset_x = cos(angle_dof) * radius_scale * raytracerUBO.apertureSize;
                        let aperture_offset_y = sin(angle_dof) * radius_scale * raytracerUBO.apertureSize;

                        let perturbed_origin = cameraUBO.position.xyz +
                                               cameraUBO.right.xyz * aperture_offset_x +
                                               cameraUBO.up.xyz * aperture_offset_y;

                        let ndc_x: f32 = (f32(global_id.x) / screen_width) * 2.0f - 1.0f;
                        let ndc_y: f32 = (1.0f - f32(global_id.y) / screen_height) * 2.0f - 1.0f;

                        let aspect_ratio = cameraUBO.aspect;
                        let fov_rad = cameraUBO.fovy;

                        let ray_x = ndc_x * aspect_ratio * tan(fov_rad / 2.0f);
                        let ray_y = ndc_y * tan(fov_rad / 2.0f);
                        let ray_z = -1.0f;

                        let ray_dir_camera_space = normalize(vec3<f32>(ray_x, ray_y, ray_z));

                        let ideal_ray_direction_world = normalize(
                            ray_dir_camera_space.x * cameraUBO.right.xyz +
                            ray_dir_camera_space.y * cameraUBO.up.xyz +
                            ray_dir_camera_space.z * cameraUBO.forward.xyz
                        );

                        let focal_point = cameraUBO.position.xyz + ideal_ray_direction_world * raytracerUBO.focalDistance;

                        let dof_ray_direction = normalize(focal_point - perturbed_origin);
                        let dof_ray = Ray(perturbed_origin, dof_ray_direction);

                        final_accumulated_color += traceRay(dof_ray, timeUBO.time, global_id.xy).xyz;
                    }

                    let final_color_per_pixel = final_accumulated_color / f32(raytracerUBO.dofSamples);

                    let previous_color_vec4 = textureLoad(inputTexture, vec2<i32>(global_id.xy), 0u);
                    let current_frame_f32 = f32(timeUBO.frame_count);
                    let blend_factor = 1.0f / (current_frame_f32 + 1.0f);
                    let new_accumulated_color = mix(previous_color_vec4.rgb, final_color_per_pixel, blend_factor);

                    textureStore(outputTexture, vec2<i32>(global_id.xy), vec4<f32>(new_accumulated_color, 1.0f));
                }
                \`;
                    this.uiManager.setLoadingStatus("ShaderManager initialized. Initializing SceneManager...");

                    this.sceneManager = new SceneManager(this);
                    console.log("SceneManager initialized.");
                    this.uiManager.setLoadingStatus("SceneManager initialized. Configuring canvas...");


                    this.device.lost.then((info) => {
                        console.error(\`WebGPU device lost: \${info.message}\`);
                        this.uiManager.displayErrorMessage(\`WebGPU device lost! Reason: \${info.reason}. Please try reducing settings and refresh.\`);
                        if (this.animationFrameId) {
                            cancelAnimationFrame(this.animationFrameId);
                            this.animationFrameId = null;
                        }
                        this.uiManager.switchView('menu');
                    });

                    this.context = this.canvas.getContext('webgpu');
                    if (!this.context) { throw new Error("Failed to get WebGPU context."); }

                    this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                    this.context.configure({ device: this.device, format: this.presentationFormat, alphaMode: 'opaque', size: [this.canvas.width, this.canvas.height] });
                    console.log("Canvas context configured by NovaRayEngine.");

                    await this.createCoreResourcesAndPipelines();

                    this.uiManager.setLoadingStatus("Initializing BVH Worker (NovaRayEngine)...");
                    this.initBvhWorker();

                    this.uiManager.setLoadingStatus("Generating 3D Noise Texture...");
                    await this.createNoiseGenerationPass();



                    this.sceneManager.updateCameraUniformBuffer();
                    this.sceneManager.light.color = this.sceneManager.hsvToRgb(this.sceneManager.sunHue);
                    this.sceneManager.updateLightUniformBuffer();
                    this.sceneManager.updateTimeUniformBuffer(this.totalTime, this.frameCount);
                    this.sceneManager.updateWaterUniformBuffer();
                    this.sceneManager.updateTerrainUniformBuffer();
                    this.sceneManager.updateRaytracerParamsUniformBuffer();
                    this.sceneManager.updateCloudParamsUniformBuffer(); // Ensure it's called after SceneManager is fully constructed and UBO buffer exists

                    this.sceneManager.manageSpheres();

                    this.createComputeBindGroups();

                    console.log("WebGPU initialization complete via NovaRayEngine.");
                    this.uiManager.setLoadingStatus("Initialization complete. Ready to render!");

                    this.uiManager.initEventListeners();

                    setTimeout(() => {
                        this.uiManager.switchView('scene');
                        this.uiManager.initSceneControlsUI();
                    }, 1000);
                    return true;

                } catch (error) {
                    console.error("NovaRayEngine initialization failed:", error);
                    this.uiManager.displayErrorMessage(\`NovaRayEngine Error: \${error.message}\`);
                    this.uiManager.switchView('menu');
                    return false;
                }
            },
            /**
             * Creates core GPU resources like textures, samplers, UBOs, and pipelines
             * for the main raytracing pass.
             * @async
             */
            async createCoreResourcesAndPipelines() {
                this.uiManager.setLoadingStatus("Creating textures and sampler (NovaRayEngine)...");
                if (this.outputTexture0) { this.outputTexture0.destroy(); }
                if (this.outputTexture1) { this.outputTexture1.destroy(); }
                let textureWidth = this.canvas.width;
                let textureHeight = this.canvas.height;
                this.outputTexture0 = this.resourceManager.createTexture({
                    size: { width: textureWidth, height: textureHeight },
                    format: 'rgba32float',
                    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
                }, "Output Texture 0 (Ping)");
                this.outputTextureView0 = this.outputTexture0.createView();
                this.outputTexture1 = this.resourceManager.createTexture({
                    size: { width: textureWidth, height: textureHeight },
                    format: 'rgba32float',
                    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
                }, "Output Texture 1 (Pong)");
                this.outputTextureView1 = this.outputTexture1.createView();
                console.log(\`Ping-pong textures created by NovaRayEngine with dimensions: \${textureWidth}x\${textureHeight}.\`);
                this.outputSampler = this.resourceManager.createSampler({ minFilter: 'nearest', magFilter: 'nearest' }, "Output Sampler");

                // Sampler for the 3D noise texture
                this.noiseSampler = this.resourceManager.createSampler({
                    addressModeU: 'repeat',
                    addressModeV: 'repeat',
                    addressModeW: 'repeat',
                    magFilter: 'linear',
                    minFilter: 'linear',
                    mipmapFilter: 'linear', // Or 'nearest' if no mipmaps for noise texture
                }, "3D Noise Sampler");


                this.uiManager.setLoadingStatus("Creating uniform buffers (NovaRayEngine)...");
                this.cameraUBOBuffer = this.resourceManager.createBuffer({ size: 96, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Camera UBO");
                this.lightUBOBuffer = this.resourceManager.createBuffer({ size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Light UBO");
                this.timeUBOBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Time UBO");
                this.waterUBOBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Water UBO");
                this.terrainUBOBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Terrain UBO");
                this.raytracerUBOBuffer = this.resourceManager.createBuffer({ size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Raytracer Params UBO");
                this.cloudParamsUBOBuffer = this.resourceManager.createBuffer({ size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Cloud Params UBO");

                // Mesh Data Buffers (initially small, SceneManager will resize and fill)
                this.meshInstanceDataBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST }, "Mesh Instance Data Buffer"); // Min size for empty array
                this.vertexDataBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST }, "Vertex Data Buffer");
                this.triangleIndexDataBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST }, "Triangle Index Data Buffer");


                this.uiManager.setLoadingStatus("Preparing rendering assets (NovaRayEngine)...");
                const renderQuadVerticesData = new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]);
                this.renderQuadVertexBuffer = this.resourceManager.createBuffer({ size: renderQuadVerticesData.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST }, "Render Quad Vertex Buffer");
                this.device.queue.writeBuffer(this.renderQuadVertexBuffer, 0, renderQuadVerticesData);

                this.uiManager.setLoadingStatus("Compiling shaders and creating pipelines (NovaRayEngine)...");
                const computeShaderModule = await this.shaderManager.createShaderModule(this.shaderManager.wgslCompute, 'Raytracer Compute Shader');
                const renderShaderModule = await this.shaderManager.createShaderModule(this.shaderManager.wgslRender, 'Raytracer Render Shader');

                this.computePipeline = await this.shaderManager.createComputePipeline({
                    layout: this.device.createPipelineLayout({
                        bindGroupLayouts: [
                            this.device.createBindGroupLayout({
                                entries: [
                                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                                    { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                                    { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
                                    { binding: 6, visibility: GPUShaderStage.COMPUTE, storageTexture: { format: 'rgba32float', access: 'write-only' } },
                                    { binding: 7, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: 'unfilterable-float' } },
                                    { binding: 8, visibility: GPUShaderStage.COMPUTE, sampler: { type: 'filtering' } },      // For 3D Noise Sampler
                                    { binding: 9, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: 'float', viewDimension: '3d' } },
                                    { binding: 10, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform'} }
                                ]
                            }),
                            this.device.createBindGroupLayout({
                                entries: [
                                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // spheres / mesh bounding spheres
                                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // bvhNodes
                                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // primitiveIndices (for BVH leaves)
                                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // meshInstances
                                    { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // vertexData
                                    { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, // triangleIndexData
                                ]
                            }),
                        ]
                    }),
                    compute: { module: computeShaderModule, entryPoint: 'main' }
                }, "Raytracer Compute Pipeline");

                this.renderPipeline = await this.shaderManager.createRenderPipeline({
                    layout: this.device.createPipelineLayout({
                        bindGroupLayouts: [ this.device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'non-filtering' } }, { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'unfilterable-float' } }, ] }) ]
                    }),
                    vertex: { module: renderShaderModule, entryPoint: 'vert_main', buffers: [{ arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }], }], },
                    fragment: { module: renderShaderModule, entryPoint: 'frag_main', targets: [{ format: this.presentationFormat }] },
                    primitive: { topology: 'triangle-list' },
                }, "Raytracer Render Pipeline");

                console.log("Pipelines created by NovaRayEngine using ShaderManager.");
                this.uiManager.setLoadingStatus("Pipelines created. Initializing Cloud UBO (placeholder)...");
                // Actual update call will be added later when SceneManager is updated
                // if (this.sceneManager && this.cloudParamsUBOBuffer) {
                //    this.sceneManager.updateCloudParamsUniformBuffer();
                // } else {
                //    console.warn("SceneManager or CloudParamsUBOBuffer not ready for initial UBO update in createCoreResourcesAndPipelines.");
                // }
                this.uiManager.setLoadingStatus("Pipelines created. Resizing canvas...");
                resizeCanvasAndAssets();
            },
            /**
             * Initializes the Web Worker for asynchronous BVH (Bounding Volume Hierarchy) construction.
             */
            initBvhWorker() {
                if (this.bvhWorker) {
                    console.log("Terminating existing BVH worker.");
                    this.bvhWorker.terminate();
                    this.bvhWorker = null;
                }

                try {
                    const blob = new Blob([bvhWorkerScript], { type: 'application/javascript' });
                    this.bvhWorker = new Worker(URL.createObjectURL(blob));
                    console.log("BVH Worker initialized.");

                    this.bvhWorker.onmessage = (event) => {
                        const { status, bvhNodes, primitiveIndices, message, stack } = event.data;
                        if (status === 'success') {
                            console.log("BVH Worker completed successfully.");
                            const bvhNodesTyped = new Float32Array(bvhNodes);
                            const primitiveIndicesTyped = new Uint32Array(primitiveIndices);

                            this.sceneManager.updateGPUBuffers(this.latestSphereDataForWorker, {
                                bvhNodes: this.convertFlatBvhNodes(bvhNodesTyped),
                                primitiveIndices: Array.from(primitiveIndicesTyped)
                            });
                            this.resetAccumulation();


                        } else {
                            console.error("BVH Worker failed:", message, stack);
                            this.uiManager.displayErrorMessage(\`BVH Worker Error: \${message}\`);
                        }
                        this.isBVHBuilding = false;
                        if (this.bvhUpdatePromise && this.bvhUpdatePromise._resolve) {
                            this.bvhUpdatePromise._resolve();
                        }
                        this.bvhUpdatePromise = null;
                    };

                    this.bvhWorker.onerror = (error) => {
                        console.error("Error in BVH Worker:", error.message, error);
                        this.uiManager.displayErrorMessage(\`BVH Worker Error: \${error.message}\`);
                        this.isBVHBuilding = false;
                        if (this.bvhUpdatePromise && this.bvhUpdatePromise._reject) {
                            this.bvhUpdatePromise._reject(error);
                        }
                        this.bvhUpdatePromise = null;
                    };

                } catch (e) {
                    console.error("Failed to initialize BVH Worker:", e);
                    this.uiManager.displayErrorMessage(\`Failed to create BVH Worker: \${e.message}\`);
                    this.bvhWorker = null;
                }
            },

            convertFlatBvhNodes(flatNodes) {
                const nodes = [];
                const BVH_NODE_FLOAT_COUNT = 12;
                for (let i = 0; i < flatNodes.length / BVH_NODE_FLOAT_COUNT; i++) {
                    const node = new BvhNode();
                    let offset = i * BVH_NODE_FLOAT_COUNT;
                    node.minBounds = [flatNodes[offset + 0], flatNodes[offset + 1], flatNodes[offset + 2]];
                    node.isLeaf = flatNodes[offset + 3];
                    node.maxBounds = [flatNodes[offset + 4], flatNodes[offset + 5], flatNodes[offset + 6]];
                    node.primitiveCount = flatNodes[offset + 7];
                    node.leftChildOrFirstPrimitiveIndex = flatNodes[offset + 8];
                    nodes.push(node);
                }
                return nodes;
            },
            /**
             * Resets the frame accumulation buffer and related counters.
             * This is typically called when camera or significant scene parameters change,
             * or when the canvas is resized. It recreates ping-pong textures and their bind groups.
             */
            resetAccumulation() {
                this.frameCount = 0;
                this.currentTextureIndex = 0;
                this.accumulationNeedsReset = true;

                if (this.device && this.canvas && this.resourceManager) {
                    if (this.outputTexture0) this.outputTexture0.destroy();
                    if (this.outputTexture1) this.outputTexture1.destroy();

                    const textureDesc = {
                        size: { width: this.canvas.width, height: this.canvas.height },
                        format: 'rgba32float',
                        usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
                    };

                    this.outputTexture0 = this.resourceManager.createTexture(textureDesc, "Output Texture 0 (Ping) - Reset Accumulation");
                    this.outputTextureView0 = this.outputTexture0.createView();
                    this.outputTexture1 = this.resourceManager.createTexture(textureDesc, "Output Texture 1 (Pong) - Reset Accumulation");
                    this.outputTextureView1 = this.outputTexture1.createView();

                    console.log('Accumulation reset: Ping-pong textures recreated.');

                    this.createComputeBindGroups();
                    this.createRenderBindGroup();
                } else {
                    console.warn("Accumulation reset attempted but NovaRayEngine not fully initialized.");
                }
            },

            /**
             * Creates bind groups for the main raytracing compute shader.
             * Assumes UBOs, storage buffers, ping-pong textures, and 3D noise texture/sampler are already created.
             */
            createComputeBindGroups() {
                const currentWriteTextureView = (this.currentTextureIndex === 0) ? this.outputTextureView0 : this.outputTextureView1;
                const currentReadTextureView = (this.currentTextureIndex === 0) ? this.outputTextureView1 : this.outputTextureView0;

                if (!this.device || !this.computePipeline || !currentWriteTextureView || !currentReadTextureView ||
                    !this.cameraUBOBuffer || !this.lightUBOBuffer || !this.timeUBOBuffer ||
                    !this.waterUBOBuffer || !this.terrainUBOBuffer || !this.raytracerUBOBuffer ||
                    !this.sphereDataBuffer || !this.bvhNodesBuffer || !this.primitiveIndicesBuffer ||
                    !this.meshInstanceDataBuffer || !this.vertexDataBuffer || !this.triangleIndexDataBuffer || // Added mesh buffers
                    !this.noiseSampler || !this.noiseTexture3DView || !this.cloudParamsUBOBuffer) {
                    console.warn("Skipping compute bind group creation: essential resources not ready.");
                    return;
                }

                this.computeBindGroup0 = this.device.createBindGroup({
                    label: "Compute Bind Group 0 (UBOs, Textures, Noise)",
                    layout: this.computePipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: this.cameraUBOBuffer } },
                        { binding: 1, resource: { buffer: this.lightUBOBuffer } },
                        { binding: 2, resource: { buffer: this.raytracerUBOBuffer } },
                        { binding: 3, resource: { buffer: this.timeUBOBuffer } },
                        { binding: 4, resource: { buffer: this.waterUBOBuffer } },
                        { binding: 5, resource: { buffer: this.terrainUBOBuffer } },
                        { binding: 6, resource: currentWriteTextureView },
                        { binding: 7, resource: currentReadTextureView },
                        { binding: 8, resource: this.noiseSampler },      // New binding for 3D Noise Sampler
                        { binding: 9, resource: this.noiseTexture3DView }, // New binding for 3D Noise Texture View
                        { binding: 10, resource: { buffer: this.cloudParamsUBOBuffer } } // Added CloudParamsUBOBuffer
                    ],
                });

                this.computeBindGroup1 = this.device.createBindGroup({
                    label: "Compute Bind Group 1 (Scene Data)",
                    layout: this.computePipeline.getBindGroupLayout(1),
                    entries: [
                        { binding: 0, resource: { buffer: this.sphereDataBuffer } },
                        { binding: 1, resource: { buffer: this.bvhNodesBuffer } },
                        { binding: 2, resource: { buffer: this.primitiveIndicesBuffer } },
                        { binding: 3, resource: { buffer: this.meshInstanceDataBuffer } },
                        { binding: 4, resource: { buffer: this.vertexDataBuffer } },
                        { binding: 5, resource: { buffer: this.triangleIndexDataBuffer } },
                    ],
                });
            },

            /**
             * Creates the bind group for the render pass, linking the correct output texture
             * that was just written to by the compute shader.
             */
            createRenderBindGroup() {
                const textureToDisplayView = (this.currentTextureIndex === 0) ? this.outputTextureView0 : this.outputTextureView1;

                if (!this.device || !this.renderPipeline || !this.outputSampler || !textureToDisplayView) {
                    console.warn("Skipping render bind group creation: essential resources not ready.");
                    return;
                }
                this.renderBindGroup = this.device.createBindGroup({
                    label: "Render Pass Bind Group",
                    layout: this.renderPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: this.outputSampler },
                        { binding: 1, resource: textureToDisplayView },
                    ],
                });
            },

            /**
             * Creates and runs a compute pass to generate a 3D noise texture.
             * Initializes this.noiseTexture3D, this.noiseTexture3DView, and this.noise3DComputePipeline.
             * This pass is executed once during initialization.
             * @async
             * @returns {Promise<void>}
             */
            async createNoiseGenerationPass() {
                if (!this.device || !this.resourceManager || !this.shaderManager) {
                    console.error("Noise generation requires device, resourceManager, and shaderManager.");
                    if(this.uiManager) this.uiManager.displayErrorMessage("Error: Noise generation resources not ready.");
                    return;
                }
                if(this.uiManager) this.uiManager.setLoadingStatus("Creating 3D noise texture resources...");

                // 1. Create Texture
                if (this.noiseTexture3D) this.noiseTexture3D.destroy();
                this.noiseTexture3D = this.resourceManager.createTexture({
                    size: this.noiseTextureSize,
                    dimension: '3d',
                    format: 'r32float',
                    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING,
                }, "3D Noise Texture");
                this.noiseTexture3DView = this.noiseTexture3D.createView();
                console.log("3D Noise Texture and View created.");

                // 2. Create Pipeline
                if(this.uiManager) this.uiManager.setLoadingStatus("Compiling 3D noise shader...");
                const noiseModule = await this.shaderManager.createShaderModule(this.shaderManager.wgslNoise3DCompute, "3D Noise Compute Shader");

                const noisePipelineLayout = this.device.createPipelineLayout({
                    bindGroupLayouts: [
                        this.device.createBindGroupLayout({
                            entries: [{
                                binding: 0,
                                visibility: GPUShaderStage.COMPUTE,
                                storageTexture: { access: 'write-only', format: 'r32float', viewDimension: '3d' }
                            }]
                        })
                    ]
                });

                this.noise3DComputePipeline = await this.shaderManager.createComputePipeline({
                    layout: noisePipelineLayout,
                    compute: { module: noiseModule, entryPoint: 'main' }
                }, "3D Noise Compute Pipeline");
                console.log("3D Noise Compute Pipeline created.");

                // 3. Create Bind Group
                const noisePassBindGroup = this.device.createBindGroup({
                    label: "3D Noise Pass Bind Group",
                    layout: this.noise3DComputePipeline.getBindGroupLayout(0),
                    entries: [{ binding: 0, resource: this.noiseTexture3DView }]
                });
                console.log("3D Noise Pass Bind Group created.");

                // 4. Dispatch Compute Pass
                if(this.uiManager) this.uiManager.setLoadingStatus("Dispatching 3D noise generation pass...");
                const commandEncoder = this.device.createCommandEncoder({ label: "Noise Generation Encoder" });
                const passEncoder = commandEncoder.beginComputePass({ label: "3D Noise Pass" });
                passEncoder.setPipeline(this.noise3DComputePipeline);
                passEncoder.setBindGroup(0, noisePassBindGroup);
                passEncoder.dispatchWorkgroups(
                    Math.ceil(this.noiseTextureSize.width / 4),
                    Math.ceil(this.noiseTextureSize.height / 4),
                    Math.ceil(this.noiseTextureSize.depth / 4)
                );
                passEncoder.end();
                this.device.queue.submit([commandEncoder.finish()]);

                try {
                    await this.device.queue.onSubmittedWorkDone();
                    console.log("3D Noise texture generated successfully.");
                    if(this.uiManager) this.uiManager.setLoadingStatus("3D Noise texture generated.");
                } catch(e) {
                    console.error("Error during 3D noise generation:", e);
                    if(this.uiManager) this.uiManager.displayErrorMessage("Error generating 3D noise: " + e.message);
                }
            }
        };
        // --- End NovaRayEngine Definition ---

        /**
         * @class SceneManager
         * @description Manages all scene-specific data, objects, and related logic for NovaRay.
         * This includes camera, lights, spheres, BVH, and parameters for procedural elements like water and terrain.
         * It provides methods to update these elements and their corresponding GPU buffers.
         * @param {NovaRayEngine} novaRayEngine - A reference to the main NovaRayEngine instance.
         */
        class SceneManager {
            constructor(novaRayEngine) {
                this.novaRayEngine = novaRayEngine;

                /** @type {object} Camera properties including position, rotation, FOV, etc. */
                this.camera = {
                    position: [0.0, 5.0, 20.0],
                    rotationX: -0.05,
                    rotationY: Math.PI,
                    forward: [0, 0, -1],
                    right: [1, 0, 0],
                    up: [0, 1, 0],
                    movementSpeed: 0.05,
                    rotationSpeed: 0.005,
                    fovy: Math.PI / 3,
                    aspect: 0,
                    near: 0.1,
                    far: 100.0,
                    focalDistance: 10.0,
                    apertureSize: 0.00,
                };

                /** @type {object} Light properties including position, brightness, size, and color. */
                this.light = {
                    position: [0.0, 10.0, 2.8],
                    brightness: 1.0,
                    size: 0.4,
                    color: [1.0, 1.0, 1.0]
                };
                /** @type {number} Hue component for the sun's color, used by UI and converted to RGB. */
                this.sunHue = 0.0;

                /** @type {Array<object>} Array holding all sphere objects in the scene. */
                this.spheres = [];
                /** @type {number} The target number of regular (non-rock) spheres for the scene, controlled by UI. */
                this.targetSphereCount = 5; // This now refers to non-rock spheres
                /** @type {number} The last actual number of spheres generated, for change detection. */
                this.lastSphereCount = 5; // This also refers to non-rock spheres
                /** @type {{bvhNodes: Array<BvhNode>, primitiveIndices: Array<number>}} Stores the result of the BVH build. */
                this.currentBvhResult = { bvhNodes: [], primitiveIndices: [] };

                /** @type {number} Strength of water waves. */
                this.waveStrength = 0.24;
                /** @type {number} Frequency of water waves. */
                this.waveFrequency = 0.5;
                /** @type {number} Speed of water wave animation. */
                this.waveSpeed = 0.01;

                /** @type {number} Global refractive index, primarily for water and refractive spheres. */
                this.globalRefractiveIndex = 1.50;
                /** @type {number} Strength of domain warping applied to scene elements. */
                this.globalWarpStrength = 0.0;
                /** @type {boolean} Flag to indicate if globalWarpStrength changed, to trigger sphere repopulation. */
                this.globalWarpStrengthChanged = false;
                /** @type {number} Height scale for terrain generation. */
                this.terrainHeightScale = 0.0;
                /** @type {number} Frequency for terrain noise generation. */
                this.terrainFrequency = 0.15;

                /** @type {number} Maximum ray bounces for path tracing. */
                this.maxBounces = 2;
                /** @type {number} Maximum steps for raymarching (SDFs). */
                this.maxRaymarchSteps = 150;
                /** @type {number} Number of samples for soft shadows. */
                this.shadowSamples = 4;
                /** @type {number} Number of samples for depth of field effect. */
                this.dofSamples = 4;
                /** @type {number} Current sky preset (0 for Sunny Day, 1 for Dusk). */
                this.skyPreset = 0;

                // Material type constants, matching WGSL definitions
                this.MATERIAL_DIFFUSE = 0;
                this.MATERIAL_REFLECTIVE = 1;
                this.MATERIAL_REFRACTIVE = 2;

                // Rock Generation Properties
                this.rockCount = 2;
                this.rockSubdivisions = 1;
                this.rockNumScrapes = 15;
                this.rockScrapeConfig = {
                    strength: 0.3,
                    radiusMin: 0.4,
                    radiusMax: 0.8
                };
                this.rockVertexNoiseStrength = 0.05;

                // Cloud Parameters (default values)
                this.cloudLayerMinY = 20.0;
                this.cloudLayerMaxY = 30.0;
                this.cloudNoiseScale = 0.05;
                this.cloudDensityThreshold = 0.3;
                this.cloudDensityMultiplier = 1.0;
                this.cloudMarchSteps = 64;
                this.cloudScatteringCoeff = 0.7;
                this.cloudAbsorptionCoeff = 0.3;
                this.cloudBaseColor = [0.8, 0.8, 0.85]; // R, G, B
                this.cloudAnimationSpeed = 0.03;

                if (this.novaRayEngine.canvas) {
                    this.camera.aspect = this.novaRayEngine.canvas.width / this.novaRayEngine.canvas.height;
                }
                this.updateCloudParamsUniformBuffer(); // Initialize UBO with default values
            }

            _regenerateSceneObjectsAndReset() {
                // targetSphereCount is the count for non-rock spheres.
                this.populateInitialSpheres(this.targetSphereCount);
                // updateGPUBuffers was already modified to handle meshData and pack it.
                // It also updates RaytracerParams with the number of mesh instances.
                // A valid BVH result is needed, even if it's empty from a previous state or initial.
                if (!this.currentBvhResult) { // Ensure it exists
                    this.currentBvhResult = { bvhNodes: [], primitiveIndices: [] };
                }
                this.updateGPUBuffers(this.spheres, this.currentBvhResult);
                this.novaRayEngine.resetAccumulation();
            }

            // --- Rock Property Setters ---
            setRockCount(value) { value = parseInt(value); if (this.rockCount !== value && value >= 0) { this.rockCount = value; this._regenerateSceneObjectsAndReset(); } }
            setRockSubdivisions(value) { value = parseInt(value); if (this.rockSubdivisions !== value && value >= 0) { this.rockSubdivisions = value; this._regenerateSceneObjectsAndReset(); } }
            setRockNumScrapes(value) { value = parseInt(value); if (this.rockNumScrapes !== value && value >= 0) { this.rockNumScrapes = value; this._regenerateSceneObjectsAndReset(); } }
            setRockScrapeStrength(value) { value = parseFloat(value); if (this.rockScrapeConfig.strength !== value && value >= 0) { this.rockScrapeConfig.strength = value; this._regenerateSceneObjectsAndReset(); } }
            setRockScrapeRadiusMin(value) { value = parseFloat(value); if (this.rockScrapeConfig.radiusMin !== value && value >= 0) { this.rockScrapeConfig.radiusMin = value; this._regenerateSceneObjectsAndReset(); } }
            setRockScrapeRadiusMax(value) { value = parseFloat(value); if (this.rockScrapeConfig.radiusMax !== value && value >= 0) { this.rockScrapeConfig.radiusMax = value; this._regenerateSceneObjectsAndReset(); } }
            setRockVertexNoiseStrength(value) { value = parseFloat(value); if (this.rockVertexNoiseStrength !== value && value >= 0) { this.rockVertexNoiseStrength = value; this._regenerateSceneObjectsAndReset(); } }


            // --- Camera Movement and Rotation Methods ---
            /**
             * Moves the camera by the given deltas in world space.
             * @param {number} dx - Change in X position.
             * @param {number} dy - Change in Y position.
             * @param {number} dz - Change in Z position.
             */
            moveCamera(dx, dy, dz) {
                this.camera.position[0] += dx;
                this.camera.position[1] += dy;
                this.camera.position[2] += dz;
                this.updateCameraUniformBuffer();
                this.novaRayEngine.resetAccumulation();
            }

            /**
             * Rotates the camera based on yaw and pitch changes.
             * @param {number} deltaYaw - Change in yaw (left/right look).
             * @param {number} deltaPitch - Change in pitch (up/down look).
             */
            rotateCamera(deltaYaw, deltaPitch) {
                this.camera.rotationY += deltaYaw * this.camera.rotationSpeed;
                this.camera.rotationX += deltaPitch * this.camera.rotationSpeed;
                // Clamp pitch
                this.camera.rotationX = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, this.camera.rotationX));

                this.calculateCameraVectors(); // Ensure vectors are updated after rotation
                this.updateCameraUniformBuffer();
                this.novaRayEngine.resetAccumulation();
            }
            // --- Setter methods for scene parameters ---
            /** Sets camera focal distance and resets accumulation. */
            setFocalDistance(value) {
                value = parseFloat(value);
                if (this.camera.focalDistance !== value) {
                    this.camera.focalDistance = value;
                    this.updateRaytracerParamsUniformBuffer();
                    this.novaRayEngine.resetAccumulation();
                }
            }

            /** Sets camera aperture size and resets accumulation. */
            setApertureSize(value) {
                value = parseFloat(value);
                if (this.camera.apertureSize !== value) {
                    this.camera.apertureSize = value;
                    this.updateRaytracerParamsUniformBuffer();
                    this.novaRayEngine.resetAccumulation();
                }
            }

            /** Sets light position for a given axis and resets accumulation. */
            setLightPosition(axis, value) {
                value = parseFloat(value);
                let changed = false;
                if (axis === 'x' && this.light.position[0] !== value) { this.light.position[0] = value; changed = true; }
                else if (axis === 'y' && this.light.position[1] !== value) { this.light.position[1] = value; changed = true; }
                else if (axis === 'z' && this.light.position[2] !== value) { this.light.position[2] = value; changed = true; }
                if (changed) { this.updateLightUniformBuffer(); this.novaRayEngine.resetAccumulation(); }
            }
            setLightBrightness(value) { value = parseFloat(value); if (this.light.brightness !== value) { this.light.brightness = value; this.updateLightUniformBuffer(); this.novaRayEngine.resetAccumulation();}}
            setLightSize(value) { value = parseFloat(value); if (this.light.size !== value) { this.light.size = value; this.updateLightUniformBuffer(); this.novaRayEngine.resetAccumulation();}}
            setSunHue(value) {
                value = parseFloat(value);
                if (this.sunHue !== value) {
                    this.sunHue = value;
                    this.light.color = this.hsvToRgb(value);
                    this.updateLightUniformBuffer();
                    this.novaRayEngine.resetAccumulation();
                }
            }
            setWaveStrength(value) { value = parseFloat(value); if (this.waveStrength !== value) { this.waveStrength = value; this.updateWaterUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setWaveFrequency(value) { value = parseFloat(value); if (this.waveFrequency !== value) { this.waveFrequency = value; this.updateWaterUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setWaveSpeed(value) { value = parseFloat(value); if (this.waveSpeed !== value) { this.waveSpeed = value; this.updateWaterUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setGlobalRefractiveIndex(value) {
                value = parseFloat(value);
                if (this.globalRefractiveIndex !== value) {
                    this.globalRefractiveIndex = value;
                    this.spheres.forEach(s => { if (s.materialType === this.MATERIAL_REFRACTIVE) s.refractiveIndex = this.globalRefractiveIndex; });
                    this.updateGPUBuffers(this.spheres, this.currentBvhResult);
                    this.novaRayEngine.resetAccumulation();
                }
            }
            setTerrainHeightScale(value) { value = parseFloat(value); if (this.terrainHeightScale !== value) { this.terrainHeightScale = value; this.updateTerrainUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setTerrainFrequency(value) { value = parseFloat(value); if (this.terrainFrequency !== value) { this.terrainFrequency = value; this.updateTerrainUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setMaxBounces(value) { value = parseInt(value); if (this.maxBounces !== value) { this.maxBounces = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setMaxRaymarchSteps(value) { value = parseInt(value); if (this.maxRaymarchSteps !== value) { this.maxRaymarchSteps = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setShadowSamples(value) { value = parseInt(value); if (this.shadowSamples !== value) { this.shadowSamples = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setDofSamples(value) { value = parseInt(value); if (this.dofSamples !== value) { this.dofSamples = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setGlobalWarpStrength(value) {
                value = parseFloat(value);
                if (this.globalWarpStrength !== value) {
                    this.globalWarpStrength = value;
                    this.globalWarpStrengthChanged = true;
                    this.manageSpheres();
                    this.updateRaytracerParamsUniformBuffer();
                }
            }
            setSkyPreset(value) { value = parseInt(value); if (this.skyPreset !== value) { this.skyPreset = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setTargetSphereCount(count) {
                const newCount = parseInt(count);
                if (this.targetSphereCount !== newCount && newCount >=0) { // Ensure non-negative
                    this.targetSphereCount = newCount; // This now refers to non-rock spheres
                    this._regenerateSceneObjectsAndReset();
                }
            }


            hsvToRgb(h) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = 0;
                const q = 1 - f;
                const t = f;
                switch (i % 6) {
                    case 0: r = 1; g = t; b = p; break;
                    case 1: r = q; g = 1; b = p; break;
                    case 2: r = p; g = 1; b = t; break;
                    case 3: r = p; g = q; b = 1; break;
                    case 4: r = t; g = p; b = 1; break;
                    case 5: r = 1; g = p; b = q; break;
                }
                return [r, g, b];
            }

            calculateCameraVectors() {
                const pitch = this.camera.rotationX;
                const yaw = this.camera.rotationY;
                this.camera.forward[0] = Math.cos(pitch) * Math.sin(yaw);
                this.camera.forward[1] = Math.sin(pitch);
                this.camera.forward[2] = -Math.cos(pitch) * Math.cos(yaw);
                let len = Math.sqrt(this.camera.forward[0] ** 2 + this.camera.forward[1] ** 2 + this.camera.forward[2] ** 2);
                this.camera.forward[0] /= len; this.camera.forward[1] /= len; this.camera.forward[2] /= len;

                let worldUp = [0, 1, 0];
                this.camera.right[0] = worldUp[1] * this.camera.forward[2] - worldUp[2] * this.camera.forward[1];
                this.camera.right[1] = worldUp[2] * this.camera.forward[0] - worldUp[0] * this.camera.forward[2];
                this.camera.right[2] = worldUp[0] * this.camera.forward[1] - worldUp[1] * this.camera.forward[0];
                len = Math.sqrt(this.camera.right[0] ** 2 + this.camera.right[1] ** 2 + this.camera.right[2] ** 2);
                if (len > 0) { this.camera.right[0] /= len; this.camera.right[1] /= len; this.camera.right[2] /= len; } else { this.camera.right = [1, 0, 0]; }

                this.camera.up[0] = this.camera.forward[1] * this.camera.right[2] - this.camera.forward[2] * this.camera.right[1];
                this.camera.up[1] = this.camera.forward[2] * this.camera.right[0] - this.camera.forward[0] * this.camera.right[2];
                this.camera.up[2] = this.camera.forward[0] * this.camera.right[1] - this.camera.forward[1] * this.camera.right[0];
                len = Math.sqrt(this.camera.up[0] ** 2 + this.camera.up[1] ** 2 + this.camera.up[2] ** 2);
                if (len > 0) { this.camera.up[0] /= len; this.camera.up[1] /= len; this.camera.up[2] /= len; } else { this.camera.up = [0, 1, 0]; }
            }
            /**
             * Populates the spheres array with a given number of spheres, including a ground sphere.
             * Applies domain warping if `this.globalWarpStrength > 0`.
             * @param {number} count - The total number of spheres to generate (including ground sphere).
             * @returns {Array<object>} The array of generated sphere objects.
             */
            // Helper to calculate bounding sphere for a set of vertices
            _calculateBoundingSphere(positions) {
                if (!positions || positions.length === 0) {
                    return { center: [0,0,0], radius: 0 };
                }
                let min = [Infinity, Infinity, Infinity];
                let max = [-Infinity, -Infinity, -Infinity];
                for (let i = 0; i < positions.length; i += 3) {
                    min[0] = Math.min(min[0], positions[i]);
                    min[1] = Math.min(min[1], positions[i+1]);
                    min[2] = Math.min(min[2], positions[i+2]);
                    max[0] = Math.max(max[0], positions[i]);
                    max[1] = Math.max(max[1], positions[i+1]);
                    max[2] = Math.max(max[2], positions[i+2]);
                }
                const center = [
                    (min[0] + max[0]) / 2,
                    (min[1] + max[1]) / 2,
                    (min[2] + max[2]) / 2
                ];
                let radius = 0;
                for (let i = 0; i < positions.length; i += 3) {
                    const distSq = (positions[i] - center[0])**2 +
                                 (positions[i+1] - center[1])**2 +
                                 (positions[i+2] - center[2])**2;
                    radius = Math.max(radius, Math.sqrt(distSq));
                }
                return { center, radius };
            }

            populateInitialSpheres(regularSphereCount) { // Renamed 'count' to 'regularSphereCount' for clarity
                const newSpheres = [];
                const sphereMinRadius = 0.5;
                const sphereMaxRadius = 1.5;
                // Ensure ProceduralMeshGenerator is available
                if (!this.meshGenerator) {
                    this.meshGenerator = new ProceduralMeshGenerator();
                }

                // Ground Sphere (always present, not part of 'regularSphereCount' or 'rockCount')
                newSpheres.push({
                    position: [0.0, -100.5, 0.0], radius: 100.0,
                    color: [0.7, 0.7, 0.7],
                    baseReflectivity: 0.04,
                    perPixelRoughness: 0.9,
                    metallic: 0.0,
                    refractiveIndex: 1.0,
                    materialType: this.MATERIAL_DIFFUSE,
                    originalIndex: 0, // Remains 0
                    isProceduralRock: false
                });

                // Generate Regular Spheres first
                for (let i = 0; i < regularSphereCount; ++i) {
                    let materialType;
                    const r = Math.random();
                    if (r < 0.4) materialType = this.MATERIAL_DIFFUSE;
                    else if (r < 0.7) materialType = this.MATERIAL_REFLECTIVE;
                    else materialType = this.MATERIAL_REFRACTIVE;

                    let s = {
                        position: [0, 0, 0],
                        radius: sphereMinRadius + Math.random() * (sphereMaxRadius - sphereMinRadius),
                        color: [0, 0, 0], // Will be set below
                        baseReflectivity: 0.04,
                        perPixelRoughness: 0.0, // Will be set below
                        metallic: 0.0, // Will be set for reflective
                        refractiveIndex: 1.0, // Default, will be set for refractive
                        materialType: materialType,
                        originalIndex: newSpheres.length,
                        isProceduralRock: false
                    };

                    let attempts = 0; const max_attempts = 50; let collided;
                    const distanceSq = (p1, p2) => (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2;
                    do {
                        collided = false;
                        s.position[0] = (Math.random() - 0.5) * 15;
                        s.position[1] = s.radius + Math.random() * 3;
                        s.position[2] = (Math.random() - 0.5) * 15;
                        for (let j = 0; j < newSpheres.length; ++j) {
                            if (distanceSq(s.position, newSpheres[j].position) < (s.radius + newSpheres[j].radius + 0.5)**2) {
                                collided = true; break;
                            }
                        }
                        attempts++;
                    } while (collided && attempts < max_attempts);

                    if (!collided) {
                        if (materialType === this.MATERIAL_DIFFUSE) {
                            s.perPixelRoughness = Math.random() * 0.7 + 0.3;
                            s.color = [Math.random(), Math.random(), Math.random()];
                        } else if (materialType === this.MATERIAL_REFLECTIVE) {
                            s.perPixelRoughness = Math.random() * 0.1; s.metallic = 1.0;
                            s.color = [Math.random() * 0.7 + 0.3, Math.random() * 0.7 + 0.3, Math.random() * 0.7 + 0.3];
                        } else if (materialType === this.MATERIAL_REFRACTIVE) {
                            s.perPixelRoughness = Math.random() * 0.1;
                            s.refractiveIndex = this.globalRefractiveIndex;
                            s.color = [Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5];
                        }
                        newSpheres.push(s);
                    }
                }

                // Generate Procedural Rocks
                for (let r_idx = 0; r_idx < this.rockCount; r_idx++) {
                    const rockGenConfig = {
                        subdivisions: this.rockSubdivisions,
                        numScrapes: this.rockNumScrapes,
                        scrapeStrength: this.rockScrapeConfig.strength,
                        scrapeRadiusMin: this.rockScrapeConfig.radiusMin,
                        scrapeRadiusMax: this.rockScrapeConfig.radiusMax,
                        noiseStrength: this.rockVertexNoiseStrength
                    };
                    const rockData = this.meshGenerator.generateRock(rockGenConfig);
                    const boundingSphere = this._calculateBoundingSphere(rockData.positions);

                    if (boundingSphere && boundingSphere.radius > 0) {
                        let rockPlaceholder = {
                            position: boundingSphere.center, // Will be randomized
                            radius: boundingSphere.radius,
                            color: [0.5, 0.5, 0.55],
                            baseReflectivity: 0.04,
                            perPixelRoughness: 0.8,
                            metallic: 0.01,
                            refractiveIndex: 1.0,
                            materialType: 3,
                            isProceduralRock: true,
                            meshData: rockData,
                            originalIndex: newSpheres.length
                        };

                        let attempts = 0; const max_attempts = 20; let collided;
                        const distanceSq = (p1, p2) => (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2;
                        do {
                            collided = false;
                            rockPlaceholder.position[0] = (Math.random() - 0.5) * 20;
                            rockPlaceholder.position[1] = rockPlaceholder.radius + Math.random() * 2;
                            rockPlaceholder.position[2] = (Math.random() - 0.5) * 20;
                            for (let j = 0; j < newSpheres.length; ++j) {
                                if (distanceSq(rockPlaceholder.position, newSpheres[j].position) < (rockPlaceholder.radius + newSpheres[j].radius + 1.0)**2) {
                                    collided = true; break;
                                }
                            }
                            attempts++;
                        } while (collided && attempts < max_attempts);

                        if (!collided) {
                           newSpheres.push(rockPlaceholder);
                        }
                    }
                }

                this.spheres = newSpheres;

                if (this.globalWarpStrength > 0) {
                    this.spheres.forEach(sphere => {
                        if (sphere.originalIndex === 0) return;
                        if (!sphere.isProceduralRock) {
                            const warpedPos = this.applyDomainWarp(sphere.position, this.globalWarpStrength);
                            sphere.position[0] = warpedPos[0];
                            sphere.position[1] = warpedPos[1];
                            sphere.position[2] = warpedPos[2];
                        }
                    });
                }
                return newSpheres;
            }

            applyDomainWarp(position, strength) {
                const p = position;
                const s = strength;
                const q = [
                    snoise([p[0], p[1], p[2]]),
                    snoise([p[0] + 5.2, p[1] - 1.3, p[2]]),
                    snoise([p[0] - 2.7, p[1] + 3.1, p[2] + 1.5])
                ];
                return [ p[0] + q[0] * s, p[1] + q[1] * s, p[2] + q[2] * s ];
            }

            /** Builds the BVH structure synchronously on the main thread. Used as a fallback or if worker is disabled. */
            buildBvhStructure(primitivesForBVH) {
                console.time("BVH Build (SceneManager Sync)");
                if (this.novaRayEngine.uiManager) this.novaRayEngine.uiManager.setLoadingStatus(`Building BVH for ${primitivesForBVH.length} spheres (Sync)...`);

                if (primitivesForBVH.length === 0) {
                    console.warn("No primitives to build BVH for (SceneManager Sync).");
                    return { bvhNodes: [], primitiveIndices: [] };
                }

                const flattenedNodes = [];
                const primitiveIndices = Array.from({ length: primitivesForBVH.length }, (_, i) => i);

                try {
                    buildBvh(primitivesForBVH, flattenedNodes, primitiveIndices, 0, primitivesForBVH.length);
                } catch (e) {
                    console.error("Error during BVH construction (SceneManager Sync):", e);
                    if (this.novaRayEngine.uiManager) this.novaRayEngine.uiManager.displayErrorMessage(`BVH construction failed (Sync): ${e.message}`);
                    return { bvhNodes: [], primitiveIndices: [] };
                }

                console.timeEnd("BVH Build (SceneManager Sync)");
                if (this.novaRayEngine.uiManager) this.novaRayEngine.uiManager.setLoadingStatus(`BVH built with ${flattenedNodes.length} nodes (Sync). Uploading to GPU...`);
                return { bvhNodes: flattenedNodes, primitiveIndices: primitiveIndices };
            }

            /**
             * Updates the GPU buffers for spheres, BVH nodes, and primitive indices.
             * @param {Array<object>} newSpheresData - Array of sphere objects.
             * @param {object} bvhData - Object containing `bvhNodes` (Array<BvhNode>) and `primitiveIndices` (Array<number>).
             */
            updateGPUBuffers(newSpheresData, bvhData) {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.resourceManager) {
                    console.warn("NovaRayEngine.device or resourceManager not ready for GPU buffer update.");
                    return;
                }
                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Updating sphere data (${newSpheresData.length} spheres)...`);

                const SPHERE_FLOAT_COUNT = 12;
                const sphereRawData = new Float32Array(newSpheresData.length * SPHERE_FLOAT_COUNT);
                newSpheresData.forEach((s, i) => {
                    let offset = i * SPHERE_FLOAT_COUNT;
                    sphereRawData[offset + 0] = s.position[0]; sphereRawData[offset + 1] = s.position[1]; sphereRawData[offset + 2] = s.position[2]; sphereRawData[offset + 3] = s.radius;
                    sphereRawData[offset + 4] = s.color[0]; sphereRawData[offset + 5] = s.color[1]; sphereRawData[offset + 6] = s.color[2]; sphereRawData[offset + 7] = s.metallic;
                    // pbr_properties: .x = roughness, .y = baseReflectivity, .z = materialType, .w = refractiveIndex OR meshInstanceIndex if rock
                    sphereRawData[offset + 8] = s.perPixelRoughness;
                    sphereRawData[offset + 9] = s.baseReflectivity;
                    sphereRawData[offset + 10] = s.materialType; // This is pbr_properties.z (MATERIAL_DIFFUSE, _REFLECTIVE, _REFRACTIVE, or 3 for rock)
                    // Store meshInstance index in .w for rocks, otherwise IOR. Need to track meshInstance index.
                    // This will be done when processing proceduralRocks later. For now, placeholder.
                    sphereRawData[offset + 11] = s.refractiveIndex; // Initial placeholder, will be overwritten for rocks
                });

                // --- Mesh Data Buffer Updates ---
                const proceduralRocks = newSpheresData.filter(s => s.isProceduralRock && s.meshData);
                let totalVertices = 0;
                let totalTriangles = 0;
                proceduralRocks.forEach(rock => {
                    totalVertices += rock.meshData.positions.length / 3;
                    totalTriangles += rock.meshData.indices.length / 3;
                });

                const MESH_INSTANCE_FIELDS = 4; // vertex_offset, index_offset, num_triangles, material_id (all u32)
                const meshInstanceRawData = new Uint32Array(proceduralRocks.length * MESH_INSTANCE_FIELDS);

                const VERTEX_FIELDS = 6; // position (3 f32) + normal (3 f32)
                const allVertexData = new Float32Array(totalVertices * VERTEX_FIELDS);

                const TRIANGLE_INDICES_PER_TRIANGLE = 3;
                const allTriangleIndexData = new Uint32Array(totalTriangles * TRIANGLE_INDICES_PER_TRIANGLE);

                let currentVertexOffset = 0;
                let currentIndexBufferOffset = 0;
                let currentMeshInstanceIdx = 0;

                proceduralRocks.forEach(rock => {
                    const mesh = rock.meshData;
                    const numMeshVertices = mesh.positions.length / 3;
                    const numMeshTriangles = mesh.indices.length / 3;

                    meshInstanceRawData[currentMeshInstanceIdx * MESH_INSTANCE_FIELDS + 0] = currentVertexOffset;
                    meshInstanceRawData[currentMeshInstanceIdx * MESH_INSTANCE_FIELDS + 1] = currentIndexBufferOffset;
                    meshInstanceRawData[currentMeshInstanceIdx * MESH_INSTANCE_FIELDS + 2] = numMeshTriangles;
                    meshInstanceRawData[currentMeshInstanceIdx * MESH_INSTANCE_FIELDS + 3] = 0; // Placeholder material_id for rock (e.g., an index into a future material array)

                    // Update the corresponding sphere entry's pbr_properties.w to store this mesh instance index
                    const sphereIndexInRawData = rock.originalIndex !== undefined ? rock.originalIndex : -1;
                    if (sphereIndexInRawData !== -1 && sphereIndexInRawData < newSpheresData.length) {
                        // Assuming newSpheresData[sphereIndexInRawData] is the rock placeholder
                        let offset = sphereIndexInRawData * SPHERE_FLOAT_COUNT;
                        sphereRawData[offset + 11] = currentMeshInstanceIdx; // Store the mesh instance index
                    } else {
                        console.warn("Could not find rock placeholder in sphereRawData to update meshInstanceIndex", rock);
                    }
                    currentMeshInstanceIdx++;


                    for (let i = 0; i < numMeshVertices; i++) {
                        let vertexBase = (currentVertexOffset + i) * VERTEX_FIELDS;
                        allVertexData[vertexBase + 0] = mesh.positions[i * 3 + 0];
                        allVertexData[vertexBase + 1] = mesh.positions[i * 3 + 1];
                        allVertexData[vertexBase + 2] = mesh.positions[i * 3 + 2];
                        allVertexData[vertexBase + 3] = mesh.normals[i * 3 + 0];
                        allVertexData[vertexBase + 4] = mesh.normals[i * 3 + 1];
                        allVertexData[vertexBase + 5] = mesh.normals[i * 3 + 2];
                    }

                    for (let i = 0; i < mesh.indices.length; i++) {
                        allTriangleIndexData[currentIndexBufferOffset + i] = mesh.indices[i] + currentVertexOffset;
                    }

                    currentVertexOffset += numMeshVertices;
                    currentIndexBufferOffset += mesh.indices.length;
                });

                // Now that sphereRawData has been updated for rocks, write it.
                if (engine.sphereDataBuffer) { engine.sphereDataBuffer.destroy(); }
                engine.sphereDataBuffer = engine.resourceManager.createBuffer({
                    size: sphereRawData.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "Sphere Data Buffer (SceneManager)");
                engine.device.queue.writeBuffer(engine.sphereDataBuffer, 0, sphereRawData);

                this.currentBvhResult.bvhNodes = bvhData.bvhNodes;
                this.currentBvhResult.primitiveIndices = bvhData.primitiveIndices;

                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Updating BVH nodes (${bvhData.bvhNodes.length} nodes)...`);
                const BVH_NODE_FLOAT_COUNT = 12;
                const bvhNodesFlat = new Float32Array(bvhData.bvhNodes.length * BVH_NODE_FLOAT_COUNT);
                const bvhNodesIntView = new Uint32Array(bvhNodesFlat.buffer);

                bvhData.bvhNodes.forEach((node, i) => {
                    let floatOffset = i * BVH_NODE_FLOAT_COUNT;
                    let intOffset = floatOffset;

                    bvhNodesFlat[floatOffset + 0] = node.minBounds[0]; bvhNodesFlat[floatOffset + 1] = node.minBounds[1]; bvhNodesFlat[floatOffset + 2] = node.minBounds[2];
                    bvhNodesIntView[intOffset + 3] = node.isLeaf;

                    bvhNodesFlat[floatOffset + 4] = node.maxBounds[0]; bvhNodesFlat[floatOffset + 5] = node.maxBounds[1]; bvhNodesFlat[floatOffset + 6] = node.maxBounds[2];
                    bvhNodesIntView[intOffset + 7] = node.primitiveCount;

                    bvhNodesIntView[intOffset + 8] = node.leftChildOrFirstPrimitiveIndex;
                });

                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Updating primitive indices (${bvhData.primitiveIndices.length} indices)...`);
                const primitiveIndicesFlat = new Uint32Array(bvhData.primitiveIndices);

                if (engine.bvhNodesBuffer) { engine.bvhNodesBuffer.destroy(); }
                engine.sphereDataBuffer = engine.resourceManager.createBuffer({
                    size: sphereRawData.byteLength > 0 ? sphereRawData.byteLength : 16, // Min size for empty
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "Sphere Data Buffer (SceneManager)");
                if (sphereRawData.byteLength > 0) engine.device.queue.writeBuffer(engine.sphereDataBuffer, 0, sphereRawData);


                if (engine.bvhNodesBuffer) { engine.bvhNodesBuffer.destroy(); }
                engine.bvhNodesBuffer = engine.resourceManager.createBuffer({
                    size: bvhNodesFlat.byteLength > 0 ? bvhNodesFlat.byteLength : 16,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "BVH Nodes Buffer (SceneManager)");
                if (bvhNodesFlat.byteLength > 0) engine.device.queue.writeBuffer(engine.bvhNodesBuffer, 0, bvhNodesFlat);


                if (engine.primitiveIndicesBuffer) { engine.primitiveIndicesBuffer.destroy(); }
                engine.primitiveIndicesBuffer = engine.resourceManager.createBuffer({
                    size: primitiveIndicesFlat.byteLength > 0 ? primitiveIndicesFlat.byteLength : 16,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "Primitive Indices Buffer (SceneManager)");
                if (primitiveIndicesFlat.byteLength > 0) engine.device.queue.writeBuffer(engine.primitiveIndicesBuffer, 0, primitiveIndicesFlat);


                if (engine.meshInstanceDataBuffer) engine.meshInstanceDataBuffer.destroy();
                engine.meshInstanceDataBuffer = engine.resourceManager.createBuffer({
                    size: meshInstanceRawData.byteLength > 0 ? meshInstanceRawData.byteLength : 16,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "Mesh Instance Data Buffer");
                if (meshInstanceRawData.byteLength > 0) engine.device.queue.writeBuffer(engine.meshInstanceDataBuffer, 0, meshInstanceRawData);

                if (engine.vertexDataBuffer) engine.vertexDataBuffer.destroy();
                engine.vertexDataBuffer = engine.resourceManager.createBuffer({
                    size: allVertexData.byteLength > 0 ? allVertexData.byteLength : 16,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "Vertex Data Buffer");
                if (allVertexData.byteLength > 0) engine.device.queue.writeBuffer(engine.vertexDataBuffer, 0, allVertexData);

                if (engine.triangleIndexDataBuffer) engine.triangleIndexDataBuffer.destroy();
                engine.triangleIndexDataBuffer = engine.resourceManager.createBuffer({
                    size: allTriangleIndexData.byteLength > 0 ? allTriangleIndexData.byteLength : 16,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "Triangle Index Data Buffer");
                if (allTriangleIndexData.byteLength > 0) engine.device.queue.writeBuffer(engine.triangleIndexDataBuffer, 0, allTriangleIndexData);

                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Mesh buffers updated: ${proceduralRocks.length} meshes, ${totalVertices} vertices, ${totalTriangles} triangles.`);

                this.updateRaytracerParamsUniformBuffer(proceduralRocks.length); // Pass the number of actual mesh instances
                this.novaRayEngine.createComputeBindGroups();
            }

            /**
             * Manages sphere population and BVH construction, opting for asynchronous
             * BVH building via Web Worker if available and not busy, otherwise falls back
             * to synchronous construction.
             */
            manageSpheres() {
                const engine = this.novaRayEngine;
                if (this.spheres.length !== this.targetSphereCount || this.lastSphereCount !== this.targetSphereCount || this.spheres.length === 0 || this.globalWarpStrengthChanged) {
                    this.populateInitialSpheres(this.targetSphereCount);
                    this.lastSphereCount = this.targetSphereCount;
                    this.globalWarpStrengthChanged = false;

                    if (this.spheres.length === 0) {
                        this.updateGPUBuffers([], { bvhNodes: [], primitiveIndices: [] });
                        engine.resetAccumulation();
                        return;
                    }

                    if (engine.bvhWorker && !engine.isBVHBuilding) {
                        console.log("SceneManager: Attempting asynchronous BVH construction via worker.");
                        engine.isBVHBuilding = true;
                        if (engine.uiManager) engine.uiManager.setLoadingStatus(`Sending ${this.spheres.length} spheres to BVH worker...`);
                        engine.latestSphereDataForWorker = [...this.spheres];

                        const spheresForWorker = this.spheres.map((s, index) => ({
                            position: s.position, radius: s.radius, originalIndex: s.originalIndex !== undefined ? s.originalIndex : index
                        }));

                        engine.bvhUpdatePromise = new Promise((resolve, reject) => {
                            engine.bvhWorker.postMessage({ spheresData: spheresForWorker });
                            engine.bvhUpdatePromise._resolve = resolve;
                            engine.bvhUpdatePromise._reject = reject;
                        }).catch(err => {
                            console.error("SceneManager: BVH Update Promise rejected:", err);
                            this.fallbackToSyncBVH("BVH worker promise rejected.");
                        });
                    } else if (engine.isBVHBuilding) {
                        console.log("SceneManager: BVH worker is busy. Update will be processed after current build or manageSpheres needs to be called again.");
                    } else {
                        this.fallbackToSyncBVH("BVH worker not available.");
                    }
                } else {
                    this.updateRaytracerParamsUniformBuffer();
                }
            }

            fallbackToSyncBVH(reason) {
                const engine = this.novaRayEngine;
                console.log(`SceneManager: ${reason} Falling back to synchronous BVH construction.`);
                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Building BVH synchronously for ${this.spheres.length} spheres...`);
                try {
                    const bvhResult = this.buildBvhStructure(this.spheres);
                    this.updateGPUBuffers(this.spheres, bvhResult);
                    engine.resetAccumulation();
                } catch (e) {
                    console.error("Error building BVH on main thread (SceneManager fallback):", e);
                    if (engine.uiManager) engine.uiManager.displayErrorMessage(`Error building BVH (sync fallback): ${e.message}`);
                }
            }


            // --- UBO Update Methods ---
            /** Updates the camera uniform buffer with current camera state. */
            updateCameraUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.canvas || !engine.cameraUBOBuffer || !engine.resourceManager) return;
                const cameraData = new Float32Array([
                    this.camera.position[0], this.camera.position[1], this.camera.position[2], 0.0,
                    this.camera.forward[0], this.camera.forward[1], this.camera.forward[2], 0.0,
                    this.camera.right[0], this.camera.right[1], this.camera.right[2], 0.0,
                    this.camera.up[0], this.camera.up[1], this.camera.up[2], 0.0,
                    engine.canvas.width, engine.canvas.height, this.camera.aspect, this.camera.fovy,
                    this.camera.near, this.camera.far, 0.0, 0.0,
                ]);
                if (cameraData.length !== 24) console.error("SceneManager: CameraUniformBuffer size mismatch! Expected 24 floats, got", cameraData.length);
                engine.device.queue.writeBuffer(engine.cameraUBOBuffer, 0, cameraData);
            }
            /** Updates the light uniform buffer. */
            updateLightUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.lightUBOBuffer || !engine.resourceManager) return;
                const lightData = new Float32Array([
                    this.light.position[0], this.light.position[1], this.light.position[2], this.light.brightness,
                    this.light.size, 0.0, 0.0, 0.0,
                    this.light.color[0], this.light.color[1], this.light.color[2], 0.0
                ]);
                engine.device.queue.writeBuffer(engine.lightUBOBuffer, 0, lightData);
            }
            /** Updates the time uniform buffer. */
            updateTimeUniformBuffer(time, frameCount) {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.timeUBOBuffer || !engine.resourceManager) return;
                const timeData = new Float32Array([ time, parseFloat(frameCount), 0.0, 0.0 ]);
                engine.device.queue.writeBuffer(engine.timeUBOBuffer, 0, timeData);
            }
            /** Updates the water parameters uniform buffer. */
            updateWaterUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.waterUBOBuffer || !engine.resourceManager) return;
                const waterData = new Float32Array([this.waveStrength, this.waveFrequency, this.waveSpeed, 0.0]);
                engine.device.queue.writeBuffer(engine.waterUBOBuffer, 0, waterData);
            }
             /** Updates the terrain parameters uniform buffer. */
            updateTerrainUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.terrainUBOBuffer || !engine.resourceManager) return;
                const terrainData = new Float32Array([this.terrainHeightScale, this.terrainFrequency, 0.0, 0.0]);
                engine.device.queue.writeBuffer(engine.terrainUBOBuffer, 0, terrainData);
            }
            /** Updates the main raytracer parameters uniform buffer. */
            updateRaytracerParamsUniformBuffer(numMeshInstances = 0) { // numMeshInstances parameter added and used
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.raytracerUBOBuffer || !engine.resourceManager) return;
                const raytracerData = new Float32Array(12); // 12 floats = 48 bytes
                const raytracerDataUintView = new Uint32Array(raytracerData.buffer);

                raytracerDataUintView[0] = this.maxBounces;
                raytracerDataUintView[1] = this.maxRaymarchSteps;
                raytracerDataUintView[2] = this.shadowSamples;
                raytracerDataUintView[3] = this.dofSamples;

                raytracerDataUintView[4] = this.currentBvhResult.bvhNodes.length;
                raytracerDataUintView[5] = this.spheres.length; // Number of sphere entries (placeholders for BVH)
                raytracerDataUintView[6] = this.skyPreset;
                raytracerDataUintView[7] = numMeshInstances; // Store the actual number of mesh instances

                raytracerData[8] = this.globalWarpStrength;
                raytracerData[9] = this.camera.focalDistance;
                raytracerData[10] = this.camera.apertureSize;
                // raytracerData[11] is _pad1:f32, can be left as 0.0, default initialization of Float32Array is 0.

                engine.device.queue.writeBuffer(engine.raytracerUBOBuffer, 0, raytracerData);
            }

            /** Updates the cloud parameters uniform buffer. */
            updateCloudParamsUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.cloudParamsUBOBuffer || !engine.resourceManager) {
                    console.warn("SceneManager: CloudParamsUBOBuffer not ready for update.");
                    return;
                }
                const cloudData = new Float32Array(12);
                const cloudDataUintView = new Uint32Array(cloudData.buffer);

                cloudData[0] = this.cloudLayerMinY;
                cloudData[1] = this.cloudLayerMaxY;
                cloudData[2] = this.cloudNoiseScale;
                cloudData[3] = this.cloudDensityThreshold;
                cloudData[4] = this.cloudDensityMultiplier;
                cloudDataUintView[5] = this.cloudMarchSteps;
                cloudData[6] = this.cloudScatteringCoeff;
                cloudData[7] = this.cloudAbsorptionCoeff;
                cloudData[8] = this.cloudBaseColor[0];
                cloudData[9] = this.cloudBaseColor[1];
                cloudData[10] = this.cloudBaseColor[2];
                cloudData[11] = this.cloudAnimationSpeed;

                engine.device.queue.writeBuffer(engine.cloudParamsUBOBuffer, 0, cloudData);
            }

            // Setters for Cloud Parameters
            setCloudLayerMinY(value) { value = parseFloat(value); if (this.cloudLayerMinY !== value) { this.cloudLayerMinY = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudLayerMaxY(value) { value = parseFloat(value); if (this.cloudLayerMaxY !== value) { this.cloudLayerMaxY = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudNoiseScale(value) { value = parseFloat(value); if (this.cloudNoiseScale !== value) { this.cloudNoiseScale = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudDensityThreshold(value) { value = parseFloat(value); if (this.cloudDensityThreshold !== value) { this.cloudDensityThreshold = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudDensityMultiplier(value) { value = parseFloat(value); if (this.cloudDensityMultiplier !== value) { this.cloudDensityMultiplier = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudMarchSteps(value) { value = parseInt(value); if (this.cloudMarchSteps !== value) { this.cloudMarchSteps = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudScatteringCoeff(value) { value = parseFloat(value); if (this.cloudScatteringCoeff !== value) { this.cloudScatteringCoeff = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudAbsorptionCoeff(value) { value = parseFloat(value); if (this.cloudAbsorptionCoeff !== value) { this.cloudAbsorptionCoeff = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudBaseColorR(value) { value = parseFloat(value); if (this.cloudBaseColor[0] !== value) { this.cloudBaseColor[0] = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudBaseColorG(value) { value = parseFloat(value); if (this.cloudBaseColor[1] !== value) { this.cloudBaseColor[1] = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudBaseColorB(value) { value = parseFloat(value); if (this.cloudBaseColor[2] !== value) { this.cloudBaseColor[2] = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setCloudAnimationSpeed(value) { value = parseFloat(value); if (this.cloudAnimationSpeed !== value) { this.cloudAnimationSpeed = value; this.updateCloudParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }

        }
        // --- End SceneManager Definition ---

        /**
         * @class UIManager
         * @description Manages all User Interface (UI) elements, interactions, view switching,
         * and feedback mechanisms like error messages and loading statuses for NovaRay.
         * @param {NovaRayEngine} novaRayEngine - A reference to the main NovaRayEngine instance.
         */
        class UIManager {
            constructor(novaRayEngine) {
                this.novaRayEngine = novaRayEngine;
                /** @type {string} Current active view ('menu', 'loading', 'scene'). */
                this.appState = 'menu';

                // DOM Elements are cached here after initDOMElements() is called.
                this.appContainer = null;
                this.menuView = null;
                this.loadingView = null;
                this.sceneView = null;
                this.settingsPanel = null;
                this.loadingStatusP = null;
                this.errorMessageDisplay = null;
                this.startButton = null;
                // ... other DOM element properties
            }

            /** Initializes (caches) references to all relevant DOM elements. */
            initDOMElements() {
                this.appContainer = document.getElementById('app-container');
                this.menuView = document.getElementById('menu-view');
                this.loadingView = document.getElementById('loading-view');
                this.sceneView = document.getElementById('scene-view');
                this.settingsPanel = document.getElementById('settings-panel');
                this.loadingStatusP = document.getElementById('loading-status');
                this.errorMessageDisplay = document.getElementById('error-message-display');
                this.startButton = document.getElementById('start-button');
                this.settingsButton = document.getElementById('settings-button');
                this.qualityPresetSelect = document.getElementById('quality-preset');
                this.numSpheresRange = document.getElementById('num-spheres');
                this.numSpheresValueSpan = document.getElementById('num-spheres-value');
                this.maxBouncesRange = document.getElementById('max-bounces');
                this.maxBouncesValueSpan = document.getElementById('max-bounces-value');
                this.samplesPerPixelRange = document.getElementById('samples-per-pixel');
                this.samplesPerPixelValueSpan = document.getElementById('samples-per-pixel-value');
                this.applySettingsButton = document.getElementById('apply-settings-button');
                this.backToMenuButton = document.getElementById('back-to-menu-button');
                this.backToMainMenuFromSceneButton = document.getElementById('back-to-main-menu-from-scene');
                this.canvas = document.getElementById('webgpu-canvas');
                this.sceneControlsPanel = document.getElementById('scene-controls-panel');
                this.togglePanelButton = document.getElementById('toggle-panel-button');
                this.sphereCountSlider = document.getElementById('sphereCountSlider');
                this.sphereCountValue = document.getElementById('sphereCountValue');
                this.lightXSlider = document.getElementById('lightXSlider'); this.lightXValue = document.getElementById('lightXValue');
                this.lightYSlider = document.getElementById('lightYSlider'); this.lightYValue = document.getElementById('lightYValue');
                this.lightZSlider = document.getElementById('lightZSlider'); this.lightZValue = document.getElementById('lightZValue');
                this.lightBrightnessSlider = document.getElementById('lightBrightnessSlider'); this.lightBrightnessValue = document.getElementById('lightBrightnessValue');
                this.lightSizeSlider = document.getElementById('lightSizeSlider'); this.lightSizeValue = document.getElementById('lightSizeValue');
                this.sunHueSlider = document.getElementById('sunHueSlider'); this.sunHueValueSpan = document.getElementById('sunHueValue');
                this.waveStrengthSlider = document.getElementById('waveStrengthSlider'); this.waveStrengthValue = document.getElementById('waveStrengthValue');
                this.waveFrequencySlider = document.getElementById('waveFrequencySlider'); this.waveFrequencyValue = document.getElementById('waveFrequencyValue');
                this.waveSpeedSlider = document.getElementById('waveSpeedSlider'); this.waveSpeedValue = document.getElementById('waveSpeedValue');
                this.refractiveIndexSlider = document.getElementById('refractiveIndexSlider'); this.refractiveIndexValue = document.getElementById('refractiveIndexValue');
                this.warpStrengthSlider = document.getElementById('warpStrengthSlider'); this.warpStrengthValue = document.getElementById('warpStrengthValue');
                this.terrainHeightSlider = document.getElementById('terrainHeightSlider'); this.terrainHeightValue = document.getElementById('terrainHeightValue');
                this.terrainFrequencySlider = document.getElementById('terrainFrequencySlider'); this.terrainFrequencyValue = document.getElementById('terrainFrequencyValue');
                this.bouncesSlider = document.getElementById('bouncesSlider'); this.bouncesValue = document.getElementById('bouncesValue');
                this.raymarchStepsSlider = document.getElementById('raymarchStepsSlider'); this.raymarchStepsValue = document.getElementById('raymarchStepsValue');
                this.shadowSamplesSlider = document.getElementById('shadowSamplesSlider'); this.shadowSamplesValue = document.getElementById('shadowSamplesValue');
                this.dofSamplesSlider = document.getElementById('dofSamplesSlider'); this.dofSamplesValue = document.getElementById('dofSamplesValue');
                this.focalDistanceSlider = document.getElementById('focalDistanceSlider'); this.focalDistanceValue = document.getElementById('focalDistanceValue');
                this.apertureSizeSlider = document.getElementById('apertureSizeSlider'); this.apertureSizeValue = document.getElementById('apertureSizeValue');
                this.sunnyDayButton = document.getElementById('sunnyDayButton');
                this.duskButton = document.getElementById('duskButton');
                this.fpsCounterElement = document.getElementById('fps-counter');

                // Rock Controls
                this.rockCountSlider = document.getElementById('rockCountSlider');
                this.rockCountValueSpan = document.getElementById('rockCountValue');
                this.rockSubdivisionsSlider = document.getElementById('rockSubdivisionsSlider');
                this.rockSubdivisionsValueSpan = document.getElementById('rockSubdivisionsValue');
                this.rockNumScrapesSlider = document.getElementById('rockNumScrapesSlider');
                this.rockNumScrapesValueSpan = document.getElementById('rockNumScrapesValue');
                this.rockScrapeStrengthSlider = document.getElementById('rockScrapeStrengthSlider');
                this.rockScrapeStrengthValueSpan = document.getElementById('rockScrapeStrengthValue');
                this.rockScrapeRadiusMinSlider = document.getElementById('rockScrapeRadiusMinSlider');
                this.rockScrapeRadiusMinValueSpan = document.getElementById('rockScrapeRadiusMinValue');
                this.rockScrapeRadiusMaxSlider = document.getElementById('rockScrapeRadiusMaxSlider');
                this.rockScrapeRadiusMaxValueSpan = document.getElementById('rockScrapeRadiusMaxValue');
                this.rockVertexNoiseStrengthSlider = document.getElementById('rockVertexNoiseStrengthSlider');
                this.rockVertexNoiseStrengthValueSpan = document.getElementById('rockVertexNoiseStrengthValue');

                // Cloud Controls
                this.cloudLayerMinYSlider = document.getElementById('cloudLayerMinYSlider'); this.cloudLayerMinYValue = document.getElementById('cloudLayerMinYValue');
                this.cloudLayerMaxYSlider = document.getElementById('cloudLayerMaxYSlider'); this.cloudLayerMaxYValue = document.getElementById('cloudLayerMaxYValue');
                this.cloudNoiseScaleSlider = document.getElementById('cloudNoiseScaleSlider'); this.cloudNoiseScaleValue = document.getElementById('cloudNoiseScaleValue');
                this.cloudDensityThresholdSlider = document.getElementById('cloudDensityThresholdSlider'); this.cloudDensityThresholdValue = document.getElementById('cloudDensityThresholdValue');
                this.cloudDensityMultiplierSlider = document.getElementById('cloudDensityMultiplierSlider'); this.cloudDensityMultiplierValue = document.getElementById('cloudDensityMultiplierValue');
                this.cloudMarchStepsSlider = document.getElementById('cloudMarchStepsSlider'); this.cloudMarchStepsValue = document.getElementById('cloudMarchStepsValue');
                this.cloudScatteringCoeffSlider = document.getElementById('cloudScatteringCoeffSlider'); this.cloudScatteringCoeffValue = document.getElementById('cloudScatteringCoeffValue');
                this.cloudAbsorptionCoeffSlider = document.getElementById('cloudAbsorptionCoeffSlider'); this.cloudAbsorptionCoeffValue = document.getElementById('cloudAbsorptionCoeffValue');
                this.cloudColorRSlider = document.getElementById('cloudColorRSlider'); this.cloudColorRValue = document.getElementById('cloudColorRValue');
                this.cloudColorGSlider = document.getElementById('cloudColorGSlider'); this.cloudColorGValue = document.getElementById('cloudColorGValue');
                this.cloudColorBSlider = document.getElementById('cloudColorBSlider'); this.cloudColorBValue = document.getElementById('cloudColorBValue');
                this.cloudAnimationSpeedSlider = document.getElementById('cloudAnimationSpeedSlider'); this.cloudAnimationSpeedValue = document.getElementById('cloudAnimationSpeedValue');
            }

            /**
             * Switches the active view of the application.
             * @param {string} newViewId - The ID of the view to switch to ('menu', 'loading', 'scene').
             */
            switchView(newViewId) {
                this.menuView.classList.remove('active');
                this.loadingView.classList.remove('active');
                this.sceneView.classList.remove('active');
                this.settingsPanel.classList.remove('active');
                if (this.fpsCounterElement) this.fpsCounterElement.style.display = 'none';
                if (this.sceneControlsPanel) this.sceneControlsPanel.style.display = 'none';
                if (this.backToMainMenuFromSceneButton) this.backToMainMenuFromSceneButton.style.display = 'none';

                setTimeout(() => {
                    if (newViewId === 'menu') {
                        this.menuView.classList.add('active');
                        if (this.canvas) this.canvas.style.display = 'none';
                    } else if (newViewId === 'loading') {
                        this.loadingView.classList.add('active');
                        if (this.canvas) this.canvas.style.display = 'none';
                    } else if (newViewId === 'scene') {
                        this.sceneView.classList.add('active');
                        if (this.canvas) this.canvas.style.display = 'block';
                        if (this.fpsCounterElement) this.fpsCounterElement.style.display = 'block';
                        if (this.sceneControlsPanel) this.sceneControlsPanel.style.display = 'block';
                        if (this.backToMainMenuFromSceneButton) this.backToMainMenuFromSceneButton.style.display = 'block';
                        startRenderLoop();
                    }
                    this.appState = newViewId;
                    console.log(`Switched to view: ${this.appState}`);
                }, 50);
            }

            /**
             * Displays an error message to the user.
             * @param {string} message - The error message to display.
             */
            displayErrorMessage(message) {
                if (this.errorMessageDisplay) {
                    this.errorMessageDisplay.textContent = message;
                    this.errorMessageDisplay.classList.add('active');
                    setTimeout(() => {
                        this.errorMessageDisplay.classList.remove('active');
                    }, 5000);
                }
                console.error(message);
            }

            /**
             * Sets the text content of the loading status display.
             * @param {string} message - The status message to display.
             */
            setLoadingStatus(message) {
                if (this.loadingStatusP) {
                    this.loadingStatusP.textContent = message;
                }
            }

            /**
             * Helper to update the text content of a span associated with a range slider.
             * @param {HTMLInputElement} sliderElement - The range input element.
             * @param {HTMLElement} valueSpanElement - The span element to display the value.
             * @param {number} [toFixedDigits=1] - Number of decimal places for the displayed value.
             */
            updateSliderValueDisplay(sliderElement, valueSpanElement, toFixedDigits = 1) {
                if (valueSpanElement && sliderElement) {
                    valueSpanElement.textContent = parseFloat(sliderElement.value).toFixed(toFixedDigits);
                }
            }

            /**
             * Updates the FPS counter display.
             * @param {number} fpsValue - The current FPS value.
             */
            updateFPSCounter(fpsValue) {
                if (this.fpsCounterElement) {
                    this.fpsCounterElement.textContent = \`FPS: \${fpsValue.toFixed(0)}\`;
                }
            }
            /**
             * Initializes the scene control panel UI elements with values from SceneManager
             * and sets up their event listeners.
             */
            initSceneControlsUI() {
                const sm = this.novaRayEngine.sceneManager;
                if (!sm) {
                    console.warn("SceneManager not initialized, skipping UI init Scene Controls.");
                    return;
                }

                this.updateSliderValueDisplay(this.sphereCountSlider, this.sphereCountValue, 0); this.sphereCountSlider.value = sm.targetSphereCount;
                this.updateSliderValueDisplay(this.lightXSlider, this.lightXValue); this.lightXSlider.value = sm.light.position[0];
                this.updateSliderValueDisplay(this.lightYSlider, this.lightYValue); this.lightYSlider.value = sm.light.position[1];
                this.updateSliderValueDisplay(this.lightZSlider, this.lightZValue); this.lightZSlider.value = sm.light.position[2];
                this.updateSliderValueDisplay(this.lightBrightnessSlider, this.lightBrightnessValue); this.lightBrightnessSlider.value = sm.light.brightness;
                this.updateSliderValueDisplay(this.lightSizeSlider, this.lightSizeValue); this.lightSizeSlider.value = sm.light.size;
                this.updateSliderValueDisplay(this.sunHueSlider, this.sunHueValueSpan, 2); this.sunHueSlider.value = sm.sunHue;
                this.updateSliderValueDisplay(this.waveStrengthSlider, this.waveStrengthValue, 2); this.waveStrengthSlider.value = sm.waveStrength;
                this.updateSliderValueDisplay(this.waveFrequencySlider, this.waveFrequencyValue); this.waveFrequencySlider.value = sm.waveFrequency;
                this.updateSliderValueDisplay(this.waveSpeedSlider, this.waveSpeedValue, 2); this.waveSpeedSlider.value = sm.waveSpeed;
                this.updateSliderValueDisplay(this.refractiveIndexSlider, this.refractiveIndexValue, 2); this.refractiveIndexSlider.value = sm.globalRefractiveIndex;
                this.updateSliderValueDisplay(this.warpStrengthSlider, this.warpStrengthValue, 2); this.warpStrengthSlider.value = sm.globalWarpStrength;
                this.updateSliderValueDisplay(this.terrainHeightSlider, this.terrainHeightValue); this.terrainHeightSlider.value = sm.terrainHeightScale;
                this.updateSliderValueDisplay(this.terrainFrequencySlider, this.terrainFrequencyValue, 2); this.terrainFrequencySlider.value = sm.terrainFrequency;
                this.updateSliderValueDisplay(this.bouncesSlider, this.bouncesValue, 0); this.bouncesSlider.value = sm.maxBounces;
                this.updateSliderValueDisplay(this.raymarchStepsSlider, this.raymarchStepsValue, 0); this.raymarchStepsSlider.value = sm.maxRaymarchSteps;
                this.updateSliderValueDisplay(this.shadowSamplesSlider, this.shadowSamplesValue, 0); this.shadowSamplesSlider.value = sm.shadowSamples;
                this.updateSliderValueDisplay(this.dofSamplesSlider, this.dofSamplesValue, 0); this.dofSamplesSlider.value = sm.dofSamples;
                this.updateSliderValueDisplay(this.focalDistanceSlider, this.focalDistanceValue); this.focalDistanceSlider.value = sm.camera.focalDistance;
                this.updateSliderValueDisplay(this.apertureSizeSlider, this.apertureSizeValue, 2); this.apertureSizeSlider.value = sm.camera.apertureSize;

                if (sm.skyPreset === 0) { this.sunnyDayButton.classList.add('active'); this.duskButton.classList.remove('active'); }
                else { this.duskButton.classList.add('active'); this.sunnyDayButton.classList.remove('active'); }

                // Initialize Rock Controls UI
                this.updateSliderValueDisplay(this.rockCountSlider, this.rockCountValueSpan, 0); this.rockCountSlider.value = sm.rockCount;
                this.updateSliderValueDisplay(this.rockSubdivisionsSlider, this.rockSubdivisionsValueSpan, 0); this.rockSubdivisionsSlider.value = sm.rockSubdivisions;
                this.updateSliderValueDisplay(this.rockNumScrapesSlider, this.rockNumScrapesValueSpan, 0); this.rockNumScrapesSlider.value = sm.rockNumScrapes;
                this.updateSliderValueDisplay(this.rockScrapeStrengthSlider, this.rockScrapeStrengthValueSpan, 2); this.rockScrapeStrengthSlider.value = sm.rockScrapeConfig.strength;
                this.updateSliderValueDisplay(this.rockScrapeRadiusMinSlider, this.rockScrapeRadiusMinValueSpan, 2); this.rockScrapeRadiusMinSlider.value = sm.rockScrapeConfig.radiusMin;
                this.updateSliderValueDisplay(this.rockScrapeRadiusMaxSlider, this.rockScrapeRadiusMaxValueSpan, 2); this.rockScrapeRadiusMaxSlider.value = sm.rockScrapeConfig.radiusMax;
                this.updateSliderValueDisplay(this.rockVertexNoiseStrengthSlider, this.rockVertexNoiseStrengthValueSpan, 3); this.rockVertexNoiseStrengthSlider.value = sm.rockVertexNoiseStrength;

                // Initialize Cloud Controls UI
                this.updateSliderValueDisplay(this.cloudLayerMinYSlider, this.cloudLayerMinYValue); this.cloudLayerMinYSlider.value = sm.cloudLayerMinY;
                this.updateSliderValueDisplay(this.cloudLayerMaxYSlider, this.cloudLayerMaxYValue); this.cloudLayerMaxYSlider.value = sm.cloudLayerMaxY;
                this.updateSliderValueDisplay(this.cloudNoiseScaleSlider, this.cloudNoiseScaleValue, 3); this.cloudNoiseScaleSlider.value = sm.cloudNoiseScale;
                this.updateSliderValueDisplay(this.cloudDensityThresholdSlider, this.cloudDensityThresholdValue, 2); this.cloudDensityThresholdSlider.value = sm.cloudDensityThreshold;
                this.updateSliderValueDisplay(this.cloudDensityMultiplierSlider, this.cloudDensityMultiplierValue); this.cloudDensityMultiplierSlider.value = sm.cloudDensityMultiplier;
                this.updateSliderValueDisplay(this.cloudMarchStepsSlider, this.cloudMarchStepsValue, 0); this.cloudMarchStepsSlider.value = sm.cloudMarchSteps;
                this.updateSliderValueDisplay(this.cloudScatteringCoeffSlider, this.cloudScatteringCoeffValue, 2); this.cloudScatteringCoeffSlider.value = sm.cloudScatteringCoeff;
                this.updateSliderValueDisplay(this.cloudAbsorptionCoeffSlider, this.cloudAbsorptionCoeffValue, 2); this.cloudAbsorptionCoeffSlider.value = sm.cloudAbsorptionCoeff;
                this.updateSliderValueDisplay(this.cloudColorRSlider, this.cloudColorRValue, 2); this.cloudColorRSlider.value = sm.cloudBaseColor[0];
                this.updateSliderValueDisplay(this.cloudColorGSlider, this.cloudColorGValue, 2); this.cloudColorGSlider.value = sm.cloudBaseColor[1];
                this.updateSliderValueDisplay(this.cloudColorBSlider, this.cloudColorBValue, 2); this.cloudColorBSlider.value = sm.cloudBaseColor[2];
                this.updateSliderValueDisplay(this.cloudAnimationSpeedSlider, this.cloudAnimationSpeedValue, 3); this.cloudAnimationSpeedSlider.value = sm.cloudAnimationSpeed;
            }
            /**
             * Initializes all UI event listeners for the application.
             * This includes main menu, settings panel, scene controls, and canvas interactions.
             */
            initEventListeners() {
                const sm = this.novaRayEngine.sceneManager; // Alias

                this.startButton.addEventListener('click', () => applySettingsAndStart());
                this.settingsButton.addEventListener('click', () => {
                    this.menuView.classList.remove('active');
                    this.settingsPanel.classList.add('active');
                });
                this.backToMenuButton.addEventListener('click', () => {
                    this.settingsPanel.classList.remove('active');
                    this.menuView.classList.add('active');
                });
                this.applySettingsButton.addEventListener('click', () => applySettingsAndStart());

                this.numSpheresRange.addEventListener('input', (e) => { this.numSpheresValueSpan.textContent = e.target.value; });
                this.maxBouncesRange.addEventListener('input', (e) => { this.maxBouncesValueSpan.textContent = e.target.value; });
                this.samplesPerPixelRange.addEventListener('input', (e) => { this.samplesPerPixelValueSpan.textContent = e.target.value; });

                this.qualityPresetSelect.addEventListener('change', (e) => {
                    const preset = e.target.value;
                    if (preset === 'low') {
                        this.numSpheresRange.value = 5; this.maxBouncesRange.value = 2; this.samplesPerPixelRange.value = 4;
                    } else if (preset === 'medium') {
                        this.numSpheresRange.value = 10; this.maxBouncesRange.value = 4; this.samplesPerPixelRange.value = 16;
                    } else if (preset === 'high') {
                        this.numSpheresRange.value = 50; this.maxBouncesRange.value = 8; this.samplesPerPixelRange.value = 32;
                    }
                    this.numSpheresValueSpan.textContent = this.numSpheresRange.value;
                    this.maxBouncesValueSpan.textContent = this.maxBouncesRange.value;
                    this.samplesPerPixelValueSpan.textContent = this.samplesPerPixelRange.value;
                });

                this.togglePanelButton.addEventListener('click', () => {
                    this.sceneControlsPanel.classList.toggle('collapsed');
                    this.togglePanelButton.textContent = this.sceneControlsPanel.classList.contains('collapsed') ? '>' : '<';
                });

                this.sphereCountSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.sphereCountSlider, this.sphereCountValue, 0); sm.setTargetSphereCount(v); });
                this.lightXSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightXSlider, this.lightXValue); sm.setLightPosition('x', v); });
                this.lightYSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightYSlider, this.lightYValue); sm.setLightPosition('y', v); });
                this.lightZSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightZSlider, this.lightZValue); sm.setLightPosition('z', v); });
                this.lightBrightnessSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightBrightnessSlider, this.lightBrightnessValue); sm.setLightBrightness(v); });
                this.lightSizeSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightSizeSlider, this.lightSizeValue); sm.setLightSize(v); });
                this.sunHueSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.sunHueSlider, this.sunHueValueSpan, 2); sm.setSunHue(v); });
                this.waveStrengthSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.waveStrengthSlider, this.waveStrengthValue, 2); sm.setWaveStrength(v); });
                this.waveFrequencySlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.waveFrequencySlider, this.waveFrequencyValue); sm.setWaveFrequency(v); });
                this.waveSpeedSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.waveSpeedSlider, this.waveSpeedValue, 2); sm.setWaveSpeed(v); });
                this.refractiveIndexSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.refractiveIndexSlider, this.refractiveIndexValue, 2); sm.setGlobalRefractiveIndex(v); });
                this.warpStrengthSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.warpStrengthSlider, this.warpStrengthValue, 2); sm.setGlobalWarpStrength(v); });
                this.terrainHeightSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.terrainHeightSlider, this.terrainHeightValue); sm.setTerrainHeightScale(v); });
                this.terrainFrequencySlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.terrainFrequencySlider, this.terrainFrequencyValue, 2); sm.setTerrainFrequency(v); });
                this.bouncesSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.bouncesSlider, this.bouncesValue, 0); sm.setMaxBounces(v); });
                this.raymarchStepsSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.raymarchStepsSlider, this.raymarchStepsValue, 0); sm.setMaxRaymarchSteps(v); });
                this.shadowSamplesSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.shadowSamplesSlider, this.shadowSamplesValue, 0); sm.setShadowSamples(v); });
                this.dofSamplesSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.dofSamplesSlider, this.dofSamplesValue, 0); sm.setDofSamples(v); });
                this.focalDistanceSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.focalDistanceSlider, this.focalDistanceValue); sm.setFocalDistance(v); });
                this.apertureSizeSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.apertureSizeSlider, this.apertureSizeValue, 2); sm.setApertureSize(v); });
                this.sunnyDayButton.addEventListener('click', () => { sm.setSkyPreset(0); this.sunnyDayButton.classList.add('active'); this.duskButton.classList.remove('active'); });
                this.duskButton.addEventListener('click', () => { sm.setSkyPreset(1); this.duskButton.classList.add('active'); this.sunnyDayButton.classList.remove('active'); });

                // Rock Control Event Listeners
                this.rockCountSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.rockCountSlider, this.rockCountValueSpan, 0); sm.setRockCount(v); });
                this.rockSubdivisionsSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.rockSubdivisionsSlider, this.rockSubdivisionsValueSpan, 0); sm.setRockSubdivisions(v); });
                this.rockNumScrapesSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.rockNumScrapesSlider, this.rockNumScrapesValueSpan, 0); sm.setRockNumScrapes(v); });
                this.rockScrapeStrengthSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.rockScrapeStrengthSlider, this.rockScrapeStrengthValueSpan, 2); sm.setRockScrapeStrength(v); });
                this.rockScrapeRadiusMinSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.rockScrapeRadiusMinSlider, this.rockScrapeRadiusMinValueSpan, 2); sm.setRockScrapeRadiusMin(v); });
                this.rockScrapeRadiusMaxSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.rockScrapeRadiusMaxSlider, this.rockScrapeRadiusMaxValueSpan, 2); sm.setRockScrapeRadiusMax(v); });
                this.rockVertexNoiseStrengthSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.rockVertexNoiseStrengthSlider, this.rockVertexNoiseStrengthValueSpan, 3); sm.setRockVertexNoiseStrength(v); });

                // Cloud Control Event Listeners
                this.cloudLayerMinYSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudLayerMinYSlider, this.cloudLayerMinYValue); sm.setCloudLayerMinY(e.target.value); });
                this.cloudLayerMaxYSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudLayerMaxYSlider, this.cloudLayerMaxYValue); sm.setCloudLayerMaxY(e.target.value); });
                this.cloudNoiseScaleSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudNoiseScaleSlider, this.cloudNoiseScaleValue, 3); sm.setCloudNoiseScale(e.target.value); });
                this.cloudDensityThresholdSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudDensityThresholdSlider, this.cloudDensityThresholdValue, 2); sm.setCloudDensityThreshold(e.target.value); });
                this.cloudDensityMultiplierSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudDensityMultiplierSlider, this.cloudDensityMultiplierValue); sm.setCloudDensityMultiplier(e.target.value); });
                this.cloudMarchStepsSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudMarchStepsSlider, this.cloudMarchStepsValue, 0); sm.setCloudMarchSteps(e.target.value); });
                this.cloudScatteringCoeffSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudScatteringCoeffSlider, this.cloudScatteringCoeffValue, 2); sm.setCloudScatteringCoeff(e.target.value); });
                this.cloudAbsorptionCoeffSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudAbsorptionCoeffSlider, this.cloudAbsorptionCoeffValue, 2); sm.setCloudAbsorptionCoeff(e.target.value); });
                this.cloudColorRSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudColorRSlider, this.cloudColorRValue, 2); sm.setCloudBaseColorR(e.target.value); });
                this.cloudColorGSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudColorGSlider, this.cloudColorGValue, 2); sm.setCloudBaseColorG(e.target.value); });
                this.cloudColorBSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudColorBSlider, this.cloudColorBValue, 2); sm.setCloudBaseColorB(e.target.value); });
                this.cloudAnimationSpeedSlider.addEventListener('input', (e) => { this.updateSliderValueDisplay(this.cloudAnimationSpeedSlider, this.cloudAnimationSpeedValue, 3); sm.setCloudAnimationSpeed(e.target.value); });

                this.backToMainMenuFromSceneButton.addEventListener('click', () => {
                    if (this.novaRayEngine.animationFrameId) {
                        cancelAnimationFrame(this.novaRayEngine.animationFrameId);
                        this.novaRayEngine.animationFrameId = null;
                    }
                    this.switchView('menu');
                });

                this.setupCanvasEventListeners();
            }

            /** Sets up mouse and keyboard event listeners for the main canvas (camera controls). */
            setupCanvasEventListeners() {
                if (!this.canvas) {
                    console.error("UIManager: Canvas element not found for event listeners setup.");
                    return;
                }
                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.appState === 'scene') {
                        this.novaRayEngine.isMouseDown = true;
                        this.novaRayEngine.lastMouseX = e.clientX;
                        this.novaRayEngine.lastMouseY = e.clientY;
                        this.canvas.requestPointerLock = this.canvas.requestPointerLock || this.canvas.mozRequestPointerLock;
                        this.canvas.requestPointerLock();
                        this.canvas.style.cursor = 'grabbing';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.appState === 'scene' && this.novaRayEngine.isMouseDown) {
                        this.novaRayEngine.isMouseDown = false;
                        if (document.pointerLockElement === this.canvas) {
                            document.exitPointerLock();
                        }
                        this.canvas.style.cursor = 'grab';
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.appState === 'scene' && document.pointerLockElement === this.canvas) {
                        const movementX = e.movementX || e.mozMovementX || 0;
                        const movementY = e.movementY || e.mozMovementY || 0;
                        this.novaRayEngine.sceneManager.rotateCamera(-movementX, -movementY);
                    }
                });

                document.addEventListener('keydown', (e) => {
                    this.novaRayEngine.keysPressed[e.key.toLowerCase()] = true;
                });
                document.addEventListener('keyup', (e) => {
                    this.novaRayEngine.keysPressed[e.key.toLowerCase()] = false;
                });
                 window.addEventListener('resize', () => {
                    if (NovaRayEngine && NovaRayEngine.device) {
                        resizeCanvasAndAssets();
                    }
                });
            }
        }
        // --- End UIManager Definition ---

        /**
         * @class ProceduralMeshGenerator
         * @description Generates procedural meshes like icospheres.
         */
        class ProceduralMeshGenerator {
            // --- Static Vector Math Utilities ---
            static vec3_create() {
                return [0, 0, 0];
            }

            static vec3_dot(v1, v2) {
                return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
            }

            static vec3_subtract(out, v1, v2) {
                out[0] = v1[0] - v2[0];
                out[1] = v1[1] - v2[1];
                out[2] = v1[2] - v2[2];
                return out;
            }

            static vec3_add(out, v1, v2) { // Added for completeness, useful for projection
                out[0] = v1[0] + v2[0];
                out[1] = v1[1] + v2[1];
                out[2] = v1[2] + v2[2];
                return out;
            }

            static vec3_scale(out, v, s) { // Added for completeness, useful for projection
                out[0] = v[0] * s;
                out[1] = v[1] * s;
                out[2] = v[2] * s;
                return out;
            }

            static vec3_scaleAndAdd(out, v1, v2, scale) {
                out[0] = v1[0] + v2[0] * scale;
                out[1] = v1[1] + v2[1] * scale;
                out[2] = v1[2] + v2[2] * scale;
                return out;
            }

            static vec3_copy(out, v) {
                out[0] = v[0];
                out[1] = v[1];
                out[2] = v[2];
                return out;
            }

            static vec3_normalize(out, v) {
                let len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
                if (len > 0) {
                    len = 1 / Math.sqrt(len);
                    out[0] = v[0] * len;
                    out[1] = v[1] * len;
                    out[2] = v[2] * len;
                } else {
                    out[0] = 0;
                    out[1] = 0;
                    out[2] = 0;
                }
                return out;
            }

            static vec3_squaredDistance(v1, v2) {
                const dx = v1[0] - v2[0];
                const dy = v1[1] - v2[1];
                const dz = v1[2] - v2[2];
                return dx*dx + dy*dy + dz*dz;
            }

            constructor() {
                console.log("ProceduralMeshGenerator initialized.");
            }

            /**
             * Generates vertices and indices for an icosphere.
             * @param {number} subdivisions - Number of times to subdivide the icosahedron.
             * @returns {{positions: Float32Array, indices: Uint32Array}}
             */
            generateIcosphere(subdivisions = 0) {
                const t = (1.0 + Math.sqrt(5.0)) / 2.0;

                let vertices = [
                    [-1,  t,  0], [ 1,  t,  0], [-1, -t,  0], [ 1, -t,  0],
                    [ 0, -1,  t], [ 0,  1,  t], [ 0, -1, -t], [ 0,  1, -t],
                    [ t,  0, -1], [ t,  0,  1], [-t,  0, -1], [-t,  0,  1]
                ];

                // Normalize initial vertices to unit sphere
                vertices = vertices.map(v => {
                    const length = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
                    return [v[0]/length, v[1]/length, v[2]/length];
                });

                let faces = [
                    [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                    [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                    [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                    [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
                ];

                const midpointCache = new Map();
                const getMidpoint = (p1Idx, p2Idx) => {
                    const sortedIndices = [Math.min(p1Idx, p2Idx), Math.max(p1Idx, p2Idx)];
                    const cacheKey = `${sortedIndices[0]}-${sortedIndices[1]}`;

                    if (midpointCache.has(cacheKey)) {
                        return midpointCache.get(cacheKey);
                    }

                    const v1 = vertices[p1Idx];
                    const v2 = vertices[p2Idx];
                    const mid = [
                        (v1[0] + v2[0]) / 2.0,
                        (v1[1] + v2[1]) / 2.0,
                        (v1[2] + v2[2]) / 2.0
                    ];

                    const length = Math.sqrt(mid[0]*mid[0] + mid[1]*mid[1] + mid[2]*mid[2]);
                    const normalizedMid = [mid[0]/length, mid[1]/length, mid[2]/length];

                    vertices.push(normalizedMid);
                    const newIdx = vertices.length - 1;
                    midpointCache.set(cacheKey, newIdx);
                    return newIdx;
                };

                for (let i = 0; i < subdivisions; i++) {
                    const newFaces = [];
                    midpointCache.clear(); // Clear cache for each subdivision level if vertices array is rebuilt per level
                                       // Or, if vertices array is appended globally, cache should persist.
                                       // Current implementation appends globally, so cache should persist.

                    for (const face of faces) {
                        const v0 = face[0];
                        const v1 = face[1];
                        const v2 = face[2];

                        const m01 = getMidpoint(v0, v1);
                        const m12 = getMidpoint(v1, v2);
                        const m20 = getMidpoint(v2, v0);

                        newFaces.push([v0, m01, m20]);
                        newFaces.push([v1, m12, m01]);
                        newFaces.push([v2, m20, m12]);
                        newFaces.push([m01, m12, m20]);
                    }
                    faces = newFaces;
                }

                const positions = new Float32Array(vertices.length * 3);
                for (let i = 0; i < vertices.length; i++) {
                    positions[i * 3 + 0] = vertices[i][0];
                    positions[i * 3 + 1] = vertices[i][1];
                    positions[i * 3 + 2] = vertices[i][2];
                }

                const indices = new Uint32Array(faces.length * 3);
                for (let i = 0; i < faces.length; i++) {
                    indices[i * 3 + 0] = faces[i][0];
                    indices[i * 3 + 1] = faces[i][1];
                    indices[i * 3 + 2] = faces[i][2];
                }

                return { positions, indices };
            }

            /**
             * Calculates the adjacent vertices for each vertex in a mesh.
             * @param {Float32Array} positions - Flat array of vertex positions.
             * @param {Uint32Array} indices - Flat array of triangle indices.
             * @returns {Array<Array<number>>} An array where each element is an array of neighboring vertex indices.
             */
            getNeighbours(positions, indices) {
                const numVertices = positions.length / 3;
                const adjacencySets = Array.from({ length: numVertices }, () => new Set());

                for (let i = 0; i < indices.length; i += 3) {
                    const v0 = indices[i];
                    const v1 = indices[i + 1];
                    const v2 = indices[i + 2];

                    adjacencySets[v0].add(v1);
                    adjacencySets[v0].add(v2);

                    adjacencySets[v1].add(v0);
                    adjacencySets[v1].add(v2);

                    adjacencySets[v2].add(v0);
                    adjacencySets[v2].add(v1);
                }

                const adjacentVertices = Array.from({ length: numVertices }, () => []);
                for (let i = 0; i < numVertices; i++) {
                    adjacentVertices[i] = Array.from(adjacencySets[i]);
                }
                return adjacentVertices;
            }

            /**
             * Projects a point onto a plane.
             * @static
             * @param {number[]} planeNormal - The normal vector of the plane (3-element array).
             * @param {number[]} pointOnPlane - A point lying on the plane (3-element array).
             * @param {number[]} pointToProject - The point to project onto the plane (3-element array).
             * @returns {number[]} The projected point (3-element array).
             */
            static project(planeNormal, pointOnPlane, pointToProject) {
                const PM = ProceduralMeshGenerator; // Alias for static methods

                const tempVec = PM.vec3_create();
                PM.vec3_subtract(tempVec, pointOnPlane, pointToProject); // tempVec = pointOnPlane - pointToProject

                const numerator = PM.vec3_dot(planeNormal, tempVec);
                const denominator = PM.vec3_dot(planeNormal, planeNormal);

                if (denominator === 0) { // Avoid division by zero if planeNormal is a zero vector
                    console.warn("ProceduralMeshGenerator.project: planeNormal is a zero vector.");
                    return PM.vec3_copy(PM.vec3_create(), pointToProject); // Or return pointToProject, or handle error
                }

                const t = numerator / denominator;

                const scaledNormal = PM.vec3_create();
                PM.vec3_scale(scaledNormal, planeNormal, t); // scaledNormal = t * planeNormal

                const projectedPoint = PM.vec3_create();
                PM.vec3_add(projectedPoint, pointToProject, scaledNormal); // projectedPoint = pointToProject + scaledNormal

                return projectedPoint;
            }

            /**
             * Modifies vertex positions and normals by "scraping" a planar area.
             * @param {Float32Array} vertexPositions - Flat array of vertex coordinates (modified in place).
             * @param {Float32Array} vertexNormals - Flat array of vertex normals (modified in place).
             * @param {Array<Array<number>>} precomputedNeighbours - Adjacency list for vertices.
             * @param {number} centerVertexIndex - Index of the vertex to start the scrape from.
             * @param {number} scrapeStrength - How much to displace the scraping plane.
             * @param {number} scrapeRadius - Radius of effect for the scrape.
             */
            scrape(vertexPositions, vertexNormals, precomputedNeighbours, centerVertexIndex, scrapeStrength, scrapeRadius) {
                const PM = ProceduralMeshGenerator; // Alias for static methods
                const numVertices = vertexPositions.length / 3;

                const centerPosition = PM.vec3_create();
                centerPosition[0] = vertexPositions[centerVertexIndex * 3];
                centerPosition[1] = vertexPositions[centerVertexIndex * 3 + 1];
                centerPosition[2] = vertexPositions[centerVertexIndex * 3 + 2];

                const planeNormal = PM.vec3_create(); // Normal of the scraping plane
                planeNormal[0] = vertexNormals[centerVertexIndex * 3];
                planeNormal[1] = vertexNormals[centerVertexIndex * 3 + 1];
                planeNormal[2] = vertexNormals[centerVertexIndex * 3 + 2];
                PM.vec3_normalize(planeNormal, planeNormal);


                const r0 = PM.vec3_create(); // A point on the displaced plane
                const scaledNormalOffset = PM.vec3_create();
                PM.vec3_scale(scaledNormalOffset, planeNormal, -scrapeStrength); // -planeNormal * scrapeStrength
                PM.vec3_add(r0, centerPosition, scaledNormalOffset); // r0 = centerPosition - planeNormal * scrapeStrength

                const scrapeRadiusSq = scrapeRadius * scrapeRadius;
                const traversed = new Array(numVertices).fill(false);
                const stack = [centerVertexIndex];

                let currentPosition = PM.vec3_create();
                let projectedP = PM.vec3_create();

                while (stack.length > 0) {
                    const currentIndex = stack.pop();

                    if (traversed[currentIndex]) {
                        continue;
                    }
                    traversed[currentIndex] = true;

                    currentPosition[0] = vertexPositions[currentIndex * 3];
                    currentPosition[1] = vertexPositions[currentIndex * 3 + 1];
                    currentPosition[2] = vertexPositions[currentIndex * 3 + 2];

                    PM.project(planeNormal, r0, currentPosition, projectedP); // project currentPosition onto the plane r0, n

                    if (PM.vec3_squaredDistance(projectedP, r0) < scrapeRadiusSq) {
                        vertexPositions[currentIndex * 3]     = projectedP[0];
                        vertexPositions[currentIndex * 3 + 1] = projectedP[1];
                        vertexPositions[currentIndex * 3 + 2] = projectedP[2];

                        // Update normals to align with the scrape plane normal in the affected area
                        vertexNormals[currentIndex * 3]     = planeNormal[0];
                        vertexNormals[currentIndex * 3 + 1] = planeNormal[1];
                        vertexNormals[currentIndex * 3 + 2] = planeNormal[2];

                        const neighbours = precomputedNeighbours[currentIndex];
                        if (neighbours) {
                            for (const neighbourIndex of neighbours) {
                                if (!traversed[neighbourIndex]) {
                                    stack.push(neighbourIndex);
                                }
                            }
                        }
                    }
                }
            }

            /**
             * Displaces vertices along their normals by a random amount.
             * @param {Float32Array} vertexPositions - Flat array of vertex coordinates (modified in place).
             * @param {Float32Array} vertexNormals - Flat array of vertex normals.
             * @param {number} noiseStrength - Multiplier for the displacement.
             */
            displaceVerticesWithNoise(vertexPositions, vertexNormals, noiseStrength) {
                const numVertices = vertexPositions.length / 3;
                let normal = ProceduralMeshGenerator.vec3_create();

                for (let i = 0; i < numVertices; i++) {
                    normal[0] = vertexNormals[i * 3];
                    normal[1] = vertexNormals[i * 3 + 1];
                    normal[2] = vertexNormals[i * 3 + 2];
                    // No need to normalize here if input normals are already unit vectors.

                    let randomNoiseValue = (Math.random() - 0.5) * 2.0; // [-1, 1]

                    vertexPositions[i * 3 + 0] += normal[0] * randomNoiseValue * noiseStrength;
                    vertexPositions[i * 3 + 1] += normal[1] * randomNoiseValue * noiseStrength;
                    vertexPositions[i * 3 + 2] += normal[2] * randomNoiseValue * noiseStrength;
                }
            }

            /**
             * Generates a rock-like procedural mesh.
             * @param {object} config - Configuration object.
             * @param {number} [config.subdivisions=0] - Icosphere subdivisions.
             * @param {number} [config.numScrapes=10] - Number of scrape operations.
             * @param {number} [config.scrapeStrength=0.1] - Base strength of scrapes.
             * @param {number} [config.scrapeRadiusMin=0.4] - Minimum radius for scrapes.
             * @param {number} [config.scrapeRadiusMax=0.8] - Maximum radius for scrapes.
             * @param {number} [config.noiseStrength=0.05] - Strength of final noise displacement.
             * @returns {{positions: Float32Array, indices: Uint32Array, normals: Float32Array}}
             */
            generateRock(config = {}) {
                const subdivisions = config.subdivisions === undefined ? 1 : config.subdivisions; // Default to 1 for a more rock-like base
                const numScrapes = config.numScrapes === undefined ? 10 : config.numScrapes;
                const scrapeStrengthBase = config.scrapeStrength === undefined ? 0.1 : config.scrapeStrength;
                const scrapeRadiusMin = config.scrapeRadiusMin === undefined ? 0.3 : config.scrapeRadiusMin;
                const scrapeRadiusMax = config.scrapeRadiusMax === undefined ? 0.7 : config.scrapeRadiusMax;
                const noiseStrength = config.noiseStrength === undefined ? 0.02 : config.noiseStrength;

                const icosphereData = this.generateIcosphere(subdivisions);

                // Make copies to work on, as generateIcosphere returns fresh arrays
                // but scrape and displaceVerticesWithNoise modify in-place.
                const vertexPositions = new Float32Array(icosphereData.positions);
                const vertexNormals = new Float32Array(icosphereData.positions.length); // Initialize with same size

                // Initialize normals (for a sphere, normal is same as position if centered at origin and unit radius)
                // And then normalize them, as scraping might alter positions making them non-unit.
                for (let i = 0; i < vertexPositions.length / 3; i++) {
                    const px = vertexPositions[i*3];
                    const py = vertexPositions[i*3+1];
                    const pz = vertexPositions[i*3+2];
                    const len = Math.sqrt(px*px + py*py + pz*pz);
                    if (len > 0) {
                        vertexNormals[i*3]   = px/len;
                        vertexNormals[i*3+1] = py/len;
                        vertexNormals[i*3+2] = pz/len;
                    } else { // Should not happen for icosphere from generateIcosphere
                        vertexNormals[i*3]   = 0;
                        vertexNormals[i*3+1] = 1;
                        vertexNormals[i*3+2] = 0;
                    }
                }

                const adjacentVertices = this.getNeighbours(vertexPositions, icosphereData.indices);
                const numVertices = vertexPositions.length / 3;

                for (let i = 0; i < numScrapes; i++) {
                    const centerVertexIndex = Math.floor(Math.random() * numVertices);
                    const currentScrapeRadius = scrapeRadiusMin + Math.random() * (scrapeRadiusMax - scrapeRadiusMin);
                    const currentScrapeStrength = scrapeStrengthBase + (Math.random() - 0.5) * (scrapeStrengthBase * 0.5); // +/- 25% of base

                    this.scrape(vertexPositions, vertexNormals, adjacentVertices, centerVertexIndex, currentScrapeStrength, currentScrapeRadius);
                }

                if (noiseStrength > 0) {
                    this.displaceVerticesWithNoise(vertexPositions, vertexNormals, noiseStrength);
                }

                // Recalculate normals after all deformations (optional, but good for final shading)
                // For simplicity, this step is omitted here but would typically involve averaging face normals.
                // The scrape operation already updates normals in the scraped area to the plane normal.
                // The noise displacement slightly moves vertices off these scraped planes.

                return { positions: vertexPositions, indices: icosphereData.indices, normals: vertexNormals };
            }
        }
        // --- End ProceduralMeshGenerator Definition ---

        // Global instance of the engine
        const NovaRayEngine = window.NovaRayEngine;

        // --- Global UI Access (Legacy, for applySettingsAndStart) ---
        const globalCanvas = document.getElementById('webgpu-canvas');
        const globalLoadingStatusP = document.getElementById('loading-status');
        const globalErrorMessageDisplay = document.getElementById('error-message-display');


        /**
         * Main application orchestrator for settings application and starting the engine.
         * This function is typically called from UI event listeners.
         * @async
         */
        async function applySettingsAndStart() {
            if (!NovaRayEngine.uiManager) {
                NovaRayEngine.uiManager = new UIManager(NovaRayEngine);
                NovaRayEngine.uiManager.initDOMElements();
            }
            NovaRayEngine.uiManager.switchView('loading');

            const success = await NovaRayEngine.initialize(globalCanvas, globalLoadingStatusP, globalErrorMessageDisplay);

            if (!success) {
                NovaRayEngine.uiManager.switchView('menu');
            }
        }

        /**
         * @class AABB
         * @description Axis-Aligned Bounding Box helper class for BVH construction.
         * Used by both the main thread (for synchronous BVH fallback) and the BVH worker.
         */
        class AABB {
            constructor(min, max) { this.min = min; this.max = max; }
            expand(point) { this.min[0] = Math.min(this.min[0], point[0]); this.min[1] = Math.min(this.min[1], point[1]); this.min[2] = Math.min(this.min[2], point[2]); this.max[0] = Math.max(this.max[0], point[0]); this.max[1] = Math.max(this.max[1], point[1]); this.max[2] = Math.max(this.max[2], point[2]); }
            union(other) { this.min[0] = Math.min(this.min[0], other.min[0]); this.min[1] = Math.min(this.min[1], other.min[1]); this.min[2] = Math.min(this.min[2], other.min[2]); this.max[0] = Math.max(this.max[0], other.max[0]); this.max[1] = Math.max(this.max[1], other.max[1]); this.max[2] = Math.max(this.max[2], other.max[2]); }
            centroid() { return [(this.min[0] + this.max[0]) * 0.5, (this.min[1] + this.max[1]) * 0.5, (this.min[2] + this.max[2]) * 0.5]; }
            longestAxis() { const dx = this.max[0] - this.min[0]; const dy = this.max[1] - this.min[1]; const dz = this.max[2] - this.min[2]; if (dx > dy && dx > dz) return 0; if (dy > dz) return 1; return 2; }
        }
        /**
         * @class BvhNode
         * @description Represents a node in the Bounding Volume Hierarchy.
         * Used by both the main thread (for synchronous BVH fallback) and the BVH worker.
         */
        class BvhNode { constructor() { this.minBounds = [Infinity, Infinity, Infinity]; this.maxBounds = [-Infinity, -Infinity, -Infinity]; this.isLeaf = 0; this.primitiveCount = 0; this.leftChildOrFirstPrimitiveIndex = 0; } }
        const BVH_LEAF_SIZE = 4; // Maximum primitives in a BVH leaf node.
        /** Builds the BVH recursively. This is a global helper for synchronous BVH construction. */
        function buildBvh(primitives, flattenedNodes, primitiveIndices, offset, count) {
            let bbox = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
            for (let i = offset; i < offset + count; ++i) { const p = primitives[primitiveIndices[i]]; bbox.expand([p.position[0] - p.radius, p.position[1] - p.radius, p.position[2] - p.radius]); bbox.expand([p.position[0] + p.radius, p.position[1] + p.radius, p.position[2] + p.radius]); }
            const nodeIndex = flattenedNodes.length; const node = new BvhNode(); node.minBounds = bbox.min; node.maxBounds = bbox.max; flattenedNodes.push(node);
            if (count <= BVH_LEAF_SIZE) { node.isLeaf = 1; node.primitiveCount = count; node.leftChildOrFirstPrimitiveIndex = offset;  } else {
                const axis = bbox.longestAxis(); const pivot = bbox.centroid()[axis]; let left = offset; let right = offset + count - 1;
                while (left <= right) { while (left <= right && primitives[primitiveIndices[left]].position[axis] < pivot) left++; while (left <= right && primitives[primitiveIndices[right]].position[axis] >= pivot) right--; if (left < right) { [primitiveIndices[left], primitiveIndices[right]] = [primitiveIndices[right], primitiveIndices[left]]; left++; right--; } }
                let mid = left; if (mid === offset || mid === offset + count) mid = offset + Math.floor(count / 2);
                const leftCount = mid - offset; const rightCount = count - leftCount;
                node.isLeaf = 0; node.primitiveCount = 0; node.leftChildOrFirstPrimitiveIndex = flattenedNodes.length;
                buildBvh(primitives, flattenedNodes, primitiveIndices, offset, leftCount); buildBvh(primitives, flattenedNodes, primitiveIndices, mid, rightCount);
            }
            flattenedNodes[nodeIndex] = node; return nodeIndex;
        }

        /** Handles canvas resizing and recreation of dependent GPU resources. This is a global function that operates on the global NovaRayEngine instance. */
        function resizeCanvasAndAssets() {
            let newWidth = window.innerWidth * window.devicePixelRatio;
            let newHeight = window.innerHeight * window.devicePixelRatio;
            const MAX_CANVAS_DIMENSION = 1920;

            if (newWidth > MAX_CANVAS_DIMENSION || newHeight > MAX_CANVAS_DIMENSION) {
                const aspectRatio = newWidth / newHeight;
                if (newWidth > newHeight) { newWidth = MAX_CANVAS_DIMENSION; newHeight = Math.floor(MAX_CANVAS_DIMENSION / aspectRatio); }
                else { newHeight = MAX_CANVAS_DIMENSION; newWidth = Math.floor(MAX_CANVAS_DIMENSION * aspectRatio); }
            }
            newWidth = Math.floor(newWidth); newHeight = Math.floor(newHeight);

            if (NovaRayEngine.canvas.width !== newWidth || NovaRayEngine.canvas.height !== newHeight) {
                NovaRayEngine.canvas.width = newWidth; NovaRayEngine.canvas.height = newHeight;
                if (NovaRayEngine.sceneManager) { NovaRayEngine.sceneManager.camera.aspect = NovaRayEngine.canvas.width / NovaRayEngine.canvas.height; }
                console.log(`Canvas resized to ${NovaRayEngine.canvas.width}x${NovaRayEngine.canvas.height}.`);
                if (NovaRayEngine.uiManager) NovaRayEngine.uiManager.setLoadingStatus(`Canvas resized to ${NovaRayEngine.canvas.width}x${NovaRayEngine.canvas.height}. Recreating textures...`);

                NovaRayEngine.context.configure({ device: NovaRayEngine.device, format: NovaRayEngine.presentationFormat, alphaMode: 'opaque', size: [NovaRayEngine.canvas.width, NovaRayEngine.canvas.height], });
                if (NovaRayEngine.outputTexture0) NovaRayEngine.outputTexture0.destroy(); if (NovaRayEngine.outputTexture1) NovaRayEngine.outputTexture1.destroy();
                NovaRayEngine.outputTexture0 = NovaRayEngine.resourceManager.createTexture({ size: { width: NovaRayEngine.canvas.width, height: NovaRayEngine.canvas.height }, format: 'rgba32float', usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT, }, "Output Texture 0 (Ping) - Resize");
                NovaRayEngine.outputTextureView0 = NovaRayEngine.outputTexture0.createView();
                NovaRayEngine.outputTexture1 = NovaRayEngine.resourceManager.createTexture({ size: { width: NovaRayEngine.canvas.width, height: NovaRayEngine.canvas.height }, format: 'rgba32float', usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT, }, "Output Texture 1 (Pong) - Resize");
                NovaRayEngine.outputTextureView1 = NovaRayEngine.outputTexture1.createView();

                if (NovaRayEngine.computePipeline && NovaRayEngine.renderPipeline) { NovaRayEngine.createComputeBindGroups(); NovaRayEngine.createRenderBindGroup(); }
                else { console.warn("Pipelines not yet ready on NovaRayEngine during resize, deferring bind group creation."); }
                if (NovaRayEngine.sceneManager) { NovaRayEngine.sceneManager.updateCameraUniformBuffer(); NovaRayEngine.sceneManager.updateRaytracerParamsUniformBuffer(); }
                NovaRayEngine.resetAccumulation();
            }
        }

        // Performance tracking variables, local to this script block for renderLoop
        let lastFpsUpdateTime = 0;
        let lastFrameTime = 0;

        /**
         * The main rendering loop for NovaRay.
         * Handles camera updates, UBO updates, dispatching compute and render passes,
         * and FPS counting. Relies on NovaRayEngine for state and resources.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function renderLoop(currentTime) {
            if (!NovaRayEngine.device || NovaRayEngine.device.lost || !NovaRayEngine.canvas || !NovaRayEngine.context || !NovaRayEngine.computePipeline || !NovaRayEngine.renderPipeline) {
                console.error("NovaRayEngine core components not ready or device lost. Stopping render loop.");
                if (NovaRayEngine.device && NovaRayEngine.device.lost) {
                    NovaRayEngine.uiManager.displayErrorMessage("WebGPU device lost. Please try reducing settings and refresh.");
                }
                NovaRayEngine.animationFrameId = null;
                return;
            }

            if (NovaRayEngine.uiManager.appState !== 'scene') {
                NovaRayEngine.animationFrameId = null;
                return;
            }

            const current_time_seconds = currentTime / 1000.0;
            const deltaTime = (current_time_seconds - lastFrameTime);
            lastFrameTime = current_time_seconds;

            const moveSpeed = NovaRayEngine.sceneManager.camera.movementSpeed;
            let dx = 0, dy = 0, dz = 0;

            if (NovaRayEngine.keysPressed['w'] || NovaRayEngine.keysPressed['W'] || NovaRayEngine.keysPressed['ArrowUp']) {
                dx += NovaRayEngine.sceneManager.camera.forward[0] * moveSpeed;
                dy += NovaRayEngine.sceneManager.camera.forward[1] * moveSpeed;
                dz += NovaRayEngine.sceneManager.camera.forward[2] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed['s'] || NovaRayEngine.keysPressed['S'] || NovaRayEngine.keysPressed['ArrowDown']) {
                dx -= NovaRayEngine.sceneManager.camera.forward[0] * moveSpeed;
                dy -= NovaRayEngine.sceneManager.camera.forward[1] * moveSpeed;
                dz -= NovaRayEngine.sceneManager.camera.forward[2] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed['a'] || NovaRayEngine.keysPressed['A'] || NovaRayEngine.keysPressed['ArrowLeft']) {
                dx -= NovaRayEngine.sceneManager.camera.right[0] * moveSpeed;
                dz -= NovaRayEngine.sceneManager.camera.right[2] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed['d'] || NovaRayEngine.keysPressed['D'] || NovaRayEngine.keysPressed['ArrowRight']) {
                dx += NovaRayEngine.sceneManager.camera.right[0] * moveSpeed;
                dz += NovaRayEngine.sceneManager.camera.right[2] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed[' ']) {
                dy += NovaRayEngine.sceneManager.camera.up[1] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed['Control'] || NovaRayEngine.keysPressed['control']) {
                dy -= NovaRayEngine.sceneManager.camera.up[1] * moveSpeed;
            }

            if (dx !== 0 || dy !== 0 || dz !== 0) {
                NovaRayEngine.sceneManager.moveCamera(dx, dy, dz);
            }

            NovaRayEngine.totalTime = (currentTime - NovaRayEngine.startTimeForTotalTime) / 1000.0;
            if (NovaRayEngine.accumulationNeedsReset) {
                NovaRayEngine.frameCount = 0;
                NovaRayEngine.accumulationNeedsReset = false;
            } else {
                NovaRayEngine.frameCount++;
            }
            NovaRayEngine.sceneManager.updateTimeUniformBuffer(NovaRayEngine.totalTime, NovaRayEngine.frameCount);

            NovaRayEngine.createComputeBindGroups();

            NovaRayEngine.device.pushErrorScope('validation');
            NovaRayEngine.device.pushErrorScope('internal');

            const commandEncoder = NovaRayEngine.device.createCommandEncoder();
            const computePassEncoder = commandEncoder.beginComputePass();
            computePassEncoder.setPipeline(NovaRayEngine.computePipeline);
            computePassEncoder.setBindGroup(0, NovaRayEngine.computeBindGroup0);
            computePassEncoder.setBindGroup(1, NovaRayEngine.computeBindGroup1);
            const workgroup_size_x = 8;
            const workgroup_size_y = 8;
            const dispatchX = Math.ceil(NovaRayEngine.canvas.width / workgroup_size_x);
            const dispatchY = Math.ceil(NovaRayEngine.canvas.height / workgroup_size_y);
            computePassEncoder.dispatchWorkgroups(dispatchX, dispatchY, 1);
            computePassEncoder.end();

            const textureView = NovaRayEngine.context.getCurrentTexture().createView();
            const renderPassDescriptor = {
                colorAttachments: [{
                    view: textureView, loadOp: 'clear', clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, storeOp: 'store',
                }],
            };
            const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);
            renderPass.setPipeline(NovaRayEngine.renderPipeline);
            NovaRayEngine.createRenderBindGroup();
            renderPass.setBindGroup(0, NovaRayEngine.renderBindGroup);
            renderPass.setVertexBuffer(0, NovaRayEngine.renderQuadVertexBuffer);
            renderPass.draw(6);
            renderPass.end();

            NovaRayEngine.device.queue.submit([commandEncoder.finish()]);

            NovaRayEngine.device.popErrorScope().then((error) => {
                if (error) { console.error('WebGPU Error (internal scope):', error); NovaRayEngine.uiManager.displayErrorMessage(\`WebGPU Internal Error: \${error.message}\`); }
            });
            NovaRayEngine.device.popErrorScope().then((error) => {
                if (error) { console.error('WebGPU Error (validation scope):', error); NovaRayEngine.uiManager.displayErrorMessage(\`WebGPU Validation Error: \${error.message}\`); }
            });

            if (currentTime - lastFpsUpdateTime >= 1000) {
                const currentFps = (NovaRayEngine.frameCount / ((currentTime - lastFpsUpdateTime)/1000.0));
                NovaRayEngine.uiManager.updateFPSCounter(currentFps);
                lastFpsUpdateTime = currentTime;
            }

            NovaRayEngine.currentTextureIndex = 1 - NovaRayEngine.currentTextureIndex;

            NovaRayEngine.animationFrameId = requestAnimationFrame(renderLoop);
        }

        /** Starts the main render loop and initializes timing variables. */
        function startRenderLoop() {
            NovaRayEngine.totalTime = 0;
            NovaRayEngine.frameCount = 0;
            NovaRayEngine.currentTextureIndex = 0;
            NovaRayEngine.accumulationNeedsReset = true;
            NovaRayEngine.startTimeForTotalTime = performance.now();
            lastFrameTime = performance.now() / 1000.0;
            lastFpsUpdateTime = performance.now();


            if (!NovaRayEngine.animationFrameId) {
                NovaRayEngine.animationFrameId = requestAnimationFrame(renderLoop);
            }
        }

        window.onload = () => {
            // Global NovaRayEngine is already defined as an object literal.
            // UIManager needs to be instantiated and initialized.
            if (!NovaRayEngine.uiManager) {
                 NovaRayEngine.uiManager = new UIManager(NovaRayEngine);
                 NovaRayEngine.uiManager.initDOMElements();
                 NovaRayEngine.uiManager.initEventListeners();
            }
            NovaRayEngine.uiManager.switchView('menu');

            // Initialize NovaRayEngine state properties
            NovaRayEngine.totalTime = 0;
            NovaRayEngine.frameCount = 0;
            NovaRayEngine.currentTextureIndex = 0;
            NovaRayEngine.animationFrameId = null;
            NovaRayEngine.keysPressed = {};
            NovaRayEngine.isMouseDown = false;
            NovaRayEngine.lastMouseX = 0;
            NovaRayEngine.lastMouseY = 0;
            NovaRayEngine.accumulationNeedsReset = true;

        };
    </script>
</body>
</html>
