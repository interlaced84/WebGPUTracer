<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CompuTracer - Volumetric Clouds</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="webgpu-canvas"></canvas>
    <script type="module">
const noiseWgslString = `// WGSL Noise Library
// Implements Perlin Noise (2D and 3D) and Fractional Brownian Motion (fBm).

// --- Helper Functions ---

// Quintic interpolation function (smoother than fade(t) = 6t^5 - 15t^4 + 10t^3)
// t should be in [0, 1]
fn fade(t: f32) -> f32 {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Linear interpolation
fn lerp(a: f32, b: f32, t: f32) -> f32 {
    return a + t * (b - a);
}

// --- 2D Perlin Noise ---

// Hash function to pseudo-randomly permute input coordinates.
// Output is a vec2<f32> in the range [0, 1)
// Based on implementations that use fractional parts of dot products.
fn hash2D(p: vec2<f32>) -> vec2<f32> {
    let k1 = vec2<f32>(12.9898, 78.233);
    let k2 = vec2<f32>(26.7, 63.2);
    var p_mut = p; // Make p mutable
    p_mut = vec2<f32>(dot(p_mut, k1), dot(p_mut, k2));
    return fract(sin(p_mut) * 43758.5453); // Common large number for pseudo-randomness
}

// Gradient function for 2D Perlin noise.
// Takes a hashed value (from hash2D, effectively a random direction index)
// and a position vector \`p_fract\` (fractional part of original coords).
// Returns the dot product of a gradient vector and \`p_fract\`.
fn grad2D(hash_val: vec2<f32>, p_fract: vec2<f32>) -> f32 {
    // Convert hash_val to an angle (0 to 2*PI)
    let angle = hash_val.x * 2.0 * 3.1415926535; // Using PI approximation
    let gradient = vec2<f32>(cos(angle), sin(angle));
    return dot(gradient, p_fract);
}

// 2D Perlin Noise function
// Input p: vec2<f32> - point at which to evaluate noise
// Output: f32 - noise value, approximately in range [-1, 1] (though classic Perlin can exceed this slightly)
fn perlinNoise2D(p: vec2<f32>) -> f32 {
    let p_floor = floor(p); // Integer part of p
    let p_fract = fract(p); // Fractional part of p

    // Get hash values for the four grid corners
    let h00 = hash2D(p_floor + vec2<f32>(0.0, 0.0)); // Bottom-left
    let h10 = hash2D(p_floor + vec2<f32>(1.0, 0.0)); // Bottom-right
    let h01 = hash2D(p_floor + vec2<f32>(0.0, 1.0)); // Top-left
    let h11 = hash2D(p_floor + vec2<f32>(1.0, 1.0)); // Top-right

    // Calculate gradient contributions from each corner
    // Vectors from corners to the point p_fract:
    // g00: p_fract - (0,0) = p_fract
    // g10: p_fract - (1,0)
    // g01: p_fract - (0,1)
    // g11: p_fract - (1,1)
    let n00 = grad2D(h00, p_fract - vec2<f32>(0.0, 0.0));
    let n10 = grad2D(h10, p_fract - vec2<f32>(1.0, 0.0));
    let n01 = grad2D(h01, p_fract - vec2<f32>(0.0, 1.0));
    let n11 = grad2D(h11, p_fract - vec2<f32>(1.0, 1.0));

    // Apply fade function to the fractional parts (for smooth interpolation)
    let u = fade(p_fract.x);
    let v = fade(p_fract.y);

    // Interpolate along x-axis
    let nx0 = lerp(n00, n10, u);
    let nx1 = lerp(n01, n11, u);

    // Interpolate along y-axis
    let nxy = lerp(nx0, nx1, v);

    // The result is typically in [-sqrt(N)/2, sqrt(N)/2] where N is dimensions.
    // For 2D, this is [-sqrt(2)/2, sqrt(2)/2] approx [-0.707, 0.707].
    // Some implementations multiply by a factor (e.g., 2.0) to bring it closer to [-1, 1].
    // Let's scale it slightly to get a bit closer to the [-1,1] range.
    // A common scaling factor is around 1.0 to 1.414 for 2D.
    // We will return the raw value, often around [-0.7, 0.7].
    // If a strict [-1,1] is needed, the user should scale it.
    return nxy;
}

// --- 3D Perlin Noise ---

// Hash function for 3D. Output is vec3<f32> in [0,1)^3
fn hash3D(p: vec3<f32>) -> vec3<f32> {
    // Using a common hashing technique for 3D noise
    var p_mut = vec3<f32>(dot(p, vec3<f32>(127.1, 311.7, 74.7)),
                          dot(p, vec3<f32>(269.5, 183.3, 246.1)),
                          dot(p, vec3<f32>(113.5, 271.9, 124.6)));
    return fract(sin(p_mut) * 43758.5453123);
}


// Gradient function for 3D Perlin noise.
// Uses 12 standard gradient vectors (edges of a cube centered at origin, plus midpoints of faces).
// This is a common approach for 3D Perlin noise.
fn grad3D(hash_val: vec3<f32>, p_fract: vec3<f32>) -> f32 {
    // Select one of 12 gradient vectors based on hash_val.
    // A simple way to pick: use integer part of hash_val components.
    // Or, more commonly, use a permutation table lookup for gradients.
    // For simplicity here, we'll derive from hash.
    // This is not a standard Perlin gradient selection, but a simpler one for this example.
    // A more robust method would involve a permutation table and pre-defined gradient vectors.

    // Let's use a simpler set of gradients for this example, derived from hash components.
    // This is more like a "value noise" gradient.
    // For true Perlin, one would typically use a set like:
    // (1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0),
    // (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1),
    // (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)
    // And select one based on a hash value.

    // For this implementation, let's use the hash directly as a direction vector (normalized).
    // This is more akin to Simplex noise style gradients but without the simplex grid.
    let gradient_unnormalized = (hash_val * 2.0) - 1.0; // Map [0,1] to [-1,1]
    let gradient = normalize(gradient_unnormalized);
    // Check for zero vector from normalize if hash_val was (0.5, 0.5, 0.5) -> (0,0,0)
    if (length(gradient) < 0.0001) {
        return dot(vec3<f32>(1.0, 0.0, 0.0), p_fract); // Default to a fixed gradient
    }
    return dot(gradient, p_fract);
}

// 3D Perlin Noise function
// Input p: vec3<f32> - point at which to evaluate noise
// Output: f32 - noise value, approximately in range [-1, 1] (classic 3D Perlin is closer to [-0.866, 0.866])
fn perlinNoise3D(p: vec3<f32>) -> f32 {
    let p_floor = floor(p); // Integer part
    let p_fract = fract(p); // Fractional part

    // Hashes for the 8 cube corners
    let h000 = hash3D(p_floor + vec3<f32>(0.0, 0.0, 0.0));
    let h100 = hash3D(p_floor + vec3<f32>(1.0, 0.0, 0.0));
    let h010 = hash3D(p_floor + vec3<f32>(0.0, 1.0, 0.0));
    let h110 = hash3D(p_floor + vec3<f32>(1.0, 1.0, 0.0));
    let h001 = hash3D(p_floor + vec3<f32>(0.0, 0.0, 1.0));
    let h101 = hash3D(p_floor + vec3<f32>(1.0, 0.0, 1.0));
    let h011 = hash3D(p_floor + vec3<f32>(0.0, 1.0, 1.0));
    let h111 = hash3D(p_floor + vec3<f32>(1.0, 1.0, 1.0));

    // Gradient contributions
    let n000 = grad3D(h000, p_fract - vec3<f32>(0.0, 0.0, 0.0));
    let n100 = grad3D(h100, p_fract - vec3<f32>(1.0, 0.0, 0.0));
    let n010 = grad3D(h010, p_fract - vec3<f32>(0.0, 1.0, 0.0));
    let n110 = grad3D(h110, p_fract - vec3<f32>(1.0, 1.0, 0.0));
    let n001 = grad3D(h001, p_fract - vec3<f32>(0.0, 0.0, 1.0));
    let n101 = grad3D(h101, p_fract - vec3<f32>(1.0, 0.0, 1.0));
    let n011 = grad3D(h011, p_fract - vec3<f32>(0.0, 1.0, 1.0));
    let n111 = grad3D(h111, p_fract - vec3<f32>(1.0, 1.0, 1.0));

    // Interpolation weights
    let u = fade(p_fract.x);
    let v = fade(p_fract.y);
    let w = fade(p_fract.z);

    // Interpolate along x
    let nx00 = lerp(n000, n100, u);
    let nx10 = lerp(n010, n110, u);
    let nx01 = lerp(n001, n101, u);
    let nx11 = lerp(n011, n111, u);

    // Interpolate along y
    let nxy0 = lerp(nx00, nx10, v);
    let nxy1 = lerp(nx01, nx11, v);

    // Interpolate along z
    let nxyz = lerp(nxy0, nxy1, w);

    // Output is typically in [-sqrt(3)/2, sqrt(3)/2] approx [-0.866, 0.866].
    // No scaling applied here by default.
    return nxyz;
}


// --- Fractional Brownian Motion (fBm) ---
// Sums multiple octaves of noise for a more detailed, fractal appearance.

// fBm 2D
// p: point
// octaves: number of noise layers to sum
// persistence: amplitude multiplier for each subsequent octave (typically ~0.5)
// lacunarity: frequency multiplier for each subsequent octave (typically ~2.0)
// Output range depends on octaves and persistence. If Perlin is [-1,1],
// max possible sum is sum(persistence^i) for i=0 to octaves-1.
// E.g. 4 octaves, persistence 0.5: 1 + 0.5 + 0.25 + 0.125 = 1.875. So range can be [-1.875, 1.875].
// Often normalized or mapped to [0,1] by the caller.
fn fBm2D(p: vec2<f32>, octaves: u32, persistence: f32, lacunarity: f32) -> f32 {
    var total: f32 = 0.0;
    var frequency: f32 = 1.0;
    var amplitude: f32 = 1.0;
    var maxValue: f32 = 0.0; // Used for normalizing to approx [0,1] if desired, but Perlin is already ~[-1,1]

    for (var i: u32 = 0u; i < octaves; i = i + 1u) {
        total += perlinNoise2D(p * frequency) * amplitude;
        maxValue += amplitude; // Accumulate max possible amplitude if noise was [0,1]
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    // If perlinNoise2D output is in [-1, 1], then total is roughly in [-maxValue, maxValue].
    // To map to [0, 1] (common for textures): (total / maxValue) * 0.5 + 0.5;
    // For now, returning the raw sum.
    return total;
}

// fBm 3D
// Parameters and output range considerations similar to fBm2D.
fn fBm3D(p: vec3<f32>, octaves: u32, persistence: f32, lacunarity: f32) -> f32 {
    var total: f32 = 0.0;
    var frequency: f32 = 1.0;
    var amplitude: f32 = 1.0;
    var maxValue: f32 = 0.0;

    for (var i: u32 = 0u; i < octaves; i = i + 1u) {
        total += perlinNoise3D(p * frequency) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    // Raw sum, typically in [-maxValue, maxValue] if perlinNoise3D is [-1,1].
    return total;
}

// Example of how one might use fBm to generate a value for texturing, mapped to [0,1]
// fn normalized_fBm3D(p: vec3<f32>, octaves: u32, persistence: f32, lacunarity: f32) -> f32 {
//     var total: f32 = 0.0;
//     var frequency: f32 = 1.0;
//     var amplitude: f32 = 1.0;
//     var maxValue: f32 = 0.0; // This is to normalize the result to a [0,1] range
//
//     for (var i: u32 = 0u; i < octaves; i = i + 1u) {
//         // Assuming perlinNoise3D returns in [-1, 1]. We map it to [0, 1] for this summation.
//         total += (perlinNoise3D(p * frequency) * 0.5 + 0.5) * amplitude;
//         maxValue += amplitude;
//         amplitude *= persistence;
//         frequency *= lacunarity;
//     }
//
//     if (maxValue == 0.0) { return 0.0; } // Avoid division by zero
//     return total / maxValue; // Normalize to [0,1]
// }
`;

const raymarcherWgslString = `// raymarcher.wgsl - Volumetric cloud raymarcher with lighting and self-shadowing

// --- Structs ---
struct Ray {
    origin: vec3<f32>,
    direction: vec3<f32>,
}

struct Uniforms {
    camera_pos: vec3<f32>,
    _padding1: f32,                     // Offset 0, size 16

    inv_proj_matrix: mat4x4<f32>,       // Offset 16, size 64
    inv_view_matrix: mat4x4<f32>,       // Offset 80, size 64

    viewport_size: vec2<f32>,
    _padding2: vec2<f32>,               // Offset 144, size 16

    cloud_bounds_min: vec3<f32>,
    _padding3: f32,                     // Offset 160, size 16
    cloud_bounds_max: vec3<f32>,
    _padding4: f32,                     // Offset 176, size 16

    // Raymarching & Base Noise parameters
    max_steps: u32,                     // Offset 192
    step_size: f32,                     // Offset 196
    time: f32,                          // Offset 200
    noise_scale: f32,                   // Offset 204 (Primary detail noise scale)
                                        // Block ends at 208

    fbm_octaves: u32,                   // Offset 208 (For primary detail noise)
    fbm_persistence: f32,               // Offset 212
    fbm_lacunarity: f32,                // Offset 216
    base_density_threshold_min: f32,    // Offset 220 (Remapping base_noise)
                                        // Block ends at 224

    base_density_threshold_max: f32,    // Offset 224
    density_multiplier: f32,            // Offset 228
    absorption_coefficient: f32,        // Offset 232
    scattering_coefficient: f32,        // Offset 236
                                        // Block ends at 240

    henyey_g: f32,                      // Offset 240
    coverage_noise_scale: f32,          // Offset 244
    coverage_fbm_octaves: u32,          // Offset 248
    coverage_fbm_persistence: f32,      // Offset 252
                                        // Block ends at 256

    coverage_fbm_lacunarity: f32,       // Offset 256
    coverage_threshold: f32,            // Offset 260
    cloud_base_height: f32,             // Offset 264
    cloud_top_height: f32,              // Offset 268
                                        // Block ends at 272

    height_density_falloff: f32,        // Offset 272
    // Shadow parameters
    shadow_max_steps: u32,              // Offset 276
    shadow_step_size: f32,              // Offset 280
    shadow_absorption_coefficient: f32, // Offset 284
                                        // Block ends at 288.

    // Lighting
    light_dir: vec3<f32>,               // Offset 288
    _padding6: f32,                     // For alignment
                                        // Block ends at 304
    light_color: vec3<f32>,             // Offset 304
    _padding7: f32,                     // For alignment
                                        // Block ends at 320
    ambient_light_color: vec3<f32>,     // Offset 320
    _padding8: f32,                     // For alignment
                                        // Block ends at 336
} // Total size: 336 bytes (as before, shadow params fit into previous padding)


// --- Uniforms Binding ---
@group(0) @binding(0) var<uniform> uniforms: Uniforms;

// --- Noise Function Placeholder ---
// Content of noise.wgsl (including perlinNoise3D, fBm3D, hash functions, fade, lerp)
// is expected to be prepended here by the JavaScript runner.


// --- Ray Generation ---
fn get_ray_dir_ndc(ndc_xy: vec2<f32>) -> vec3<f32> {
    let near_plane_ndc = vec4<f32>(ndc_xy.x, ndc_xy.y, 0.0, 1.0);
    var p_view = uniforms.inv_proj_matrix * near_plane_ndc;
    p_view = p_view / p_view.w;
    let p_world_near = uniforms.inv_view_matrix * vec4<f32>(p_view.xyz, 1.0);
    let ray_dir_world = p_world_near.xyz - uniforms.camera_pos;
    return normalize(ray_dir_world);
}

// --- AABB Intersection ---
fn intersect_aabb(ray_origin: vec3<f32>, ray_dir: vec3<f32>, box_min: vec3<f32>, box_max: vec3<f32>) -> vec2<f32> {
    let inv_dir = 1.0 / ray_dir;
    let t1 = (box_min - ray_origin) * inv_dir;
    let t2 = (box_max - ray_origin) * inv_dir;
    let t_min_vec = min(t1, t2);
    let t_max_vec = max(t1, t2);
    var t_enter = max(t_min_vec.x, max(t_min_vec.y, t_min_vec.z));
    var t_exit = min(t_max_vec.x, min(t_max_vec.y, t_max_vec.z));
    if (t_enter > t_exit || t_exit < 0.0) {
        return vec2<f32>(1.0, 0.0);
    }
    t_enter = max(t_enter, 0.0);
    return vec2<f32>(t_enter, t_exit);
}

// --- Density Function ---
fn sample_density(world_pos: vec3<f32>) -> f32 {
    let coverage_coord = world_pos * uniforms.coverage_noise_scale;
    var coverage_noise_raw = fBm3D(coverage_coord, uniforms.coverage_fbm_octaves, uniforms.coverage_fbm_persistence, uniforms.coverage_fbm_lacunarity);
    coverage_noise_raw = (coverage_noise_raw / 1.505) * 0.5 + 0.5;

    let coverage_factor = smoothstep(uniforms.coverage_threshold - 0.1, uniforms.coverage_threshold + 0.1, coverage_noise_raw);
    if (coverage_factor < 0.01) { return 0.0; }

    let base_noise_coord = world_pos * uniforms.noise_scale + vec3<f32>(uniforms.time * 0.03, uniforms.time * 0.01, uniforms.time * 0.005);
    var base_noise_raw = fBm3D(base_noise_coord, uniforms.fbm_octaves, uniforms.fbm_persistence, uniforms.fbm_lacunarity);
    let remapped_base_noise = smoothstep(uniforms.base_density_threshold_min, uniforms.base_density_threshold_max, base_noise_raw);

    let height_factor_bottom = smoothstep(uniforms.cloud_base_height, uniforms.cloud_base_height + uniforms.height_density_falloff, world_pos.y);
    let height_factor_top = 1.0 - smoothstep(uniforms.cloud_top_height - uniforms.height_density_falloff, uniforms.cloud_top_height, world_pos.y);
    let height_mask = height_factor_bottom * height_factor_top;
    if (height_mask < 0.01) { return 0.0; }

    let shaped_density = remapped_base_noise * height_mask * coverage_factor;
    return clamp(shaped_density, 0.0, 1.0);
}

// --- Henyey-Greenstein Phase Function ---
const PI: f32 = 3.1415926535;
fn henyey_greenstein(cos_theta: f32, g: f32) -> f32 {
    let g2 = g * g;
    let term_denominator_sq = 1.0 + g2 - 2.0 * g * cos_theta;
    if (term_denominator_sq <= 0.00001) { return (1.0 - g2) / ( (4.0 * PI) * pow(0.0001, 1.5) ) ; }
    return (1.0 - g2) / ( (4.0 * PI) * term_denominator_sq * sqrt(term_denominator_sq) );
}

// --- Shadow Transmittance Function ---
fn get_shadow_transmittance(current_ray_pos: vec3<f32>, normalized_light_dir: vec3<f32>) -> f32 {
    var S_transmittance: f32 = 1.0;
    // Start shadow ray slightly offset from the current point to avoid self-intersection artifacts
    let shadow_ray_start_offset = normalized_light_dir * uniforms.step_size * 0.5; // Or a small fixed value
    var shadow_sample_pos = current_ray_pos + shadow_ray_start_offset;

    for (var i: u32 = 0u; i < uniforms.shadow_max_steps; i = i + 1u) {
        // AABB Check for shadow ray (check if current sample point is within cloud bounds)
        // This uses the main cloud AABB. More advanced techniques might use a tighter bound or no bound if clouds are global.
        let in_bounds_min = shadow_sample_pos >= uniforms.cloud_bounds_min;
        let in_bounds_max = shadow_sample_pos <= uniforms.cloud_bounds_max;
        if (!all(in_bounds_min) || !all(in_bounds_max)) {
            // If shadow ray exits the main cloud AABB, assume it's fully lit from that point onwards towards the light source
            break;
        }

        let density_along_shadow_ray = sample_density(shadow_sample_pos);
        let effective_shadow_density = max(0.0, density_along_shadow_ray * uniforms.density_multiplier);

        if (effective_shadow_density > 0.01) {
            S_transmittance *= exp(-effective_shadow_density * uniforms.shadow_absorption_coefficient * uniforms.shadow_step_size);
            if (S_transmittance < 0.01) {
                S_transmittance = 0.0; // Fully occluded
                break;
            }
        }
        shadow_sample_pos = shadow_sample_pos + normalized_light_dir * uniforms.shadow_step_size;
    }
    return S_transmittance;
}


// --- Main Fragment Shader ---
@fragment
fn main(@builtin(position) frag_coord: vec4<f32>) -> @location(0) vec4<f32> {
    let ndc = ( (frag_coord.xy / uniforms.viewport_size) * 2.0 - 1.0 ) * vec2<f32>(1.0, -1.0);

    let ray_origin_world = uniforms.camera_pos;
    let ray_dir_world = get_ray_dir_ndc(ndc);

    let intersection = intersect_aabb(ray_origin_world, ray_dir_world, uniforms.cloud_bounds_min, uniforms.cloud_bounds_max);
    let t_min = intersection.x;
    let t_max = intersection.y;

    let background_color_rgb = vec3<f32>(0.1, 0.15, 0.3);

    if (t_min >= t_max) {
        return vec4<f32>(background_color_rgb, 1.0);
    }

    var accumulated_color = vec3<f32>(0.0);
    var transmittance = 1.0;

    let max_march_distance = min(t_max, t_min + (f32(uniforms.max_steps) * uniforms.step_size));
    var current_t = t_min + uniforms.step_size * hash3D(ray_dir_world + vec3<f32>(uniforms.time, uniforms.time * 1.3, uniforms.time * 1.7)).x;

    for (var i: u32 = 0u; i < uniforms.max_steps; i = i + 1u) {
        if (current_t >= max_march_distance) {
            break;
        }
        
        let current_pos = ray_origin_world + ray_dir_world * current_t;
        let raw_density = sample_density(current_pos);
        let effective_density = max(0.0, raw_density * uniforms.density_multiplier);

        if (effective_density > 0.01) {
            let segment_transmittance = exp(-effective_density * uniforms.absorption_coefficient * uniforms.step_size);
            
            // Get shadow transmittance from this point towards the light source
            let S_sun = get_shadow_transmittance(current_pos, uniforms.light_dir); // light_dir must be normalized

            if (S_sun > 0.01) { // Only calculate scattering if not fully in shadow
                let cos_theta = dot(uniforms.light_dir, -ray_dir_world);
                let phase_val = henyey_greenstein(cos_theta, uniforms.henyey_g);
                let direct_light_intensity_at_point = effective_density * uniforms.scattering_coefficient * phase_val * uniforms.light_color;
                accumulated_color += direct_light_intensity_at_point * S_sun * transmittance * uniforms.step_size;
            }
            
            transmittance *= segment_transmittance;

            if (transmittance < 0.01) {
                transmittance = 0.0; // Clamp to ensure full opacity if threshold is reached
                break;
            }
        }
        current_t += uniforms.step_size;
    }

    // Add ambient contribution to the cloud itself, modulated by how much cloud mass was encountered (1.0 - transmittance)
    let ambient_cloud_contribution = uniforms.ambient_light_color * (1.0 - transmittance); // Ambient applied to the cloud's perceived "thickness"

    let final_color = accumulated_color + ambient_cloud_contribution + background_color_rgb * transmittance;

    return vec4<f32>(final_color, 1.0);
}
`;

        // Content of main.js will be embedded here
        // main.js for WebGPU Raymarcher Test with Self-Shadowing

// --- Minimal Matrix/Vector Library ---
function normalizeVector3D(v) { let len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]); if (len > 0.00001) { return [v[0]/len, v[1]/len, v[2]/len]; } return [0,0,0]; }
function crossProduct3D(a,b) { return [ a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0] ]; }
function dotProduct(v1,v2) { return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]; }
function getProjectionMatrix(fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy/2); const out = new Float32Array(16);
    out[0]=f/aspect; out[5]=f; out[10]=far/(far-near); out[11]=1; out[14]=-(far*near)/(far-near);
    return out;
}
function getViewMatrix(cameraPosition, cameraForward, cameraUp) {
    const z=normalizeVector3D([-cameraForward[0],-cameraForward[1],-cameraForward[2]]); const x=normalizeVector3D(crossProduct3D(cameraUp,z)); const y=normalizeVector3D(crossProduct3D(z,x));
    const out = new Float32Array(16);
    out[0]=x[0]; out[4]=x[1]; out[8]=x[2]; out[12]=-dotProduct(x,cameraPosition);
    out[1]=y[0]; out[5]=y[1]; out[9]=y[2]; out[13]=-dotProduct(y,cameraPosition);
    out[2]=z[0]; out[6]=z[1]; out[10]=z[2];out[14]=-dotProduct(z,cameraPosition);
    out[15]=1;
    return out;
}
function invertMatrix(m) {
    const o=new Float32Array(16); const M=m;
    const b00=M[0]*M[5]-M[1]*M[4];const b01=M[0]*M[6]-M[2]*M[4];const b02=M[0]*M[7]-M[3]*M[4];const b03=M[1]*M[6]-M[2]*M[5];const b04=M[1]*M[7]-M[3]*M[5];const b05=M[2]*M[7]-M[3]*M[6];
    const b06=M[8]*M[13]-M[9]*M[12];const b07=M[8]*M[14]-M[10]*M[12];const b08=M[8]*M[15]-M[11]*M[12];const b09=M[9]*M[14]-M[10]*M[13];const b10=M[9]*M[15]-M[11]*M[13];const b11=M[10]*M[15]-M[11]*M[14];
    let d=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;
    if(!d){console.warn("invertMatrix: singular"); o.set([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]); return o;} d=1/d;
    o[0]=(M[5]*b11-M[6]*b10+M[7]*b09)*d;o[1]=(M[2]*b10-M[1]*b11-M[3]*b09)*d;o[2]=(M[13]*b05-M[14]*b04+M[15]*b03)*d;o[3]=(M[10]*b04-M[9]*b05-M[11]*b03)*d;
    o[4]=(M[6]*b08-M[4]*b11-M[7]*b07)*d;o[5]=(M[0]*b11-M[2]*b08+M[3]*b07)*d;o[6]=(M[14]*b02-M[12]*b05-M[15]*b01)*d;o[7]=(M[8]*b05-M[10]*b02+M[11]*b01)*d;
    o[8]=(M[4]*b10-M[5]*b08+M[7]*b06)*d;o[9]=(M[1]*b08-M[0]*b10-M[3]*b06)*d;o[10]=(M[12]*b04-M[13]*b02+M[15]*b00)*d;o[11]=(M[9]*b02-M[8]*b04-M[11]*b00)*d;
    o[12]=(M[5]*b07-M[4]*b09-M[6]*b06)*d;o[13]=(M[0]*b09-M[1]*b07+M[2]*b06)*d;o[14]=(M[13]*b01-M[12]*b03-M[14]*b00)*d;o[15]=(M[8]*b03-M[9]*b01+M[10]*b00)*d;
    return o;
}
// --- End Matrix/Vector Library ---

async function main() {
    const canvas = document.getElementById('webgpu-canvas');
    if (!canvas) { console.error("Canvas element not found."); return; }
    if (!navigator.gpu) { console.error("WebGPU not supported."); document.body.innerHTML = "WebGPU not supported."; return; }

    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) { console.error("Failed to get GPU adapter."); return; }
    const device = await adapter.requestDevice();
    if (!device) { console.error("Failed to get GPU device."); return; }

    const context = canvas.getContext('webgpu');
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    function configureCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(window.innerWidth * dpr);
        canvas.height = Math.floor(window.innerHeight * dpr);
        context.configure({ device, format: presentationFormat, alphaMode: 'opaque' });
    }
    configureCanvas();
    window.addEventListener('resize', configureCanvas);

    // WGSL shaders are now embedded as JS strings
    // No fetch calls needed for noiseWgsl and raymarcherWgsl

    const combinedShaderSource = noiseWgslString + "\n" + raymarcherWgslString;
    const shaderModule = device.createShaderModule({ label: 'Raymarcher Shader', code: combinedShaderSource });
    shaderModule.getCompilationInfo().then(info => {
        if (info.messages.filter(m=>m.type==='error').length > 0) { console.error("Raymarcher Shader Compilation Errors:", info.messages); info.messages.forEach(m=>console.log(m.message));}
        else { console.log("Raymarcher Shader compiled."); }
    });

    // WGSL Uniforms struct layout from raymarcher.wgsl (total 336 bytes)
    const uniformBufferSize = 336;
    const uniformBuffer = device.createBuffer({ size: uniformBufferSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    const uniformsData = new ArrayBuffer(uniformBufferSize);
    const uniformsF32 = new Float32Array(uniformsData);
    const uniformsU32 = new Uint32Array(uniformsData);

    const camPos = [0.0, 0.0, 2.5]; const camFwd = [0.0,0.0,-1.0]; const camUp = [0.0,1.0,0.0];
    const aspect = canvas.width/canvas.height; const projMat = getProjectionMatrix(Math.PI/3, aspect, 0.1, 100.0);
    const viewMat = getViewMatrix(camPos, camFwd, camUp);
    const invProjMat = invertMatrix(projMat); const invViewMat = invertMatrix(viewMat);

    let f32Idx = 0;

    // camera_pos: vec3f, _padding1: f32 (16 bytes)
    uniformsF32.set(camPos, f32Idx); f32Idx += 4;
    // inv_proj_matrix: mat4x4f (64 bytes)
    uniformsF32.set(invProjMat, f32Idx); f32Idx += 16;
    // inv_view_matrix: mat4x4f (64 bytes)
    uniformsF32.set(invViewMat, f32Idx); f32Idx += 16;
    // viewport_size: vec2f, _padding2: vec2f (16 bytes)
    const viewportSizeUniformOffsetF32 = f32Idx; // Store offset for dynamic update
    uniformsF32[f32Idx++] = canvas.width; uniformsF32[f32Idx++] = canvas.height; f32Idx += 2;
    // cloud_bounds_min: vec3f, _padding3: f32 (16 bytes)
    uniformsF32.set([-2.0, -0.8, -2.0], f32Idx); f32Idx += 4;
    // cloud_bounds_max: vec3f, _padding4: f32 (16 bytes)
    uniformsF32.set([2.0, 0.8, 2.0], f32Idx); f32Idx += 4;

    // Raymarching & Base Noise block (16 bytes)
    // max_steps: u32, step_size: f32, time: f32, noise_scale: f32
    let currentBlockU32View = new Uint32Array(uniformsData, f32Idx * 4, 4);
    let currentBlockF32View = new Float32Array(uniformsData, f32Idx * 4, 4);
    currentBlockU32View[0] = 96;        // max_steps
    currentBlockF32View[1] = 0.04;      // step_size
    const timeUniformOffsetF32 = f32Idx + 2; // Absolute f32 index for time
    currentBlockF32View[2] = 0.0;       // time (initial)
    currentBlockF32View[3] = 0.25;      // noise_scale (primary detail)
    f32Idx += 4;

    // FBM & Base Density block (16 bytes)
    // fbm_octaves: u32, fbm_persistence: f32, fbm_lacunarity: f32, base_density_threshold_min: f32
    currentBlockU32View = new Uint32Array(uniformsData, f32Idx * 4, 4);
    currentBlockF32View = new Float32Array(uniformsData, f32Idx * 4, 4);
    currentBlockU32View[0] = 5;         // fbm_octaves
    currentBlockF32View[1] = 0.5;       // fbm_persistence
    currentBlockF32View[2] = 2.0;       // fbm_lacunarity
    currentBlockF32View[3] = -0.15;     // base_density_threshold_min
    f32Idx += 4;

    // Density & Material Coefficients block (16 bytes)
    // base_density_threshold_max: f32, density_multiplier: f32, absorption_coefficient: f32, scattering_coefficient: f32
    uniformsF32[f32Idx++] = 0.25;     // base_density_threshold_max
    uniformsF32[f32Idx++] = 25.0;     // density_multiplier
    uniformsF32[f32Idx++] = 2.5;      // absorption_coefficient (for view ray)
    uniformsF32[f32Idx++] = 2.0;      // scattering_coefficient

    // Henyey-G & Coverage Noise block (16 bytes)
    // henyey_g: f32, coverage_noise_scale: f32, coverage_fbm_octaves: u32, coverage_fbm_persistence: f32
    currentBlockU32View = new Uint32Array(uniformsData, f32Idx * 4, 4); // u32 view for mixed types
    currentBlockF32View = new Float32Array(uniformsData, f32Idx * 4, 4);
    currentBlockF32View[0] = 0.2;       // henyey_g
    currentBlockF32View[1] = 0.03;      // coverage_noise_scale
    currentBlockU32View[2] = 3;         // coverage_fbm_octaves (u32)
    currentBlockF32View[3] = 0.5;       // coverage_fbm_persistence
    f32Idx += 4;

    // Coverage & Height Shaping block (16 bytes)
    // coverage_fbm_lacunarity: f32, coverage_threshold: f32, cloud_base_height: f32, cloud_top_height: f32
    uniformsF32[f32Idx++] = 2.0;      // coverage_fbm_lacunarity
    uniformsF32[f32Idx++] = 0.45;     // coverage_threshold
    uniformsF32[f32Idx++] = -0.5;     // cloud_base_height
    uniformsF32[f32Idx++] = 0.5;      // cloud_top_height

    // Height Falloff & Shadow Params block (16 bytes)
    // height_density_falloff: f32, shadow_max_steps: u32, shadow_step_size: f32, shadow_absorption_coefficient: f32
    currentBlockU32View = new Uint32Array(uniformsData, f32Idx * 4, 4); // u32 view for mixed types
    currentBlockF32View = new Float32Array(uniformsData, f32Idx * 4, 4);
    currentBlockF32View[0] = 0.25;      // height_density_falloff
    currentBlockU32View[1] = 24;        // shadow_max_steps (u32)
    currentBlockF32View[2] = 0.1;       // shadow_step_size
    currentBlockF32View[3] = 1.5;       // shadow_absorption_coefficient
    f32Idx += 4;

    // Lighting block 1 (16 bytes) - light_dir + _padding6
    uniformsF32.set(normalizeVector3D([0.8, 0.6, -0.3]), f32Idx); f32Idx += 4;
    // Lighting block 2 (16 bytes) - light_color + _padding7
    uniformsF32.set([1.0, 0.95, 0.9], f32Idx); f32Idx += 4;
    // Lighting block 3 (16 bytes) - ambient_light_color + _padding8
    uniformsF32.set([0.02, 0.03, 0.05], f32Idx); f32Idx += 4;

    if (f32Idx * 4 !== uniformBufferSize) {
        console.warn(\`Uniform buffer filling mismatch. Expected ${uniformBufferSize} bytes, filled based on f32Idx: ${f32Idx*4} bytes.\`);
    }

    // Explicitly define all 5 arguments for writeBuffer
    device.queue.writeBuffer(uniformBuffer, 0, uniformsData, 0, uniformsData.byteLength);

    const bindGroupLayout = device.createBindGroupLayout({ entries: [{ binding:0, visibility:GPUShaderStage.FRAGMENT, buffer:{type:'uniform'}}]});
    const bindGroup = device.createBindGroup({ layout:bindGroupLayout, entries:[{binding:0, resource:{buffer:uniformBuffer}}]});
    const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout]});

    const vsModule = device.createShaderModule({ label:"QuadVS", code: \`struct VSOut{@builtin(position)p:vec4f};@vertex fn main_vert(@builtin(vertex_index)vi:u32)->VSOut{let pos=array(vec2(-1,-1),vec2(1,-1),vec2(-1,1),vec2(-1,1),vec2(1,-1),vec2(1,1));return VSOut(vec4(pos[vi],0,1));}\`});
    vsModule.getCompilationInfo().then(info=>{if(info.messages.filter(m=>m.type==='error').length > 0)console.error("VS Compile Errors:",info.messages); else console.log("VS compiled.");});

    const renderPipeline = device.createRenderPipeline({
        label: 'RaymarcherPipeline', layout: pipelineLayout,
        vertex: { module: vsModule, entryPoint: 'main_vert' },
        fragment: { module: shaderModule, entryPoint: 'main', targets: [{ format: presentationFormat }] },
        primitive: { topology: 'triangle-list' },
    });

    let startTime = performance.now();
    function renderLoop() {
        if (!device) return;
        const currentTime = (performance.now() - startTime) / 1000.0;

        uniformsF32[timeUniformOffsetF32] = currentTime; // Update time
        uniformsF32[viewportSizeUniformOffsetF32] = canvas.width;
        uniformsF32[viewportSizeUniformOffsetF32 + 1] = canvas.height;

        // Explicitly define all 5 arguments for writeBuffer
        device.queue.writeBuffer(uniformBuffer, 0, uniformsData, 0, uniformsData.byteLength);

        const cmdEncoder = device.createCommandEncoder();
        const texView = context.getCurrentTexture().createView();
        const passDesc = { colorAttachments: [{ view:texView, loadOp:'clear', clearValue:{r:0.01,g:0.02,b:0.03,a:1.0}, storeOp:'store' }]};
        const passEnc = cmdEncoder.beginRenderPass(passDesc);
        passEnc.setPipeline(renderPipeline);
        passEnc.setBindGroup(0, bindGroup);
        passEnc.draw(6); passEnc.end();
        device.queue.submit([cmdEncoder.finish()]);
        requestAnimationFrame(renderLoop);
    }
    requestAnimationFrame(renderLoop);
}
main().catch(err => { console.error(err); document.body.innerHTML = \`Error: ${err.message}\`; });

    </script>
</body>
</html>
