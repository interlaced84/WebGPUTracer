<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Raytracer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #1a1a2e; /* Dark background */
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        /* View management */
        #app-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; /* For absolute positioning of views */
        }
        .view {
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.5s ease-in-out; /* Faster transition for general views */
        }
        .view.active {
            display: flex;
            opacity: 1;
        }
        
        /* Specific view layouts */
        #menu-view {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: #1a1a2e;
            z-index: 10;
        }
        #scene-view {
            justify-content: center;
            align-items: center;
            background-color: #0d0d1e;
            z-index: 5;
        }
        #loading-view {
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #1a1a2e;
            z-index: 15; /* Highest z-index to overlay everything during loading */
            text-align: center;
        }
        
        /* Canvas */
        canvas {
            display: block;
            background-color: #0d0d1e; /* Darker background for canvas */
            width: 100%; /* Take full width of parent */
            height: 100%; /* Take full height of parent */
            cursor: grab; /* Cursor for camera control */
        }
        canvas:active {
            cursor: grabbing;
        }
        /* UI Components - Tailwind based */
        .button-primary {
            @apply px-8 py-4 m-4 text-lg font-semibold text-white bg-indigo-600 rounded-lg shadow-lg hover:bg-indigo-700 transition-all duration-300 transform hover:scale-105 border-2 border-indigo-500;
        }
        .button-secondary {
            @apply px-6 py-3 m-2 text-md font-medium text-indigo-200 bg-gray-800 rounded-md shadow-md hover:bg-gray-700 transition-all duration-300 transform hover:scale-105 border-2 border-gray-700;
        }
        .panel {
            @apply bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-700 max-w-xl w-full;
        }
        .input-range {
            @apply w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer;
            -webkit-appearance: none; /* Override default appearance */
        }
        .input-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5; /* Tailwind indigo-600 */
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.4); /* Focus ring effect */
        }
        .input-range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.4);
        }
        
        /* Specific UI element styling */
        #menu-view h1 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #4CAF50; /* A nice green for the title */
        }
        #menu-view p {
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        #settings-panel {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(20px);
            max-width: 700px; /* Use max-width directly */
        }
        #settings-panel.active {
            opacity: 1;
            pointer-events: all;
            transform: translateY(0);
        }
        #settings-panel h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        #settings-panel label {
            display: block;
            margin-bottom: 5px;
            text-align: left;
            font-weight: 600;
        }
        #settings-panel select {
            @apply w-full p-3 rounded-md bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500;
        }
        
        /* Loading view specific styles */
        #loading-view .spinner {
            animation: spin 1s linear infinite;
            border-top-color: #6366f1; /* Tailwind indigo-500 */
            border-right-color: transparent;
            border-bottom-color: #6366f1;
            border-left-color: transparent;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-view p {
            margin-top: 20px;
            font-size: 1.2em;
            color: #a0a0a0;
        }
        /* Scene view UI */
        #fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #0f0;
            z-index: 20;
            font-family: monospace;
            display: none; /* Hidden by default, activated when scene is active */
        }
        #back-to-main-menu-from-scene {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 20;
        }
        /* Error Display */
        #error-message-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ef4444; /* Tailwind red-500 */
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10000; /* Very high to ensure visibility */
            display: none; /* Hidden by default */
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #error-message-display.active {
            display: block;
            opacity: 1;
        }
        /* Collapsible sections for scene controls */
        #scene-controls-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: #e0e0e0;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transition: width 0.3s ease;
            width: 300px; /* Default width */
            z-index: 1000; /* Ensure panel is above canvas */
            display: none; /* Hidden by default */
        }
        #scene-controls-panel.active {
            display: block;
        }
        #toggle-panel-button {
            background: none;
            border: none;
            color: #00ffff;
            font-size: 24px;
            cursor: pointer;
            position: absolute;
            top: 5px;
            left: 5px;
            line-height: 20px;
        }
        #scene-controls-panel.collapsed {
            width: 40px;
            overflow: hidden;
        }
        #scene-controls-panel.collapsed #toggle-panel-button {
            left: auto; /* reset left property to allow automatic positioning */
            right: 5px; /* Adjust button position when collapsed */
            transform: scaleX(-1); /* Flip caret horizontally */
        }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-weight: bold; color: #00ffff; }
        .control-group input[type="range"] { width: 100%; -webkit-appearance: none; appearance: none; height: 8px; background: #555; border-radius: 512px; outline: none; }
        .control-group input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #00ffff; cursor: pointer; border: 2px solid #fff; }
        .control-group input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #00ffff; cursor: pointer; border: 2px solid #fff; }
        .current-value { float: right; font-weight: normal; color: #e0e0e0; }
        #scene-controls-panel h2 { color: #00ffff; border-bottom: 2px solid #00ffff; padding-bottom: 5px; margin-top: 0; }
        .github-link {
            display: block;
            margin-top: 20px;
            text-align: center;
        }
        .github-link a {
            color: #00ffff;
            text-decoration: none;
            font-weight: bold;
        }
        .github-link a:hover {
            text-decoration: underline;
        }
        details {
            margin-bottom: 10px;
            border: 1px solid #0056b3;
            border-radius: 5px;
        }
        summary {
            background-color: #007bff;
            color: white;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        summary:hover {
            background-color: #0056b3;
        }
        details[open] summary {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        .details-content {
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-top: 1px solid #0056b3;
        }
        .button-group {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            margin-bottom: 15px;
        }
        .button-group button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }
        .button-group button:hover {
            background-color: #0056b3;
        }
        .button-group button.active {
            background-color: #00c0ff;
            box-shadow: 0 0 8px rgba(0, 192, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Main Menu View -->
        <div id="menu-view" class="view active">
            <div class="panel">
                <h1 class="text-4xl font-bold mb-6 text-indigo-300">WebGPU Raytracer</h1>
                <p class="mb-8 text-lg text-gray-300">Experience physically-based rendering on your GPU.</p>
                <button id="start-button" class="button-primary">Start Raytracing</button>
                <button id="settings-button" class="button-primary">Settings</button>
            </div>
            <!-- Settings Panel (hidden initially) -->
            <div id="settings-panel" class="panel absolute opacity-0 pointer-events-none transition-all duration-500 scale-95" style="transform: translateY(20px);">
                <h2 class="text-3xl font-bold mb-6 text-indigo-300">Settings</h2>
                <div class="mb-6">
                    <label for="quality-preset" class="block text-gray-300 text-left mb-2">Quality Preset:</label>
                    <select id="quality-preset" class="w-full p-3 rounded-md bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="low">Low (Fewer Samples, Less Bounces)</option>
                        <option value="medium" selected>Medium (Balanced)</option>
                        <option value="high">High (More Samples, More Bounces)</option>
                    </select>
                </div>
                <div class="mb-6">
                    <label for="num-spheres" class="block text-gray-300 text-left mb-2">Number of Spheres: <span id="num-spheres-value">5</span></label>
                    <input type="range" id="num-spheres" min="1" max="100" value="5" class="input-range">
                </div>
                 <div class="mb-6">
                    <label for="max-bounces" class="block text-gray-300 text-left mb-2">Max Bounces: <span id="max-bounces-value">2</span></label>
                    <input type="range" id="max-bounces" min="1" max="10" value="2" class="input-range">
                </div>
                <div class="mb-6">
                    <label for="samples-per-pixel" class="block text-gray-300 text-left mb-2">Samples per Pixel: <span id="samples-per-pixel-value">4</span></label>
                    <input type="range" id="samples-per-pixel" min="1" max="64" value="4" class="input-range">
                </div>
                <button id="apply-settings-button" class="button-primary">Apply & Start</button>
                <button id="back-to-menu-button" class="button-secondary mt-4">Back to Main Menu</button>
            </div>
        </div>
        <!-- Loading View -->
        <div id="loading-view" class="view">
            <div class="text-center">
                <div class="spinner rounded-full h-16 w-16 border-t-4 border-b-4 border-indigo-500 mb-4 mx-auto"></div>
                <p id="loading-status" class="text-xl text-gray-300">Initializing WebGPU and compiling shaders...</p>
            </div>
        </div>
        <!-- Scene View (contains canvas and scene-specific UI) -->
        <div id="scene-view" class="view">
            <canvas id="webgpu-canvas"></canvas>
            <div id="fps-counter" class="fps-counter">FPS: --</div>
            <button id="back-to-main-menu-from-scene" class="button-secondary absolute bottom-8 right-8">Back to Menu</button>
            <!-- Scene Controls Panel -->
            <div id="scene-controls-panel">
                <button id="toggle-panel-button">&lt;</button>
                <h2>Raytracer Controls</h2>
                <details open>
                    <summary>Camera & Scene</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="sphereCountSlider">Number of Spheres: <span id="sphereCountValue" class="current-value">1</span></label>
                            <input type="range" id="sphereCountSlider" min="1" max="100" value="1">
                        </div>
                        <div class="control-group">
                            <label for="warpStrengthSlider">Domain Warp Strength: <span id="warpStrengthValue" class="current-value">0.0</span></label>
                            <input type="range" id="warpStrengthSlider" min="0.0" max="2.0" step="0.01" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="focalDistanceSlider">Focal Distance: <span id="focalDistanceValue" class="current-value">10.0</span></label>
                            <input type="range" id="focalDistanceSlider" min="0.1" max="50.0" step="0.1" value="10.0">
                        </div>
                        <div class="control-group">
                            <label for="apertureSizeSlider">Aperture Size: <span id="apertureSizeValue" class="current-value">0.00</span></label>
                            <input type="range" id="apertureSizeSlider" min="0.0" max="1.0" step="0.01" value="0.00">
                        </div>
                        <div class="control-group">
                            <label>Sky Preset:</label>
                            <div class="button-group">
                                <button id="sunnyDayButton" class="active">Sunny Day</button>
                                <button id="duskButton">Dusk</button>
                            </div>
                        </div>
                    </div>
                </details>
                <details open>
                    <summary>Sun</summary> <!-- Renamed from Lighting -->
                    <div class="details-content">
                        <div class="control-group">
                            <label for="lightXSlider">Light X: <span id="lightXValue" class="current-value">0.0</span></label>
                            <input type="range" id="lightXSlider" min="-10.0" max="10.0" step="0.1" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="lightYSlider">Light Y: <span id="lightYValue" class="current-value">10.0</span></label>
                            <input type="range" id="lightYSlider" min="0.1" max="20.0" step="0.1" value="10.0">
                        </div>
                        <div class="control-group">
                            <label for="lightZSlider">Light Z: <span id="lightZValue" class="current-value">2.8</span></label>
                            <input type="range" id="lightZSlider" min="-10.0" max="10.0" step="0.1" value="2.8">
                        </div>
                        <div class="control-group">
                            <label for="lightBrightnessSlider">Light Brightness: <span id="lightBrightnessValue" class="current-value">1.0</span></label>
                            <input type="range" id="lightBrightnessSlider" min="0.1" max="5.0" step="0.1" value="1.0">
                        </div>
                        <div class="control-group">
                            <label for="lightSizeSlider">Light Size: <span id="lightSizeValue" class="current-value">0.4</span></label>
                            <input type="range" id="lightSizeSlider" min="0.0" max="5.0" step="0.1" value="0.4">
                        </div>
                        <!-- New Sun Color/Hue Slider -->
                        <div class="control-group">
                            <label for="sunHueSlider">Sun Color/Hue: <span id="sunHueValue" class="current-value">0.00</span></label>
                            <input type="range" id="sunHueSlider" min="0" max="1" step="0.01" value="0">
                        </div>
                    </div>
                </details>
                <details>
                    <summary>Water</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="waveStrengthSlider">Wave Strength: <span id="waveStrengthValue" class="current-value">0.24</span></label>
                            <input type="range" id="waveStrengthSlider" min="0.005" max="0.5" step="0.005" value="0.24">
                        </div>
                        <div class="control-group">
                            <label for="waveFrequencySlider">Wave Frequency: <span id="waveFrequencyValue" class="current-value">0.5</span></label>
                            <input type="range" id="waveFrequencySlider" min="0.5" max="20.0" step="0.1" value="0.5">
                        </div>
                        <div class="control-group">
                            <label for="waveSpeedSlider">Wave Speed: <span id="waveSpeedValue" class="current-value">0.01</span></label>
                            <input type="range" id="waveSpeedSlider" min="0.01" max="2.0" step="0.01" value="0.01">
                        </div>
                        <div class="control-group">
                            <label for="refractiveIndexSlider">Refractive Index: <span id="refractiveIndexValue" class="current-value">1.3</span></label>
                            <input type="range" id="refractiveIndexSlider" min="1.0" max="2.0" step="0.01" value="1.50">
                        </div>
                    </div>
                </details>
                <details>
                    <summary>Terrain</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="terrainHeightSlider">Terrain Height: <span id="terrainHeightValue" class="current-value">0.0</span></label>
                            <input type="range" id="terrainHeightSlider" min="0.0" max="20.0" step="0.1" value="0.0">
                        </div>
                        <div class="control-group">
                            <label for="terrainFrequencySlider">Terrain Frequency: <span id="terrainFrequencyValue" class="current-value">0.15</span></label>
                            <input type="range" id="terrainFrequencySlider" min="0.01" max="1.0" step="0.01" value="0.15">
                        </div>
                    </div>
                </details>
                <details open>
                    <summary>Raytracing Settings</summary>
                    <div class="details-content">
                        <div class="control-group">
                            <label for="bouncesSlider">Max Bounces: <span id="bouncesValue" class="current-value">2</span></label>
                            <input type="range" id="bouncesSlider" min="1" max="10" step="1" value="2">
                        </div>
                        <div class="control-group">
                            <label for="raymarchStepsSlider">Max Raymarch Steps: <span id="raymarchStepsValue" class="current-value">150</span></label>
                            <input type="range" id="raymarchStepsSlider" min="100" max="1000" step="50" value="150">
                        </div>
                        <div class="control-group">
                            <label for="shadowSamplesSlider">Shadow Samples: <span id="shadowSamplesValue" class="current-value">2</span></label>
                            <input type="range" id="shadowSamplesSlider" min="1" max="32" step="1" value="2">
                        </div>
                        <div class="control-group">
                            <label for="dofSamplesSlider">DOF Samples: <span id="dofSamplesValue" class="current-value">4</span></label>
                            <input type="range" id="dofSamplesSlider" min="1" max="32" step="1" value="4">
                        </div>
                    </div>
                </details>
                <div class="github-link">
                    <a href="https://github.com/your-repo-link" target="_blank">View on GitHub</a>
                </div>
            </div>
        </div>
    </div>
    <div id="error-message-display" class="error-message"></div>
    <script type="text/javascript">
        // NovaRay Iteration: 5 - Knowledge Base Setup, Documentation & Framework Solidification
        // --- IMPORTANT: Core Directives & Troubleshooting Log References ---
        // This section ensures adherence to the core development principles and leverages
        // our historical knowledge base for robust, high-quality code.
        //
        // Document: 'NOVARAY_CORE_DIRECTIVES.md'
        // This document contains the fundamental principles and quality standards for all development.
        //
        // Document: 'NOVARAY_TROUBLESHOOTING_LOG.md'
        // This document serves as the comprehensive history and detailed solutions for all encountered issues.
        // It should be consulted for in-depth understanding of recurring problems.
        //
        // Document: 'NOVARAY_WEBGPU_RESOURCES.md'
        // This document collects external resources, tools, and general tips for debugging WebGPU applications.
        //
        // --- End References & Checks ---
        //
        // Troubleshooting Log (In-Code Summary):
        // This section provides a brief summary of the most recent and relevant troubleshooting steps directly related to this file.
        // For the complete and detailed troubleshooting history, refer to the 'NOVARAY_TROUBLESHOOTING_LOG.md' document.
        //
        // - NovaRay Phase 3 & 4 (Completed): Modularized engine into NovaRayEngine, ResourceManager, ShaderManager, SceneManager (with Async BVH), UIManager.
        //   Implemented foundation for 3D noise texture generation. Refer to NOVARAY_PROGRESS_LOG.md for details.
        // - NovaRay Phase 5 (Current): Knowledge Base file creation and full documentation pass.
        //
        // - Previous Critical (WebGPUTracer): Persistent `textureLoad` and sampler/texture type errors.
        //   - Resolved by ensuring explicit mipmap levels, correct texture usage flags (STORAGE_BINDING | TEXTURE_BINDING),
        //     and compatible sampler/texture `sampleType` ('unfilterable-float' with 'non-filtering' sampler) for rgba32float.

const bvhWorkerScript = `
    // --- BVH Data Structures and Logic (CPU side, for Worker) ---
    // This script is intended to be run in a Web Worker.
    // It does not have access to the DOM or global variables from the main thread.

    class AABB {
        constructor(min, max) {
            this.min = min; // [x, y, z]
            this.max = max; // [x, y, z]
        }

        static fromSphere(sphere) {
            return new AABB(
                [sphere.position[0] - sphere.radius, sphere.position[1] - sphere.radius, sphere.position[2] - sphere.radius],
                [sphere.position[0] + sphere.radius, sphere.position[1] + sphere.radius, sphere.position[2] + sphere.radius]
            );
        }

        expand(point) {
            this.min[0] = Math.min(this.min[0], point[0]);
            this.min[1] = Math.min(this.min[1], point[1]);
            this.min[2] = Math.min(this.min[2], point[2]);
            this.max[0] = Math.max(this.max[0], point[0]);
            this.max[1] = Math.max(this.max[1], point[1]);
            this.max[2] = Math.max(this.max[2], point[2]);
        }

        union(other) {
            this.min[0] = Math.min(this.min[0], other.min[0]);
            this.min[1] = Math.min(this.min[1], other.min[1]);
            this.min[2] = Math.min(this.min[2], other.min[2]);
            this.max[0] = Math.max(this.max[0], other.max[0]);
            this.max[1] = Math.max(this.max[1], other.max[1]);
            this.max[2] = Math.max(this.max[2], other.max[2]);
        }

        centroid() {
            return [
                (this.min[0] + this.max[0]) * 0.5,
                (this.min[1] + this.max[1]) * 0.5,
                (this.min[2] + this.max[2]) * 0.5
            ];
        }

        longestAxis() {
            const dx = this.max[0] - this.min[0];
            const dy = this.max[1] - this.min[1];
            const dz = this.max[2] - this.min[2];
            if (dx > dy && dx > dz) return 0;
            if (dy > dz) return 1;
            return 2;
        }

        surfaceArea() {
            const dx = this.max[0] - this.min[0];
            const dy = this.max[1] - this.min[1];
            const dz = this.max[2] - this.min[2];
            return 2 * (dx * dy + dx * dz + dy * dz);
        }
    }

    class BvhNode {
        constructor() {
            this.minBounds = [Infinity, Infinity, Infinity];
            this.maxBounds = [-Infinity, -Infinity, -Infinity];
            this.isLeaf = 0; // 0 for internal, 1 for leaf
            this.primitiveCount = 0;
            // For internal nodes: index of the left child in flattenedNodes. Right child is leftChild + 1.
            // For leaf nodes: index of the first primitive in the original primitiveIndices array.
            this.leftChildOrFirstPrimitiveIndex = 0;
        }
    }

    const BVH_LEAF_SIZE = 4; // Max number of primitives in a leaf node

    // Build the BVH recursively using Surface Area Heuristic (SAH)
    function buildBvhRecursive(primitives, primitiveInfos, start, end, totalPrimitives, flattenedNodes, orderedPrimitiveIndices) {
        const nodeIndex = flattenedNodes.length;
        const node = new BvhNode();
        flattenedNodes.push(node); // Add node to the list

        // Calculate bounds for all primitives in this range
        let bounds = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
        for (let i = start; i < end; ++i) {
            bounds.union(primitiveInfos[i].bounds);
        }
        node.minBounds = bounds.min;
        node.maxBounds = bounds.max;

        const nPrimitives = end - start;

        if (nPrimitives <= BVH_LEAF_SIZE) {
            // Create leaf node
            node.isLeaf = 1;
            node.primitiveCount = nPrimitives;
            node.leftChildOrFirstPrimitiveIndex = orderedPrimitiveIndices.length; // Store start index in the global ordered list
            for (let i = start; i < end; ++i) {
                orderedPrimitiveIndices.push(primitiveInfos[i].originalIndex);
            }
        } else {
            // Create internal node
            node.isLeaf = 0;
            node.primitiveCount = 0; // Internal nodes don't store primitive count directly like leaves

            // Calculate centroid bounds for SAH partitioning
            let centroidBounds = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
            for (let i = start; i < end; ++i) {
                centroidBounds.expand(primitiveInfos[i].centroid);
            }
            const dim = centroidBounds.longestAxis();

            // Partition primitives based on SAH
            let mid = start; // Default mid if no good split found
            if (centroidBounds.max[dim] === centroidBounds.min[dim]) {
                // If centroids are all aligned on this axis, just split in the middle
                mid = start + Math.floor(nPrimitives / 2);
            } else {
                // Use SAH to find the best split
                const nBuckets = 12;
                const buckets = Array(nBuckets).fill(null).map(() => ({ count: 0, bounds: new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]) }));

                for (let i = start; i < end; ++i) {
                    let b = Math.floor(nBuckets * ((primitiveInfos[i].centroid[dim] - centroidBounds.min[dim]) / (centroidBounds.max[dim] - centroidBounds.min[dim])));
                    b = Math.max(0, Math.min(nBuckets - 1, b)); // Clamp b to [0, nBuckets-1]
                    buckets[b].count++;
                    buckets[b].bounds.union(primitiveInfos[i].bounds);
                }

                const cost = Array(nBuckets - 1).fill(0);
                for (let i = 0; i < nBuckets - 1; ++i) {
                    let b0 = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
                    let b1 = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
                    let count0 = 0, count1 = 0;
                    for (let j = 0; j <= i; ++j) {
                        b0.union(buckets[j].bounds);
                        count0 += buckets[j].count;
                    }
                    for (let j = i + 1; j < nBuckets; ++j) {
                        b1.union(buckets[j].bounds);
                        count1 += buckets[j].count;
                    }
                    cost[i] = 0.1 + (count0 * b0.surfaceArea() + count1 * b1.surfaceArea()) / bounds.surfaceArea();
                }

                let minCost = cost[0];
                let minCostSplitBucket = 0;
                for (let i = 1; i < nBuckets - 1; ++i) {
                    if (cost[i] < minCost) {
                        minCost = cost[i];
                        minCostSplitBucket = i;
                    }
                }
                
                // Partition primitives based on the best split
                const pmid = primitiveInfos.slice(start, end).sort((a, b) => a.centroid[dim] - b.centroid[dim]);
                primitiveInfos.splice(start, nPrimitives, ...pmid);

                let currentMid = start;
                for(let i = start; i < end; ++i) {
                    let b = Math.floor(nBuckets * ((primitiveInfos[i].centroid[dim] - centroidBounds.min[dim]) / (centroidBounds.max[dim] - centroidBounds.min[dim])));
                    b = Math.max(0, Math.min(nBuckets - 1, b));
                    if (b <= minCostSplitBucket) {
                        [primitiveInfos[i], primitiveInfos[currentMid]] = [primitiveInfos[currentMid], primitiveInfos[i]];
                        currentMid++;
                    }
                }
                mid = currentMid;

                // If SAH fails to produce a good split, fallback to middle split
                if (mid === start || mid === end) {
                    mid = start + Math.floor(nPrimitives / 2);
                     // Sort along the chosen axis before splitting if falling back
                    const pmidFallback = primitiveInfos.slice(start, end).sort((a, b) => a.centroid[dim] - b.centroid[dim]);
                    primitiveInfos.splice(start, nPrimitives, ...pmidFallback);
                }
            }
            
            node.leftChildOrFirstPrimitiveIndex = flattenedNodes.length; // Left child will be next in the array
            buildBvhRecursive(primitives, primitiveInfos, start, mid, totalPrimitives, flattenedNodes, orderedPrimitiveIndices);
            buildBvhRecursive(primitives, primitiveInfos, mid, end, totalPrimitives, flattenedNodes, orderedPrimitiveIndices);
        }
        return nodeIndex;
    }

    function buildBvhStructure(primitives) {
        // Primitives here are expected to be simplified: { position: [x,y,z], radius: r, originalIndex: i }
        if (!primitives || primitives.length === 0) {
            return { bvhNodes: [], primitiveIndices: [] };
        }

        const primitiveInfos = primitives.map((p, i) => {
            const bounds = AABB.fromSphere(p);
            return {
                originalIndex: p.originalIndex !== undefined ? p.originalIndex : i, // Use originalIndex if provided
                bounds: bounds,
                centroid: bounds.centroid()
            };
        });

        const flattenedNodes = [];
        const orderedPrimitiveIndices = []; // This will store the reordered primitive indices for leaf nodes

        buildBvhRecursive(primitives, primitiveInfos, 0, primitiveInfos.length, primitiveInfos.length, flattenedNodes, orderedPrimitiveIndices);

        const bvhNodesFlat = new Float32Array(flattenedNodes.length * 12);
        flattenedNodes.forEach((node, i) => {
            let offset = i * 12;
            bvhNodesFlat[offset + 0] = node.minBounds[0];
            bvhNodesFlat[offset + 1] = node.minBounds[1];
            bvhNodesFlat[offset + 2] = node.minBounds[2];
            bvhNodesFlat[offset + 3] = node.isLeaf;

            bvhNodesFlat[offset + 4] = node.maxBounds[0];
            bvhNodesFlat[offset + 5] = node.maxBounds[1];
            bvhNodesFlat[offset + 6] = node.maxBounds[2];
            bvhNodesFlat[offset + 7] = node.primitiveCount;

            bvhNodesFlat[offset + 8] = node.leftChildOrFirstPrimitiveIndex;
        });

        const primitiveIndicesFlat = new Uint32Array(orderedPrimitiveIndices);

        return {
            bvhNodesFlat: bvhNodesFlat,
            primitiveIndicesFlat: primitiveIndicesFlat
        };
    }

    self.onmessage = function(event) {
        const { spheresData } = event.data;
        try {
            const { bvhNodesFlat, primitiveIndicesFlat } = buildBvhStructure(spheresData);
            self.postMessage({
                status: 'success',
                bvhNodes: bvhNodesFlat.buffer,
                primitiveIndices: primitiveIndicesFlat.buffer
            }, [bvhNodesFlat.buffer, primitiveIndicesFlat.buffer]);
        } catch (error) {
            console.error('BVH Worker Error:', error);
            self.postMessage({ status: 'error', message: error.message, stack: error.stack });
        }
    };
`;

        /**
         * @file CompuTracer.html
         * @description Main HTML file for the NovaRay WebGPU compute-based raytracer.
         * This file encapsulates all HTML, CSS, JavaScript, and WGSL shader code.
         * Developed with AI assistance, focusing on modularity and high performance.
         */

        // NovaRay Iteration: 5 - Knowledge Base Setup, Documentation & Framework Solidification

        /**
         * @object NovaRayEngine
         * @description The central orchestrator for the NovaRay WebGPU raytracer.
         * Manages WebGPU device, context, resources, shaders, scene, UI, and the main render loop.
         * It also holds global state related to rendering and input.
         */
        const NovaRayEngine = {
            /** @type {GPUAdapter?} The WebGPU adapter. */
            adapter: null,
            /** @type {GPUDevice?} The WebGPU logical device. */
            device: null,
            /** @type {GPUCanvasContext?} The context for the WebGPU canvas. */
            context: null,
            /** @type {GPUTextureFormat?} The preferred format for the canvas presentation. */
            presentationFormat: null,
            /** @type {HTMLCanvasElement?} The HTML canvas element for rendering. */
            canvas: null,

            /** @type {Worker?} Web Worker for asynchronous BVH construction. */
            bvhWorker: null,
            /** @type {boolean} Flag indicating if BVH construction is currently in progress. */
            isBVHBuilding: false,
            /** @type {Array<Object>} Stores the latest sphere data for the BVH worker. */
            latestSphereDataForWorker: [],
            /** @type {Promise?} Promise for managing BVH update completion. */
            bvhUpdatePromise: null,

            /** @type {object?} Manages GPU resource creation (buffers, textures, samplers). */
            resourceManager: null,
            /** @type {object?} Manages WGSL shader code and pipeline compilation. */
            shaderManager: null,
            /** @type {SceneManager?} Manages scene data, objects, and related logic. */
            sceneManager: null,
            /** @type {UIManager?} Manages UI elements, interactions, and view state. */
            uiManager: null,

            /** @type {GPUComputePipeline?} Main compute pipeline for raytracing. */
            computePipeline: null,
            /** @type {GPURenderPipeline?} Pipeline for rendering the final image to canvas. */
            renderPipeline: null,
            /** @type {GPUComputePipeline?} Pipeline for the 3D noise generation compute shader. */
            noise3DComputePipeline: null,

            /** @type {GPUTexture?} Primary output texture for ping-pong accumulation. */
            outputTexture0: null,
            /** @type {GPUTexture?} Secondary output texture for ping-pong accumulation. */
            outputTexture1: null,
            /** @type {GPUTextureView?} View for outputTexture0. */
            outputTextureView0: null,
            /** @type {GPUTextureView?} View for outputTexture1. */
            outputTextureView1: null,
            /** @type {GPUSampler?} Sampler for the final render pass. */
            outputSampler: null,

            /** @type {GPUTexture?} 3D texture to store generated noise. */
            noiseTexture3D: null,
            /** @type {GPUTextureView?} View for the 3D noise texture. */
            noiseTexture3DView: null,
            /** @type {{width: number, height: number, depth: number}} Dimensions of the 3D noise texture. */
            noiseTextureSize: { width: 32, height: 32, depth: 32 },


            /** @type {GPUBindGroup?} Bind group 0 for main compute pass (UBOs, textures). */
            computeBindGroup0: null,
            /** @type {GPUBindGroup?} Bind group 1 for main compute pass (scene data). */
            computeBindGroup1: null,
            /** @type {GPUBindGroup?} Bind group for the render pass. */
            renderBindGroup: null,
            /** @type {GPUBuffer?} Vertex buffer for the full-screen quad in the render pass. */
            renderQuadVertexBuffer: null,

            // UBO Buffers
            cameraUBOBuffer: null,
            lightUBOBuffer: null,
            timeUBOBuffer: null,
            waterUBOBuffer: null,
            terrainUBOBuffer: null,
            raytracerUBOBuffer: null,

            // Storage Buffers
            bvhNodesBuffer: null,
            primitiveIndicesBuffer: null,
            sphereDataBuffer: null,

            // Frame / Time / Input State
            /** @type {number} Current frame count for accumulation rendering. */
            frameCount: 0,
            /** @type {number} Total elapsed time since rendering started, in seconds. */
            totalTime: 0,
            /** @type {number} Timestamp of when rendering started, for calculating totalTime. */
            startTimeForTotalTime: 0,
            /** @type {number} Index (0 or 1) indicating the current target texture for ping-ponging. */
            currentTextureIndex: 0,
            /** @type {number?} ID for the requestAnimationFrame loop. */
            animationFrameId: null,
            /** @type {boolean} Flag indicating if render accumulation needs to be reset. */
            accumulationNeedsReset: true,

            /** @type {object} State of currently pressed keys. */
            keysPressed: {},
            /** @type {boolean} Whether the mouse button is currently pressed down on the canvas. */
            isMouseDown: false,
            /** @type {number} Last recorded X coordinate of the mouse. */
            lastMouseX: 0,
            /** @type {number} Last recorded Y coordinate of the mouse. */
            lastMouseY: 0,

            /**
             * Initializes the NovaRayEngine, including WebGPU setup, manager instantiation,
             * resource creation, pipeline compilation, and scene setup.
             * @async
             * @param {HTMLCanvasElement} canvasElement - The canvas element for rendering.
             * @param {HTMLElement} loadingStatusElement - DOM element to display loading status.
             * @param {HTMLElement} errorDisplayElement - DOM element to display error messages.
             * @returns {Promise<boolean>} True if initialization was successful, false otherwise.
             */
            async initialize(canvasElement, loadingStatusElement, errorDisplayElement) {
                this.canvas = canvasElement;
                
                this.uiManager = new UIManager(this);
                this.uiManager.initDOMElements(); // UIManager caches its DOM elements early
                // Pass along the specific elements for early feedback during engine init
                this.uiManager.loadingStatusP = loadingStatusElement;
                this.uiManager.errorMessageDisplay = errorDisplayElement;
                
                this.uiManager.setLoadingStatus("Initializing NovaRay Engine...");

                try {
                    if (this.device) {
                        console.log("Destroying previous WebGPU device (simplified)...");
                         await this.device.queue.onSubmittedWorkDone().catch(e => console.warn("Error during queue sync before destroy:", e));
                        this.device.destroy();
                        console.log("Previous device destroyed.");
                        this.device = null;
                    }
                
                    this.uiManager.setLoadingStatus("Checking WebGPU support...");
                    if (!navigator.gpu) {
                        throw new Error("WebGPU not supported in your browser.");
                    }

                    this.uiManager.setLoadingStatus("Requesting GPU adapter...");
                    this.adapter = await navigator.gpu.requestAdapter();
                    if (!this.adapter) {
                        throw new Error("No appropriate GPU adapter found.");
                    }

                    this.uiManager.setLoadingStatus("Requesting GPU device...");
                    const requiredFeatures = [];
                    this.device = await this.adapter.requestDevice({requiredFeatures});
                    if (!this.device) {
                        throw new Error("Could not acquire a WebGPU device.");
                    }
                    console.log("WebGPU device successfully acquired.");
                    this.uiManager.setLoadingStatus("GPU device acquired. Initializing Resource Manager...");

                    /**
                     * @object NovaRayEngine.resourceManager
                     * @description Manages the creation of GPU resources like buffers, textures, and samplers.
                     */
                    this.resourceManager = {
                        device: this.device,
                        /**
                         * Creates a GPU buffer.
                         * @param {GPUBufferDescriptor} descriptor - The buffer descriptor.
                         * @param {string} [label="Buffer"] - Optional label for debugging.
                         * @returns {GPUBuffer} The created GPU buffer.
                         */
                        createBuffer: function(descriptor, label = "Buffer") {
                            // console.log(\`ResourceManager: Creating \${label} with descriptor:\`, descriptor);
                            return this.device.createBuffer(descriptor);
                        },
                        /**
                         * Creates a GPU texture.
                         * @param {GPUTextureDescriptor} descriptor - The texture descriptor.
                         * @param {string} [label="Texture"] - Optional label for debugging.
                         * @returns {GPUTexture} The created GPU texture.
                         */
                        createTexture: function(descriptor, label = "Texture") {
                            // console.log(\`ResourceManager: Creating \${label} with descriptor:\`, descriptor);
                            return this.device.createTexture(descriptor);
                        },
                        /**
                         * Creates a GPU sampler.
                         * @param {GPUSamplerDescriptor} descriptor - The sampler descriptor.
                         * @param {string} [label="Sampler"] - Optional label for debugging.
                         * @returns {GPUSampler} The created GPU sampler.
                         */
                        createSampler: function(descriptor, label = "Sampler") {
                            // console.log(\`ResourceManager: Creating \${label} with descriptor:\`, descriptor);
                            return this.device.createSampler(descriptor);
                        }
                    };
                    console.log("ResourceManager initialized.");
                    this.uiManager.setLoadingStatus("ResourceManager initialized. Initializing ShaderManager...");

                    /**
                     * @object NovaRayEngine.shaderManager
                     * @description Manages WGSL shader code, shader module creation, and pipeline compilation.
                     */
                    this.shaderManager = {
                        device: this.device,
                        /** @type {string} WGSL code for the main raytracing compute shader. */
                        wgslCompute: ``,
                        /** @type {string} WGSL code for the render shader (displays final image). */
                        wgslRender: ``,
                        /** @type {string} WGSL code for the 3D noise generation compute shader. */
                        wgslNoise3DCompute: ``,

                        /**
                         * Creates a GPU shader module from WGSL code.
                         * @param {string} code - The WGSL shader code.
                         * @param {string} label - A label for the shader module (for debugging).
                         * @returns {Promise<GPUShaderModule>} The created shader module.
                         * @throws Will throw an error if shader code is empty.
                         */
                        createShaderModule: async function(code, label) {
                            if (!code || code.trim() === "") {
                                throw new Error(\`ShaderManager: Shader code for \${label} is empty.\`);
                            }
                            return this.device.createShaderModule({ label, code });
                        },
                        /**
                         * Creates a GPU compute pipeline asynchronously.
                         * @param {GPUComputePipelineDescriptor} descriptor - The pipeline descriptor.
                         * @param {string} [label="Compute Pipeline"] - Optional label for debugging.
                         * @returns {Promise<GPUComputePipeline>} The created compute pipeline.
                         * @throws Will throw an error if pipeline creation fails validation.
                         */
                        createComputePipeline: async function(descriptor, label = "Compute Pipeline") {
                            this.device.pushErrorScope('validation');
                            const pipeline = await this.device.createComputePipelineAsync(descriptor);
                            const error = await this.device.popErrorScope();
                            if (error) {
                                throw new Error(\`ShaderManager: \${label} creation failed: \${error.message}\`);
                            }
                            return pipeline;
                        },
                        /**
                         * Creates a GPU render pipeline asynchronously.
                         * @param {GPURenderPipelineDescriptor} descriptor - The pipeline descriptor.
                         * @param {string} [label="Render Pipeline"] - Optional label for debugging.
                         * @returns {Promise<GPURenderPipeline>} The created render pipeline.
                         * @throws Will throw an error if pipeline creation fails validation.
                         */
                        createRenderPipeline: async function(descriptor, label = "Render Pipeline") {
                            this.device.pushErrorScope('validation');
                            const pipeline = await this.device.createRenderPipelineAsync(descriptor);
                            const error = await this.device.popErrorScope();
                            if (error) {
                                throw new Error(\`ShaderManager: \${label} creation failed: \${error.message}\`);
                            }
                            return pipeline;
                        }
                    };
                    this.shaderManager.wgslCompute = \`
                // Perlin Noise Permutation Table (512 elements = 256 duplicated)
                // CRITICAL REMINDER: Ensure all u32 literals have the 'u' suffix.
                // Syntax for array initialization is array<Type, Size>(...).
                var<private> perm: array<u32, 512> = array<u32, 512>(
                    151u, 160u, 137u, 91u, 90u, 15u, 131u, 13u, 201u, 95u, 96u, 53u, 194u, 233u, 7u, 225u,
                    140u, 36u, 103u, 30u, 69u, 142u, 8u, 99u, 37u, 240u, 21u, 10u, 23u, 190u, 6u, 148u,
                    247u, 120u, 234u, 75u, 0u, 26u, 197u, 62u, 94u, 252u, 219u, 203u, 117u, 35u, 11u, 32u,
                    57u, 177u, 33u, 88u, 237u, 149u, 56u, 87u, 178u, 119u, 246u, 76u, 138u, 161u, 134u, 107u,
                    97u, 28u, 164u, 73u, 204u, 159u, 125u, 158u, 215u, 116u, 176u, 31u, 250u, 189u, 155u, 109u,
                    144u, 20u, 93u, 63u, 128u, 91u, 124u, 66u, 165u, 179u, 113u, 220u, 243u, 166u, 136u, 61u,
                    100u, 175u, 195u, 48u, 122u, 198u, 139u, 79u, 184u, 167u, 106u, 80u, 200u, 127u, 43u, 239u,
                    77u, 181u, 129u, 232u, 251u, 248u, 47u, 185u, 49u, 224u, 245u, 153u, 168u, 13u, 130u, 24u,
                    170u, 105u, 104u, 154u, 196u, 1u, 38u, 126u, 78u, 244u, 140u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u, 110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u,
                    60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u, 197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u, 110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u,
                    60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u, 197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    // --- Start of Duplicated Elements to reach 512 ---
                    151u, 160u, 137u, 91u, 90u, 15u, 131u, 13u, 201u, 95u, 96u, 53u, 194u, 233u, 7u, 225u,
                    140u, 36u, 103u, 30u, 69u, 142u, 8u, 99u, 37u, 240u, 21u, 10u, 23u, 190u, 6u, 148u,
                    247u, 120u, 234u, 75u, 0u, 26u, 197u, 62u, 94u, 252u, 219u, 203u, 117u, 35u, 11u, 32u,
                    57u, 177u, 33u, 88u, 237u, 149u, 56u, 87u, 178u, 119u, 246u, 76u, 138u, 161u, 134u, 107u,
                    97u, 28u, 164u, 73u, 204u, 159u, 125u, 158u, 215u, 116u, 176u, 31u, 250u, 189u, 155u, 109u,
                    144u, 20u, 93u, 63u, 128u, 91u, 124u, 66u, 165u, 179u, 113u, 220u, 243u, 166u, 136u, 61u,
                    100u, 175u, 195u, 48u, 122u, 198u, 139u, 79u, 184u, 167u, 106u, 80u, 200u, 127u, 43u, 239u,
                    77u, 181u, 129u, 232u, 251u, 248u, 47u, 185u, 49u, 224u, 245u, 153u, 168u, 13u, 130u, 24u,
                    170u, 105u, 104u, 154u, 196u, 1u, 38u, 126u, 78u, 244u, 140u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u, 110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u,
                    60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u, 197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u,
                    197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u, 110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u,
                    60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u, 197u, 49u, 24u, 150u, 141u, 68u, 194u, 218u,
                    110u, 135u, 12u, 192u, 207u, 249u, 192u, 192u, 60u, 169u, 252u, 203u, 11u, 70u, 63u, 20u
                );

                // Perlin Noise Gradient Table (12 elements)
                var<private> grad3: array<vec3<f32>, 12> = array<vec3<f32>, 12>(
                    vec3<f32>(1.0f, 1.0f, 0.0f), vec3<f32>(-1.0f, 1.0f, 0.0f), vec3<f32>(1.0f, -1.0f, 0.0f), vec3<f32>(-1.0f, -1.0f, 0.0f),
                    vec3<f32>(1.0f, 0.0f, 1.0f), vec3<f32>(-1.0f, 0.0f, 1.0f), vec3<f32>(1.0f, 0.0f, -1.0f), vec3<f32>(-1.0f, 0.0f, -1.0f),
                    vec3<f32>(0.0f, 1.0f, 1.0f), vec3<f32>(0.0f, -1.0f, 1.0f), vec3<f32>(0.0f, 1.0f, -1.0f), vec3<f32>(0.0f, -1.0f, -1.0f)
                );

                // Helper for modulo 289
                fn mod289(x: vec3<f32>) -> vec3<f32> { return x - floor(x / 289.0f) * 289.0f; }
                fn mod289_f(x: f32) -> f32 { return x - floor(x / 289.0f) * 289.0f; }

                // Hash function for Perlin noise
                fn hash_grad(x: u32, y: u32, z: u32) -> u32 {
                    return perm[ (perm[ (perm[x % 256u] + y) % 256u ] + z) % 256u ];
                }
                
                // Classic Perlin Noise 3D
                fn snoise(p: vec3<f32>) -> f32 {
                    let F3 = 1.0f/3.0f;
                    let G3 = 1.0f/6.0f;
                    
                    let s = (p.x + p.y + p.z) * F3;
                    let i_float = floor(p + vec3<f32>(s, s, s));
                    let t = (i_float.x + i_float.y + i_float.z) * G3;
                    let x0 = p - i_float + vec3<f32>(t, t, t);

                    let g = step(x0.xyz, x0.yzx);
                    let l = 1.0f - g;
                    let i1 = min(g.xyz, l.yzx);
                    let i2 = max(g.xyz, l.yzx);

                    let i_u32 = vec3<u32>(u32(i_float.x), u32(i_float.y), u32(i_float.z));
                    let ii = i_u32 % 256u;

                    let x1 = x0 - i1 + G3;
                    let x2 = x0 - i2 + 2.0f * G3;
                    let x3 = x0 - 1.0f + 3.0f * G3;

                    let gi0 = hash_grad(ii.x, ii.y, ii.z);
                    let gi1 = hash_grad(ii.x + u32(i1.x), ii.y + u32(i1.y), ii.z + u32(i1.z));
                    let gi2 = hash_grad(ii.x + u32(i2.x), ii.y + u32(i2.y), ii.z + u32(i2.z));
                    let gi3 = hash_grad(ii.x + 1u, ii.y + 1u, ii.z + 1u);

                    let n0 = dot(grad3[gi0 % 12u], x0);
                    let n1 = dot(grad3[gi1 % 12u], x1);
                    let n2 = dot(grad3[gi2 % 12u], x2);
                    let n3 = dot(grad3[gi3 % 12u], x3);

                    let t0 = 0.5f - dot(x0, x0);
                    let t1 = 0.5f - dot(x1, x1);
                    let t2 = 0.5f - dot(x2, x2);
                    let t3 = 0.5f - dot(x3, x3);

                    var sum: f32 = 0.0f;
                    if (t0 >= 0.0f) { sum += pow(t0, 4.0f) * n0; }
                    if (t1 >= 0.0f) { sum += pow(t1, 4.0f) * n1; }
                    if (t2 >= 0.0f) { sum += pow(t2, 4.0f) * n2; }
                    if (t3 >= 0.0f) { sum += pow(t3, 4.0f) * n3; }

                    return 32.0f * sum;
                }

                fn rand_float(co: vec2<f32>, seed: f32) -> f32 {
                    return fract(sin(dot(co.xy + vec2<f32>(seed, seed), vec2<f32>(12.9898f, 78.233f))) * 43758.5453f);
                }

                fn fBm(p: vec3<f32>) -> f32 {
                    var total: f32 = 0.0f;
                    var frequency: f32 = 1.0f;
                    var amplitude: f32 = 0.5f;
                    for (var i: u32 = 0u; i < 8u; i = i + 1u) {
                        total += snoise(p * frequency) * amplitude;
                        frequency *= 2.0f;
                        amplitude *= 0.5f;
                    }
                    return total;
                }

                struct CameraUniform {
                    position: vec3<f32>, _padding0: f32,
                    forward: vec3<f32>, _padding1: f32,
                    right: vec3<f32>, _padding2: f32,
                    up: vec3<f32>, _padding3: f32,
                    resolution: vec2<f32>, aspect: f32, fovy: f32,
                    near: f32, far: f32, _padding4: vec2<f32>,
                };

                struct LightUniform {
                    position: vec3<f32>, brightness: f32,
                    size: f32, _padding0: vec3<f32>,
                    color: vec3<f32>, _padding1: f32,
                };

                struct Sphere {
                    position_radius: vec4<f32>,
                    albedo_metallic: vec4<f32>,
                    pbr_properties: vec4<f32>,
                };

                struct BvhNode {
                    minBounds: vec3<f32>, isLeaf: u32,
                    maxBounds: vec3<f32>, primitiveCount: u32,
                    leftChildOrFirstPrimitiveIndex: u32, _padding: vec3<u32>,
                };
                
                struct WaterParams {
                    strength: f32, frequency: f32, speed: f32, _padding: f32,
                };
                struct TerrainParams {
                    heightScale: f32, frequency: f32, _padding0: f32, _padding1: f32,
                };
                struct TimeUniform {
                    time: f32, frame_count: u32, _padding0: vec2<f32>,
                };

                struct RaytracerParams {
                    maxBounces: u32, 
                    maxRaymarchSteps: u32, 
                    shadowSamples: u32, 
                    dofSamples: u32,

                    numBVHNodes: u32,   
                    numPrimitives: u32, 
                    skyPreset: u32,     
                    _padding0: u32,

                    warpStrength: f32,  
                    focalDistance: f32, 
                    apertureSize: f32,  
                    _padding1: f32,
                };

                const MATERIAL_DIFFUSE: u32 = 0u;
                const MATERIAL_REFLECTIVE: u32 = 1u;
                const MATERIAL_REFRACTIVE: u32 = 2u;

                @group(0) @binding(0) var<uniform> cameraUBO: CameraUniform;
                @group(0) @binding(1) var<uniform> lightUBO: LightUniform;
                @group(0) @binding(2) var<uniform> raytracerUBO: RaytracerParams;
                @group(0) @binding(3) var<uniform> timeUBO: TimeUniform;
                @group(0) @binding(4) var<uniform> waterUBO: WaterParams;
                @group(0) @binding(5) var<uniform> terrainUBO: TerrainParams;
                @group(0) @binding(6) var outputTexture: texture_storage_2d<rgba32float, write>;
                @group(0) @binding(7) var inputTexture: texture_2d<f32>;

                @group(1) @binding(0) var<storage, read> spheres: array<Sphere>; 
                @group(1) @binding(1) var<storage, read> bvhNodes: array<BvhNode>; 
                @group(1) @binding(2) var<storage, read> primitiveIndices: array<u32>; 

                const MIN_DIST: f32 = 0.0001f;
                const MAX_DIST: f32 = 1000.0f;
                const EPSILON: f32 = 0.001f;
                const STACK_SIZE: u32 = 64u;
                const PI: f32 = 3.14159265359f;

                struct Ray {
                    origin: vec3<f32>,
                    direction: vec3<f32>,
                };

                struct HitInfo {
                    hit_pos: vec3<f32>,
                    normal: vec3<f32>,
                    distance: f32,
                    is_hit: bool,
                    object_id: u32,
                    sphere_idx: u32,
                    is_water: bool,
                };

                fn clamp_f(value: f32, min_val: f32, max_val: f32) -> f32 {
                    return max(min(value, max_val), min_val);
                }

                fn domainWarp(p: vec3<f32>, time: f32, strength: f32) -> vec3<f32> {
                    if (strength == 0.0f) { return p; }
                    let offset_factor = vec3<f32>(
                        snoise(p * 0.5f + time * 0.1f + vec3<f32>(10.0f, 20.0f, 30.0f)),
                        snoise(p * 0.7f - time * 0.2f + vec3<f32>(40.0f, 50.0f, 60.0f)),
                        snoise(p * 0.9f + time * 0.3f + vec3<f32>(70.0f, 80.0f, 90.0f))
                    );
                    return p + offset_factor * strength;
                }

                fn terrainHeight(x: f32, z: f32, time: f32) -> f32 {
                    if (terrainUBO.heightScale == 0.0f) { return -100000.0f; }
                    let p_large_scale = vec3<f32>(x, z, time * 0.01f) * 0.05f;
                    let large_scale_noise = fBm(p_large_scale);

                    let p_detail_scale = vec3<f32>(x, z, time * 0.05f) * terrainUBO.frequency;
                    let detail_noise = fBm(p_detail_scale);

                    let center_dist = distance(vec2<f32>(x, z), vec2<f32>(0.0f, 0.0f));
                    let island_shape_factor = smoothstep(150.0f, 0.0f, center_dist);

                    let base_height = (0.5f + 0.5f * large_scale_noise * 0.6f) + (0.5f + 0.5f * detail_noise * 0.4f);
                    let scaled_height_from_noise = (base_height / 2.0f) * terrainUBO.heightScale;
                    return max(-2.0f, scaled_height_from_noise * island_shape_factor);
                }

                fn calculateWaveHeight(x: f32, z: f32, time: f32) -> f32 {
                    var h: f32 = 0.0f;
                    let initial_freq = waterUBO.frequency;
                    let initial_strength = waterUBO.strength;
                    
                    h += sin(x * initial_freq + time * waterUBO.speed) * initial_strength * 0.7f;
                    h += cos(z * initial_freq * 1.5f + time * waterUBO.speed * 0.8f) * initial_strength * 0.5f;
                    h += sin((x + z) * initial_freq * 0.8f + time * waterUBO.speed * 1.2f) * initial_strength * 0.3f;
                    
                    return h;
                }

                fn sdWaterPlane(p: vec3<f32>, time: f32, warp_strength: f32) -> f32 {
                    let warped_p = domainWarp(p, time * 0.5f, warp_strength);
                    return warped_p.y - calculateWaveHeight(warped_p.x, warped_p.z, time);
                }

                fn sdSphere(p: vec3<f32>, s: Sphere, warp_strength: f32) -> f32 {
                    let warped_center = domainWarp(s.position_radius.xyz, timeUBO.time * 0.5f, warp_strength);
                    return distance(p, warped_center) - s.position_radius.w;
                }

                fn intersect_aabb(ray_origin: vec3<f32>, ray_inv_dir: vec3<f32>, min_bounds: vec3<f32>, max_bounds: vec3<f32>) -> f32 {
                    let t1 = (min_bounds - ray_origin) * ray_inv_dir;
                    let t2 = (max_bounds - ray_origin) * ray_inv_dir;

                    let t_min_vec = min(t1, t2);
                    let t_max_vec = max(t1, t2);

                    let t_enter = max(max(t_min_vec.x, t_min_vec.y), t_min_vec.z);
                    let t_exit = min(min(t_max_vec.x, t_max_vec.y), t_max_vec.z);

                    if (t_enter > t_exit || t_exit < 0.0f) {
                        return -1.0f;
                    }
                    return max(0.0f, t_enter);
                }

                fn bvh_scene_sdf_spheres(ray_origin: vec3<f32>, ray_direction: vec3<f32>, 
                                         current_time: f32, warp_strength: f32, 
                                         closest_dist: ptr<function, f32>, closest_sphere_idx: ptr<function, u32>) {
                    
                    if (raytracerUBO.numPrimitives == 0u || raytracerUBO.numBVHNodes == 0u) { return; } 

                    var inv_dir = 1.0f / ray_direction;
                    var node_stack: array<u32, STACK_SIZE>;
                    var stack_ptr: u32 = 0u;
                    var current_node_idx = 0u;

                    for (var iter: u32 = 0u; iter < 1024u; iter = iter + 1u) {
                        if (stack_ptr >= STACK_SIZE) { break; }
                        if (current_node_idx >= raytracerUBO.numBVHNodes) { break; }

                        let node = bvhNodes[current_node_idx];
                        let t = intersect_aabb(ray_origin, inv_dir, node.minBounds, node.maxBounds);

                        if (t == -1.0f || t > *closest_dist) { 
                            if (stack_ptr == 0u) { break; }
                            stack_ptr = stack_ptr - 1u;
                            current_node_idx = node_stack[stack_ptr];
                            continue;
                        }

                        if (node.isLeaf == 1u) {
                            for (var i: u32 = 0u; i < node.primitiveCount; i = i + 1u) {
                                let sphere_original_idx = primitiveIndices[node.leftChildOrFirstPrimitiveIndex + i];
                                if (sphere_original_idx >= raytracerUBO.numPrimitives) { continue; }
                                let s = spheres[sphere_original_idx];
                                let d = sdSphere(ray_origin, s, warp_strength);
                                if (d < *closest_dist) {
                                    *closest_dist = d;
                                    *closest_sphere_idx = sphere_original_idx;
                                }
                            }
                            if (stack_ptr == 0u) { break; }
                            stack_ptr = stack_ptr - 1u;
                            current_node_idx = node_stack[stack_ptr];
                        } else {
                            let left_child_idx = node.leftChildOrFirstPrimitiveIndex;
                            let right_child_idx = node.leftChildOrFirstPrimitiveIndex + 1u;

                            if (left_child_idx >= raytracerUBO.numBVHNodes || right_child_idx >= raytracerUBO.numBVHNodes) { 
                                if (stack_ptr == 0u) { break; }
                                stack_ptr = stack_ptr - 1u;
                                current_node_idx = node_stack[stack_ptr];
                                continue;
                            }

                            let t_left = intersect_aabb(ray_origin, inv_dir, bvhNodes[left_child_idx].minBounds, bvhNodes[left_child_idx].maxBounds);
                            let t_right = intersect_aabb(ray_origin, inv_dir, bvhNodes[right_child_idx].minBounds, bvhNodes[right_child_idx].maxBounds);

                            if (t_left != -1.0f && t_right != -1.0f) { 
                                if (t_left < t_right) {
                                    node_stack[stack_ptr] = right_child_idx; 
                                    stack_ptr = stack_ptr + 1u;
                                    current_node_idx = left_child_idx; 
                                } else {
                                    node_stack[stack_ptr] = left_child_idx; 
                                    stack_ptr = stack_ptr + 1u;
                                    current_node_idx = right_child_idx; 
                                }
                            } else if (t_left != -1.0f) {
                                current_node_idx = left_child_idx;
                            } else if (t_right != -1.0f) {
                                current_node_idx = right_child_idx;
                            } else {
                                if (stack_ptr == 0u) { break; }
                                stack_ptr = stack_ptr - 1u;
                                current_node_idx = node_stack[stack_ptr]; 
                            }
                        }
                    }
                }

                fn sceneSDF(p: vec3<f32>, current_time: f32, warp_strength: f32, object_id: ptr<function, u32>) -> f32 {
                    var min_dist: f32 = MAX_DIST;
                    *object_id = 999u;

                    let terrain_dist = p.y - terrainHeight(p.x, p.z, current_time);
                    if (terrain_dist < min_dist) {
                        min_dist = terrain_dist;
                        *object_id = 0u;
                    }

                    let water_dist = sdWaterPlane(p, current_time, warp_strength);
                    if (water_dist < min_dist) {
                        min_dist = water_dist;
                        *object_id = 1u;
                    }
                    
                    var closest_sphere_dist = MAX_DIST;
                    var closest_sphere_original_idx: u32 = 0u;
                    bvh_scene_sdf_spheres(p, vec3<f32>(0.0f, 0.0f, 0.0f), current_time, warp_strength, &closest_sphere_dist, &closest_sphere_original_idx);
                    if (closest_sphere_dist < min_dist) {
                        min_dist = closest_sphere_dist;
                        *object_id = closest_sphere_original_idx + 2u;
                    }
                    return min_dist;
                }

                fn estimateNormal(p: vec3<f32>, current_time: f32, warp_strength: f32, object_id_hint: u32) -> vec3<f32> {
                    var id_dummy: u32 = 0u;
                    let grad_x = sceneSDF(p + vec3<f32>(EPSILON, 0.0f, 0.0f), current_time, warp_strength, &id_dummy) - sceneSDF(p - vec3<f32>(EPSILON, 0.0f, 0.0f), current_time, warp_strength, &id_dummy);
                    let grad_y = sceneSDF(p + vec3<f32>(0.0f, EPSILON, 0.0f), current_time, warp_strength, &id_dummy) - sceneSDF(p - vec3<f32>(0.0f, EPSILON, 0.0f), current_time, warp_strength, &id_dummy);
                    let grad_z = sceneSDF(p + vec3<f32>(0.0f, 0.0f, EPSILON), current_time, warp_strength, &id_dummy) - sceneSDF(p - vec3<f32>(0.0f, 0.0f, EPSILON), current_time, warp_strength, &id_dummy);
                    return normalize(vec3<f32>(grad_x, grad_y, grad_z));
                }

                fn calculateWaterNormal(p: vec3<f32>, time: f32, warp_strength: f32) -> vec3<f32> {
                    let warped_p = domainWarp(p, time * 0.5f, warp_strength);
                    let x = warped_p.x;
                    let z = warped_p.z;
                    let h_base = calculateWaveHeight(x, z, time);
                    let eps = 0.001f;
                    let h_x = calculateWaveHeight(x + eps, z, time);
                    let h_z = calculateWaveHeight(x, z + eps, time);
                    let nx = -(h_x - h_base) / eps;
                    let ny = 1.0f;
                    let nz = -(h_z - h_base) / eps;
                    return normalize(vec3<f32>(nx, ny, nz));
                }

                fn calculateTerrainNormal(p: vec3<f32>, current_time: f32, warp_strength: f32) -> vec3<f32> {
                    let warped_p = domainWarp(p, current_time * 0.5f, warp_strength);
                    let x = warped_p.x;
                    let z = warped_p.z;
                    let h_base = terrainHeight(x, z, current_time);
                    let eps = 0.001f;
                    let h_x = terrainHeight(x + eps, z, current_time);
                    let h_z = terrainHeight(x, z + eps, current_time);
                    let nx = -(h_x - h_base) / eps;
                    let ny = 1.0f;
                    let nz = -(h_z - h_base) / eps;
                    return normalize(vec3<f32>(nx, ny, nz));
                }

                fn raymarch(ray: Ray, current_time: f32, warp_strength: f32) -> HitInfo {
                    var hit_info: HitInfo;
                    hit_info.is_hit = false;
                    hit_info.distance = MAX_DIST;
                    hit_info.sphere_idx = 0u;
                    hit_info.is_water = false;

                    var total_distance_marched: f32 = 0.0f;
                    var current_object_id_in_loop: u32 = 999u;

                    for (var i: u32 = 0u; i < raytracerUBO.maxRaymarchSteps; i = i + 1u) {
                        let current_pos = ray.origin + ray.direction * total_distance_marched;
                        let d = sceneSDF(current_pos, current_time, warp_strength, &current_object_id_in_loop);

                        if (d < MIN_DIST) {
                            hit_info.is_hit = true;
                            hit_info.hit_pos = current_pos;
                            hit_info.distance = total_distance_marched;
                            hit_info.object_id = current_object_id_in_loop;

                            if (current_object_id_in_loop == 1u) {
                                hit_info.normal = calculateWaterNormal(current_pos, current_time, warp_strength);
                                hit_info.is_water = true;
                            } else if (current_object_id_in_loop == 0u) {
                                hit_info.normal = calculateTerrainNormal(current_pos, current_time, warp_strength);
                                hit_info.is_water = false;
                            }
                            else {
                                hit_info.sphere_idx = current_object_id_in_loop - 2u;
                                hit_info.normal = estimateNormal(current_pos, current_time, warp_strength, current_object_id_in_loop);
                                hit_info.is_water = false;
                            }
                            break;
                        }

                        total_distance_marched += d;
                        if (total_distance_marched >= MAX_DIST) {
                            break;
                        }
                    }
                    return hit_info;
                }

                fn getSkyColor(ray_dir: vec3<f32>, sky_preset: u32) -> vec3<f32> {
                    let sun_dir = normalize(lightUBO.position.xyz);
                    let sun_dot = dot(ray_dir, sun_dir);
                    let sun_intensity = smoothstep(0.99f, 1.0f, sun_dot);
                    let sun_color_base = lightUBO.color * sun_intensity * lightUBO.brightness; 

                    var sky_color_top: vec3<f32>;
                    var sky_color_horizon: vec3<f32>;

                    if (sky_preset == 0u) {
                        sky_color_top = vec3<f32>(0.5f, 0.7f, 1.0f);
                        sky_color_horizon = vec3<f32>(0.7f, 0.8f, 0.9f);
                    } else {
                        sky_color_top = vec3<f32>(0.6f, 0.7f, 0.85f);
                        sky_color_horizon = vec3<f32>(1.0f, 0.8f, 0.6f);
                    }

                    let y_factor = max(0.0f, ray_dir.y);
                    let gradient_color = mix(sky_color_horizon, sky_color_top, y_factor);

                    let cloud_coverage: f32 = 0.5f;
                    let cloud_density: f32 = 0.8f;
                    let cloud_detail: f32 = 0.1f;
                    
                    let cloud_uv = ray_dir.xz * 10.0f;
                    let cloud_noise = snoise(vec3<f32>(cloud_uv.x, ray_dir.y * 5.0f, cloud_uv.y + timeUBO.time * 0.05f));
                    let clouds = smoothstep(cloud_coverage - cloud_detail, cloud_coverage + cloud_detail, cloud_noise) * cloud_density;
                    
                    let final_sky_color = mix(gradient_color, vec3<f32>(0.9f, 0.9f, 0.9f), clouds);
                    return final_sky_color + sun_color_base;
                }

                fn DistributionGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {
                    let a = roughness*roughness;
                    let a2 = a*a;
                    let NdotH = max(dot(N, H), 0.0f);
                    let NdotH2 = NdotH*NdotH;
                    let nom   = a2;
                    var denom = (NdotH2 * (a2 - 1.0f) + 1.0f);
                    denom = PI * denom * denom;
                    return nom / max(denom, 0.0000001f);
                }

                fn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
                    let r = (roughness + 1.0f);
                    let k = (r*r) / 8.0f;
                    let nom   = NdotV;
                    let denom = NdotV * (1.0f - k) + k;
                    return nom / max(denom, 0.0000001f);
                }

                fn GeometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {
                    let NdotV = max(dot(N, V), 0.0f);
                    let NdotL = max(dot(N, L), 0.0f);
                    let ggx2 = GeometrySchlickGGX(NdotV, roughness);
                    let ggx1 = GeometrySchlickGGX(NdotL, roughness);
                    return ggx1 * ggx2;
                }

                fn FresnelSchlickPBR(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {
                    return F0 + (vec3<f32>(1.0f) - F0) * pow(clamp(1.0f - cosTheta, 0.0f, 1.0f), 5.0f);
                }

                fn calculateLighting(hit_pos: vec3<f32>, N: vec3<f32>, V: vec3<f32>, current_time: f32,
                                     albedo: vec3<f32>, metallic: f32, roughness: f32, base_reflectivity: f32, 
                                     is_in_water_medium_flag: u32, global_id_xy: vec2<u32>) -> vec3<f32> { 
                    
                    var Lo = vec3<f32>(0.0f);
                    var ambient_color = albedo * 0.02f;
                    if (is_in_water_medium_flag == 1u) { ambient_color = albedo * 0.04f; }

                    let F0 = mix(vec3<f32>(base_reflectivity), albedo, metallic); 

                    let num_shadow_samples = max(1u, raytracerUBO.shadowSamples);
                    let light_center_dir = normalize(lightUBO.position.xyz - hit_pos);
                    let light_to_hit_dist = distance(lightUBO.position.xyz, hit_pos);
                    
                    var light_basis_u = normalize(cross(light_center_dir, vec3<f32>(0.0f, 1.0f, 0.0f)));
                    if (length(light_basis_u) < 0.1f) {
                        light_basis_u = normalize(cross(light_center_dir, vec3<f32>(1.0f, 0.0f, 0.0f)));
                    }
                    let light_basis_v = cross(light_basis_u, light_center_dir);

                    for (var s_idx: u32 = 0u; s_idx < num_shadow_samples; s_idx = s_idx + 1u) {
                        let rand_u_val = rand_float(vec2<f32>(f32(global_id_xy.x), f32(global_id_xy.y)), timeUBO.time * 1.3f + f32(s_idx) * 7.7f);
                        let rand_v_val = rand_float(vec2<f32>(f32(global_id_xy.y), f32(global_id_xy.x)), timeUBO.time * 0.7f + f32(s_idx) * 11.3f);
                        
                        let angle = rand_u_val * 2.0f * PI;
                        let radius_scale = sqrt(rand_v_val);
                        let offset_x = cos(angle) * radius_scale * lightUBO.size;
                        let offset_y = sin(angle) * radius_scale * lightUBO.size;

                        let perturbed_light_pos = lightUBO.position.xyz + light_basis_u * offset_x + light_basis_v * offset_y;
                        let L = normalize(perturbed_light_pos - hit_pos);

                        let shadow_ray_origin = hit_pos + N * MIN_DIST;
                        let occluder_dist = raymarch(Ray(shadow_ray_origin, L), current_time, raytracerUBO.warpStrength).distance; 

                        let shadow_factor = select(0.0f, 1.0f, occluder_dist >= light_to_hit_dist - MIN_DIST);
                        
                        if (shadow_factor > 0.0f) {
                            let H = normalize(V + L);
                            let NdotL = max(dot(N, L), 0.0f);
                            let NdotV = max(dot(N, V), 0.0f);
                            let NdotH = max(dot(N, H), 0.0f);
                            let VdotH = max(dot(V, H), 0.0f);

                            let D = DistributionGGX(N, H, roughness);
                            let G = GeometrySmith(N, V, L, roughness);
                            let F = FresnelSchlickPBR(VdotH, F0); 

                            let numerator = D * G * F;
                            let denominator = 4.0f * NdotV * NdotL;
                            let specular_brdf = numerator / max(denominator, 0.0000001f); 

                            let kS = F; 
                            var kD = vec3<f32>(1.0f) - kS;
                            kD *= (1.0f - metallic);

                            let diffuse_brdf = kD * albedo / PI;
                            let radiance = lightUBO.brightness * lightUBO.color; 
                            Lo += (diffuse_brdf + specular_brdf) * radiance * NdotL * shadow_factor;
                        }
                    }
                    Lo /= f32(num_shadow_samples);
                    return ambient_color + Lo;
                }

                fn snellsLaw(incident_dir: vec3<f32>, normal: vec3<f32>, n1: f32, n2: f32) -> vec3<f32> {
                    let cosThetaI = dot(-incident_dir, normal);
                    let clamped_cosThetaI = clamp(cosThetaI, -1.0f, 1.0f); 
                    
                    let eta = n1 / n2;
                    let sinThetaT2 = eta * eta * (1.0f - clamped_cosThetaI * clamped_cosThetaI);
                    
                    if (sinThetaT2 > 1.0f) { return vec3<f32>(0.0f); } 
                    
                    let cosThetaT = sqrt(1.0f - sinThetaT2);
                    return eta * incident_dir + (eta * clamped_cosThetaI - cosThetaT) * normal;
                }

                fn fresnelSchlick(cos_theta_i: f32, n1: f32, n2: f32) -> f32 {
                    let R0 = pow((n1 - n2) / (n1 + n2), 2.0f);
                    return R0 + (1.0f - R0) * pow(1.0f - cos_theta_i, 5.0f);
                }

                fn get_ior_and_normal(incident_dir: vec3<f32>, normal: vec3<f32>, current_medium_ior: f32, object_ior: f32) -> array<f32, 6> {
                    var n1 = current_medium_ior;
                    var n2 = object_ior;
                    var adjusted_normal = normal;
                    var is_entering_object_float: f32 = 1.0f;

                    if (dot(incident_dir, normal) > 0.0f) {
                        adjusted_normal = -normal;
                        n1 = object_ior;
                        n2 = current_medium_ior;
                        is_entering_object_float = 0.0f;
                    }
                    return array<f32, 6>(n1, n2, adjusted_normal.x, adjusted_normal.y, adjusted_normal.z, is_entering_object_float);
                }

                fn get_color_from_sub_hit(ray: Ray, current_time: f32, is_sub_ray_in_water_medium_flag: u32, global_id_xy: vec2<u32>) -> vec3<f32> {
                    let hit_info = raymarch(ray, current_time, raytracerUBO.warpStrength); 

                    if (!hit_info.is_hit) {
                        return getSkyColor(ray.direction, raytracerUBO.skyPreset); 
                    } else if (hit_info.object_id == 0u) {
                        let terrain_albedo = vec3<f32>(0.4f, 0.3f, 0.2f);
                        let terrain_metallic = 0.0f;
                        let terrain_roughness = 0.9f;
                        let terrain_base_reflectivity = 0.04f;
                        return calculateLighting(hit_info.hit_pos, hit_info.normal, -ray.direction, current_time, terrain_albedo, terrain_metallic, terrain_roughness, terrain_base_reflectivity, is_sub_ray_in_water_medium_flag, global_id_xy);
                    } else if (hit_info.object_id == 1u) {
                        let water_albedo = vec3<f32>(0.1f, 0.3f, 0.5f);
                        let water_metallic = 0.0f;
                        let water_roughness = 0.1f;
                        let water_base_reflectivity = 0.04f; 
                        return calculateLighting(hit_info.hit_pos, hit_info.normal, -ray.direction, current_time, water_albedo, water_metallic, water_roughness, water_base_reflectivity, is_sub_ray_in_water_medium_flag, global_id_xy);
                    } else {
                        let s = spheres[hit_info.sphere_idx];
                        let albedo = s.albedo_metallic.xyz;
                        let metallic = s.albedo_metallic.w;
                        let roughness = s.pbr_properties.x;
                        let base_reflectivity = s.pbr_properties.y;
                        return calculateLighting(hit_info.hit_pos, hit_info.normal, -ray.direction, current_time, albedo, metallic, roughness, base_reflectivity, is_sub_ray_in_water_medium_flag, global_id_xy);
                    }
                }

                fn traceRay(initial_ray: Ray, current_time: f32, global_id_xy: vec2<u32>) -> vec4<f32> { 
                    var final_color = vec3<f32>(0.0f);
                    var current_ray = initial_ray;
                    var current_weight = vec3<f32>(1.0f);
                    var current_ior = 1.0f;
                    let water_ior = 1.33f;
                    var is_in_water_medium_trace: u32 = 0u;

                    for (var bounce_count: u32 = 0u; bounce_count < raytracerUBO.maxBounces; bounce_count = bounce_count + 1u) {
                        let hit_info = raymarch(current_ray, current_time, raytracerUBO.warpStrength); 

                        if (!hit_info.is_hit) {
                            final_color += current_weight * getSkyColor(current_ray.direction, raytracerUBO.skyPreset); 
                            break;
                        }

                        let N = hit_info.normal;
                        let hit_pos = hit_info.hit_pos;
                        let V = -current_ray.direction;
                        
                        is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);

                        if (hit_info.object_id == 0u) {
                            let terrain_albedo = vec3<f32>(0.4f, 0.3f, 0.2f);
                            let terrain_metallic = 0.0f;
                            let terrain_roughness = 0.9f;
                            let terrain_base_reflectivity = 0.04f;
                            final_color += current_weight * calculateLighting(hit_pos, N, V, current_time, terrain_albedo, terrain_metallic, terrain_roughness, terrain_base_reflectivity, is_in_water_medium_trace, global_id_xy);
                            break;
                        }
                        else if (hit_info.object_id == 1u) {
                            let water_surface_albedo = vec3<f32>(0.1f, 0.3f, 0.5f);
                            let water_body_color_absorption = vec3<f32>(0.1f, 0.2f, 0.3f);
                            let water_metallic = 0.0f;
                            let water_roughness = 0.1f;
                            let water_base_reflectivity = 0.04f; 

                            let iors_info = get_ior_and_normal(current_ray.direction, N, current_ior, water_ior);
                            let n1 = iors_info[0];
                            let n2 = iors_info[1];
                            let adjusted_normal = vec3<f32>(iors_info[2], iors_info[3], iors_info[4]);
                            let is_entering_object = u32(iors_info[5]);

                            final_color += current_weight * calculateLighting(hit_pos, N, V, current_time, water_surface_albedo, water_metallic, water_roughness, water_base_reflectivity, is_in_water_medium_trace, global_id_xy);

                            let reflected_dir = reflect(current_ray.direction, adjusted_normal);
                            let reflected_ray = Ray(hit_pos + reflected_dir * EPSILON, reflected_dir);
                            
                            let refracted_dir = snellsLaw(current_ray.direction, adjusted_normal, n1, n2);
                            let cos_theta_i = dot(-current_ray.direction, adjusted_normal);
                            let fresnel_reflectance = fresnelSchlick(cos_theta_i, n1, n2);

                            if (length(refracted_dir) > 0.0f && length(refracted_dir) > 0.001f) {
                                final_color += current_weight * fresnel_reflectance * get_color_from_sub_hit(reflected_ray, current_time, is_in_water_medium_trace, global_id_xy);
                                current_ray = Ray(hit_pos + refracted_dir * EPSILON * -1.0f, refracted_dir);
                                current_weight *= water_body_color_absorption * (1.0f - fresnel_reflectance);
                                current_ior = n2;
                                is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);
                            } else {
                                current_ray = reflected_ray;
                                final_color += current_weight * fresnel_reflectance * get_color_from_sub_hit(reflected_ray, current_time, is_in_water_medium_trace, global_id_xy);
                                current_weight *= water_surface_albedo;
                                break;
                            }
                        }
                        else {
                            let s = spheres[hit_info.sphere_idx];
                            let albedo = s.albedo_metallic.xyz;
                            let metallic = s.albedo_metallic.w;
                            let roughness = s.pbr_properties.x;
                            let base_reflectivity = s.pbr_properties.y;
                            let material_type = u32(s.pbr_properties.z);
                            let refractive_index_object = s.pbr_properties.w;

                            final_color += current_weight * calculateLighting(hit_pos, N, V, current_time, albedo, metallic, roughness, base_reflectivity, is_in_water_medium_trace, global_id_xy);

                            if (material_type == MATERIAL_DIFFUSE) {
                                break;
                            } else if (material_type == MATERIAL_REFLECTIVE) {
                                let reflected_dir = reflect(current_ray.direction, N);
                                current_ray = Ray(hit_pos + reflected_dir * EPSILON, reflected_dir);
                                current_weight *= albedo;
                            } else if (material_type == MATERIAL_REFRACTIVE) {
                                let iors_info = get_ior_and_normal(current_ray.direction, N, current_ior, refractive_index_object);
                                let n1 = iors_info[0];
                                let n2 = iors_info[1];
                                let adjusted_normal = vec3<f32>(iors_info[2], iors_info[3], iors_info[4]);
                                
                                let cos_theta_i = dot(-current_ray.direction, adjusted_normal);
                                let fresnel_reflectance = fresnelSchlick(cos_theta_i, n1, n2);
                                let reflected_dir = reflect(current_ray.direction, adjusted_normal);
                                let reflected_ray_for_calc = Ray(hit_pos + reflected_dir * EPSILON, reflected_dir);

                                let reflected_contrib_color = get_color_from_sub_hit(reflected_ray_for_calc, current_time, is_in_water_medium_trace, global_id_xy);
                                final_color += current_weight * fresnel_reflectance * reflected_contrib_color;

                                let refracted_dir = snellsLaw(current_ray.direction, adjusted_normal, n1, n2);

                                if (length(refracted_dir) > 0.0f && length(refracted_dir) > 0.001f) {
                                    let refracted_ray_for_calc = Ray(hit_pos + refracted_dir * EPSILON * -1.0f, refracted_dir);
                                    let refracted_contrib_color = get_color_from_sub_hit(refracted_ray_for_calc, current_time, select(0u, 1u, n2 > 1.01f), global_id_xy);
                                    final_color += current_weight * (1.0f - fresnel_reflectance) * albedo * refracted_contrib_color;
                                    current_ior = n2;
                                    is_in_water_medium_trace = select(0u, 1u, current_ior > 1.01f);
                                }
                                break;
                            }
                        }
                        if (max(max(current_weight.x, current_weight.y), current_weight.z) < 0.01f) {
                            break;
                        }
                    }
                    return vec4<f32>(final_color, 1.0f);
                }

                @compute @workgroup_size(8, 8)
                fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                    let screen_width = cameraUBO.resolution.x; 
                    let screen_height = cameraUBO.resolution.y;

                    if (global_id.x >= u32(screen_width) || global_id.y >= u32(screen_height)) {
                        return;
                    }

                    var final_accumulated_color = vec3<f32>(0.0f);
                    let frag_coord_xy = vec2<f32>(f32(global_id.x), f32(global_id.y));

                    for (var dof_idx: u32 = 0u; dof_idx < raytracerUBO.dofSamples; dof_idx = dof_idx + 1u) {
                        let rand_u_dof = rand_float(frag_coord_xy, timeUBO.time * 2.1f + f32(dof_idx) * 5.9f);
                        let rand_v_dof = rand_float(frag_coord_xy.yx, timeUBO.time * 1.7f + f32(dof_idx) * 9.1f);

                        let angle_dof = rand_u_dof * 2.0f * PI;
                        let radius_scale = sqrt(rand_v_dof);
                        let aperture_offset_x = cos(angle_dof) * radius_scale * raytracerUBO.apertureSize; 
                        let aperture_offset_y = sin(angle_dof) * radius_scale * raytracerUBO.apertureSize;

                        let perturbed_origin = cameraUBO.position.xyz + 
                                               cameraUBO.right.xyz * aperture_offset_x + 
                                               cameraUBO.up.xyz * aperture_offset_y;

                        let ndc_x: f32 = (f32(global_id.x) / screen_width) * 2.0f - 1.0f;
                        let ndc_y: f32 = (1.0f - f32(global_id.y) / screen_height) * 2.0f - 1.0f;

                        let aspect_ratio = cameraUBO.aspect; 
                        let fov_rad = cameraUBO.fovy; 

                        let ray_x = ndc_x * aspect_ratio * tan(fov_rad / 2.0f);
                        let ray_y = ndc_y * tan(fov_rad / 2.0f);
                        let ray_z = -1.0f;

                        let ray_dir_camera_space = normalize(vec3<f32>(ray_x, ray_y, ray_z));

                        let ideal_ray_direction_world = normalize(
                            ray_dir_camera_space.x * cameraUBO.right.xyz +
                            ray_dir_camera_space.y * cameraUBO.up.xyz +
                            ray_dir_camera_space.z * cameraUBO.forward.xyz
                        );
                        
                        let focal_point = cameraUBO.position.xyz + ideal_ray_direction_world * raytracerUBO.focalDistance; 
                        
                        let dof_ray_direction = normalize(focal_point - perturbed_origin);
                        let dof_ray = Ray(perturbed_origin, dof_ray_direction);

                        final_accumulated_color += traceRay(dof_ray, timeUBO.time, global_id.xy).xyz;
                    }

                    let final_color_per_pixel = final_accumulated_color / f32(raytracerUBO.dofSamples);

                    let previous_color_vec4 = textureLoad(inputTexture, vec2<i32>(global_id.xy), 0u);
                    let current_frame_f32 = f32(timeUBO.frame_count);
                    let blend_factor = 1.0f / (current_frame_f32 + 1.0f); 
                    let new_accumulated_color = mix(previous_color_vec4.rgb, final_color_per_pixel, blend_factor);
                    
                    textureStore(outputTexture, vec2<i32>(global_id.xy), vec4<f32>(new_accumulated_color, 1.0f));
                }
                \`;
                    this.shaderManager.wgslRender = \`
                @group(0) @binding(0) var mainSampler: sampler;
                @group(0) @binding(1) var mainTexture: texture_2d<f32>; // Samples output of compute shader (unfilterable-float type)

                var<private> uvs: array<vec2<f32>, 6> = array<vec2<f32>, 6>(
                    vec2<f32>(0.0f, 1.0f),
                    vec2<f32>(1.0f, 1.0f),
                    vec2<f32>(0.0f, 0.0f),
                    
                    vec2<f32>(0.0f, 0.0f),
                    vec2<f32>(1.0f, 1.0f),
                    vec2<f32>(1.0f, 0.0f)
                );

                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) uv: vec2<f32>,
                };

                @vertex
                fn vert_main(@builtin(vertex_index) vertIndex: u32) -> VertexOutput {
                    let positions = array<vec2<f32>, 6>(
                    vec2<f32>(-1.0f, -1.0f),
                    vec2<f32>( 1.0f, -1.0f),
                    vec2<f32>(-1.0f,  1.0f),
                    
                    vec2<f32>(-1.0f,  1.0f),
                    vec2<f32>( 1.0f, -1.0f),
                    vec2<f32>( 1.0f,  1.0f)
                    );
                    
                    var output: VertexOutput;
                    output.position = vec4<f32>(positions[vertIndex], 0.0f, 1.0f);
                    output.uv = uvs[vertIndex];
                    return output;
                }

                @fragment
                fn frag_main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
                    return textureSample(mainTexture, mainSampler, uv);
                }
                \`;
                    this.shaderManager.wgslNoise3DCompute = \`
                // WGSL Compute Shader for generating 3D Value Noise

                // Simple hashing function for 3D unsigned integer coordinates.
                // Takes a 3D unsigned integer vector, permutes its components, and combines them
                // to produce a pseudo-random floating point value between 0.0 and 1.0.
                fn simple_hash_3d(p: vec3<u32>) -> f32 {
                    var n = p.x * 1u + p.y * 57u + p.z * 113u; // Combine components with arbitrary multipliers
                    n = (n << 13u) ^ n; // Bitwise operations to mix bits
                    n = (n * (n * n * 15731u + 789221u) + 1376312589u); // Further mixing with large prime numbers
                    return f32(n & 0x7fffffffu) / f32(0x7fffffff); // Convert to positive float and normalize to [0, 1)
                }

                // 3D Value Noise function.
                // Generates procedural noise by hashing the corners of a cube surrounding the sample point
                // and then performing trilinear interpolation between these hashed values.
                fn value_noise_3d(coord_normalized: vec3<f32>, scale: f32) -> f32 {
                    // Scale the normalized coordinate and find the integer (p) and fractional (f) parts.
                    let p = floor(coord_normalized * scale);
                    let f = fract(coord_normalized * scale);
                    let i = vec3<u32>(p); // Integer coordinates of the cube's origin corner.

                    // Interpolation weights (smoothstep for smoother results than linear interpolation).
                    // u = f * f * (3.0 - 2.0 * f) is the smoothstep function: 3f^2 - 2f^3
                    let u = f * f * (3.0f - 2.0f * f);

                    // Hash the 8 corners of the cube.
                    let n000 = simple_hash_3d(i + vec3<u32>(0u, 0u, 0u));
                    let n100 = simple_hash_3d(i + vec3<u32>(1u, 0u, 0u));
                    let n010 = simple_hash_3d(i + vec3<u32>(0u, 1u, 0u));
                    let n110 = simple_hash_3d(i + vec3<u32>(1u, 1u, 0u));
                    let n001 = simple_hash_3d(i + vec3<u32>(0u, 0u, 1u));
                    let n101 = simple_hash_3d(i + vec3<u32>(1u, 0u, 1u));
                    let n011 = simple_hash_3d(i + vec3<u32>(0u, 1u, 1u));
                    let n111 = simple_hash_3d(i + vec3<u32>(1u, 1u, 1u));

                    // Trilinear interpolation of hashed corner values.
                    // Interpolate along x-axis for each of the 4 "front" and "back" edges.
                    let n00 = mix(n000, n100, u.x);
                    let n01 = mix(n001, n101, u.x);
                    let n10 = mix(n010, n110, u.x);
                    let n11 = mix(n011, n111, u.x);

                    // Interpolate along y-axis for the results of the x-interpolations.
                    let n0 = mix(n00, n10, u.y);
                    let n1 = mix(n01, n11, u.y);

                    // Final interpolation along z-axis.
                    return mix(n0, n1, u.z);
                }

                // Output 3D texture for storing noise values (single float channel).
                // This texture will be written to by the compute shader.
                @group(0) @binding(0) var output_noise_texture: texture_storage_3d<r32float, write>;

                // Constant defining the scale of the noise. Larger values result in higher frequency noise.
                const NOISE_SCALE: f32 = 5.0f;

                // Main compute entry point.
                // Invoked for each workgroup. global_invocation_id (id) specifies the voxel coordinates.
                @compute @workgroup_size(4, 4, 4) // Workgroup size: 4x4x4 = 64 invocations per workgroup.
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    // Get the dimensions of the output texture.
                    let texture_dims_vec = textureDimensions(output_noise_texture);
                    let texture_dims = vec3<f32>(f32(texture_dims_vec.x), f32(texture_dims_vec.y), f32(texture_dims_vec.z));

                    // Prevent out-of-bounds writes if dispatch size doesn't perfectly match texture dimensions.
                    if (id.x >= u32(texture_dims.x) || id.y >= u32(texture_dims.y) || id.z >= u32(texture_dims.z)) {
                        return;
                    }

                    // Normalize coordinates to the [0, 1] range for the noise function.
                    // Adding 0.5f to sample at the center of the voxel.
                    let normalized_coord = vec3<f32>(
                        (f32(id.x) + 0.5f) / texture_dims.x,
                        (f32(id.y) + 0.5f) / texture_dims.y,
                        (f32(id.z) + 0.5f) / texture_dims.z
                    );

                    // Calculate the noise value using the 3D value noise function.
                    let noise_val = value_noise_3d(normalized_coord, NOISE_SCALE);

                    // Store the calculated noise value (0.0 to 1.0) in the red channel of the output texture.
                    // For r32float, only the first component (r) is used.
                    textureStore(output_noise_texture, id, vec4<f32>(noise_val, 0.0, 0.0, 1.0));
                }
                \`;
                    console.log("ShaderManager initialized and shader code moved.");
                    this.uiManager.setLoadingStatus("ShaderManager initialized. Initializing SceneManager...");

                    this.sceneManager = new SceneManager(this);
                    console.log("SceneManager initialized.");
                    this.uiManager.setLoadingStatus("SceneManager initialized. Configuring canvas...");


                    this.device.lost.then((info) => {
                        console.error(\`WebGPU device lost: \${info.message}\`);
                        this.uiManager.displayErrorMessage(\`WebGPU device lost! Reason: \${info.reason}. Please try reducing settings and refresh.\`);
                        if (this.animationFrameId) {
                            cancelAnimationFrame(this.animationFrameId);
                            this.animationFrameId = null;
                        }
                        this.uiManager.switchView('menu');
                    });

                    this.context = this.canvas.getContext('webgpu');
                    if (!this.context) { throw new Error("Failed to get WebGPU context."); }

                    this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
                    this.context.configure({ device: this.device, format: this.presentationFormat, alphaMode: 'opaque', size: [this.canvas.width, this.canvas.height] });
                    console.log("Canvas context configured by NovaRayEngine.");

                    await this.createCoreResourcesAndPipelines();

                    this.uiManager.setLoadingStatus("Initializing BVH Worker (NovaRayEngine)...");
                    this.initBvhWorker();

                    this.uiManager.setLoadingStatus("Generating 3D Noise Texture...");
                    await this.createNoiseGenerationPass();



                    this.sceneManager.updateCameraUniformBuffer();
                    this.sceneManager.light.color = this.sceneManager.hsvToRgb(this.sceneManager.sunHue);
                    this.sceneManager.updateLightUniformBuffer();
                    this.sceneManager.updateTimeUniformBuffer(this.totalTime, this.frameCount);
                    this.sceneManager.updateWaterUniformBuffer();
                    this.sceneManager.updateTerrainUniformBuffer();

                    this.sceneManager.manageSpheres();

                    this.sceneManager.updateRaytracerParamsUniformBuffer();
                    this.createComputeBindGroups();

                    console.log("WebGPU initialization complete via NovaRayEngine.");
                    this.uiManager.setLoadingStatus("Initialization complete. Ready to render!");

                    this.uiManager.initEventListeners();

                    setTimeout(() => {
                        this.uiManager.switchView('scene');
                        this.uiManager.initSceneControlsUI();
                    }, 1000);
                    return true;

                } catch (error) {
                    console.error("NovaRayEngine initialization failed:", error);
                    this.uiManager.displayErrorMessage(\`NovaRayEngine Error: \${error.message}\`);
                    this.uiManager.switchView('menu');
                    return false;
                }
            },
            /**
             * Creates core GPU resources like textures, samplers, UBOs, and pipelines.
             * This method is called during engine initialization and canvas resize.
             * @async
             */
            async createCoreResourcesAndPipelines() {
                this.uiManager.setLoadingStatus("Creating textures and sampler (NovaRayEngine)...");
                if (this.outputTexture0) { this.outputTexture0.destroy(); }
                if (this.outputTexture1) { this.outputTexture1.destroy(); }
                let textureWidth = this.canvas.width;
                let textureHeight = this.canvas.height;
                this.outputTexture0 = this.resourceManager.createTexture({
                    size: { width: textureWidth, height: textureHeight },
                    format: 'rgba32float',
                    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
                }, "Output Texture 0 (Ping)");
                this.outputTextureView0 = this.outputTexture0.createView();
                this.outputTexture1 = this.resourceManager.createTexture({
                    size: { width: textureWidth, height: textureHeight },
                    format: 'rgba32float',
                    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
                }, "Output Texture 1 (Pong)");
                this.outputTextureView1 = this.outputTexture1.createView();
                console.log(\`Ping-pong textures created by NovaRayEngine with dimensions: \${textureWidth}x\${textureHeight}.\`);
                this.outputSampler = this.resourceManager.createSampler({ minFilter: 'nearest', magFilter: 'nearest' }, "Output Sampler");

                this.uiManager.setLoadingStatus("Creating uniform buffers (NovaRayEngine)...");
                this.cameraUBOBuffer = this.resourceManager.createBuffer({ size: 96, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Camera UBO");
                this.lightUBOBuffer = this.resourceManager.createBuffer({ size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Light UBO");
                this.timeUBOBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Time UBO");
                this.waterUBOBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Water UBO");
                this.terrainUBOBuffer = this.resourceManager.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Terrain UBO");
                this.raytracerUBOBuffer = this.resourceManager.createBuffer({ size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }, "Raytracer Params UBO");

                this.uiManager.setLoadingStatus("Preparing rendering assets (NovaRayEngine)...");
                const renderQuadVerticesData = new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]);
                this.renderQuadVertexBuffer = this.resourceManager.createBuffer({ size: renderQuadVerticesData.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST }, "Render Quad Vertex Buffer");
                this.device.queue.writeBuffer(this.renderQuadVertexBuffer, 0, renderQuadVerticesData);

                this.uiManager.setLoadingStatus("Compiling shaders and creating pipelines (NovaRayEngine)...");
                const computeShaderModule = await this.shaderManager.createShaderModule(this.shaderManager.wgslCompute, 'Raytracer Compute Shader');
                const renderShaderModule = await this.shaderManager.createShaderModule(this.shaderManager.wgslRender, 'Raytracer Render Shader');

                this.computePipeline = await this.shaderManager.createComputePipeline({
                    layout: this.device.createPipelineLayout({
                        bindGroupLayouts: [
                            this.device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }, { binding: 6, visibility: GPUShaderStage.COMPUTE, storageTexture: { format: 'rgba32float', access: 'write-only' } }, { binding: 7, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: 'unfilterable-float' } }, ] }),
                            this.device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }, ] }),
                        ]
                    }),
                    compute: { module: computeShaderModule, entryPoint: 'main' }
                }, "Raytracer Compute Pipeline");

                this.renderPipeline = await this.shaderManager.createRenderPipeline({
                    layout: this.device.createPipelineLayout({
                        bindGroupLayouts: [ this.device.createBindGroupLayout({ entries: [ { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: 'non-filtering' } }, { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: 'unfilterable-float' } }, ] }) ]
                    }),
                    vertex: { module: renderShaderModule, entryPoint: 'vert_main', buffers: [{ arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }], }], },
                    fragment: { module: renderShaderModule, entryPoint: 'frag_main', targets: [{ format: this.presentationFormat }] },
                    primitive: { topology: 'triangle-list' },
                }, "Raytracer Render Pipeline");

                console.log("Pipelines created by NovaRayEngine using ShaderManager.");
                this.uiManager.setLoadingStatus("Pipelines created. Resizing canvas...");
                resizeCanvasAndAssets();
            },
            /**
             * Initializes the Web Worker for asynchronous BVH (Bounding Volume Hierarchy) construction.
             */
            initBvhWorker() {
                if (this.bvhWorker) {
                    console.log("Terminating existing BVH worker.");
                    this.bvhWorker.terminate();
                    this.bvhWorker = null;
                }

                try {
                    const blob = new Blob([bvhWorkerScript], { type: 'application/javascript' });
                    this.bvhWorker = new Worker(URL.createObjectURL(blob));
                    console.log("BVH Worker initialized.");

                    this.bvhWorker.onmessage = (event) => {
                        const { status, bvhNodes, primitiveIndices, message, stack } = event.data;
                        if (status === 'success') {
                            console.log("BVH Worker completed successfully.");
                            const bvhNodesTyped = new Float32Array(bvhNodes);
                            const primitiveIndicesTyped = new Uint32Array(primitiveIndices);

                            this.sceneManager.updateGPUBuffers(this.latestSphereDataForWorker, {
                                bvhNodes: this.convertFlatBvhNodes(bvhNodesTyped),
                                primitiveIndices: Array.from(primitiveIndicesTyped)
                            });
                            this.resetAccumulation();


                        } else {
                            console.error("BVH Worker failed:", message, stack);
                            this.uiManager.displayErrorMessage(\`BVH Worker Error: \${message}\`);
                        }
                        this.isBVHBuilding = false;
                        if (this.bvhUpdatePromise && this.bvhUpdatePromise._resolve) {
                            this.bvhUpdatePromise._resolve();
                        }
                        this.bvhUpdatePromise = null;
                    };

                    this.bvhWorker.onerror = (error) => {
                        console.error("Error in BVH Worker:", error.message, error);
                        this.uiManager.displayErrorMessage(\`BVH Worker Error: \${error.message}\`);
                        this.isBVHBuilding = false;
                        if (this.bvhUpdatePromise && this.bvhUpdatePromise._reject) {
                            this.bvhUpdatePromise._reject(error);
                        }
                        this.bvhUpdatePromise = null;
                    };

                } catch (e) {
                    console.error("Failed to initialize BVH Worker:", e);
                    this.uiManager.displayErrorMessage(\`Failed to create BVH Worker: \${e.message}\`);
                    this.bvhWorker = null;
                }
            },

            convertFlatBvhNodes(flatNodes) {
                const nodes = [];
                const BVH_NODE_FLOAT_COUNT = 12;
                for (let i = 0; i < flatNodes.length / BVH_NODE_FLOAT_COUNT; i++) {
                    const node = new BvhNode();
                    let offset = i * BVH_NODE_FLOAT_COUNT;
                    node.minBounds = [flatNodes[offset + 0], flatNodes[offset + 1], flatNodes[offset + 2]];
                    node.isLeaf = flatNodes[offset + 3];
                    node.maxBounds = [flatNodes[offset + 4], flatNodes[offset + 5], flatNodes[offset + 6]];
                    node.primitiveCount = flatNodes[offset + 7];
                    node.leftChildOrFirstPrimitiveIndex = flatNodes[offset + 8];
                    nodes.push(node);
                }
                return nodes;
            },
            /**
             * Resets the frame accumulation buffer and related counters.
             * This is typically called when camera or significant scene parameters change,
             * or when the canvas is resized. It recreates ping-pong textures and their bind groups.
             */
            resetAccumulation() {
                this.frameCount = 0;
                this.currentTextureIndex = 0;
                this.accumulationNeedsReset = true;

                if (this.device && this.canvas && this.resourceManager) {
                    if (this.outputTexture0) this.outputTexture0.destroy();
                    if (this.outputTexture1) this.outputTexture1.destroy();

                    const textureDesc = {
                        size: { width: this.canvas.width, height: this.canvas.height },
                        format: 'rgba32float',
                        usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,
                    };

                    this.outputTexture0 = this.resourceManager.createTexture(textureDesc, "Output Texture 0 (Ping) - Reset Accumulation");
                    this.outputTextureView0 = this.outputTexture0.createView();
                    this.outputTexture1 = this.resourceManager.createTexture(textureDesc, "Output Texture 1 (Pong) - Reset Accumulation");
                    this.outputTextureView1 = this.outputTexture1.createView();

                    console.log('Accumulation reset: Ping-pong textures recreated.');

                    this.createComputeBindGroups();
                    this.createRenderBindGroup();
                } else {
                    console.warn("Accumulation reset attempted but NovaRayEngine not fully initialized.");
                }
            },

            /**
             * Creates bind groups for the main raytracing compute shader.
             * Assumes UBOs, storage buffers, and ping-pong textures are already created and available on `this`.
             */
            createComputeBindGroups() {
                const currentWriteTextureView = (this.currentTextureIndex === 0) ? this.outputTextureView0 : this.outputTextureView1;
                const currentReadTextureView = (this.currentTextureIndex === 0) ? this.outputTextureView1 : this.outputTextureView0;

                if (!this.device || !this.computePipeline || !currentWriteTextureView || !currentReadTextureView ||
                    !this.cameraUBOBuffer || !this.lightUBOBuffer || !this.timeUBOBuffer ||
                    !this.waterUBOBuffer || !this.terrainUBOBuffer || !this.raytracerUBOBuffer ||
                    !this.sphereDataBuffer || !this.bvhNodesBuffer || !this.primitiveIndicesBuffer) {
                    console.warn("Skipping compute bind group creation: essential resources not ready.");
                    return;
                }

                this.computeBindGroup0 = this.device.createBindGroup({
                    label: "Compute Bind Group 0 (UBOs, Textures)",
                    layout: this.computePipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: this.cameraUBOBuffer } },
                        { binding: 1, resource: { buffer: this.lightUBOBuffer } },
                        { binding: 2, resource: { buffer: this.raytracerUBOBuffer } },
                        { binding: 3, resource: { buffer: this.timeUBOBuffer } },
                        { binding: 4, resource: { buffer: this.waterUBOBuffer } },
                        { binding: 5, resource: { buffer: this.terrainUBOBuffer } },
                        { binding: 6, resource: currentWriteTextureView },
                        { binding: 7, resource: currentReadTextureView },
                    ],
                });

                this.computeBindGroup1 = this.device.createBindGroup({
                    label: "Compute Bind Group 1 (Scene Data)",
                    layout: this.computePipeline.getBindGroupLayout(1),
                    entries: [
                        { binding: 0, resource: { buffer: this.sphereDataBuffer } },
                        { binding: 1, resource: { buffer: this.bvhNodesBuffer } },
                        { binding: 2, resource: { buffer: this.primitiveIndicesBuffer } },
                    ],
                });
            },

            /**
             * Creates the bind group for the render pass, linking the correct output texture
             * that was just written to by the compute shader.
             */
            createRenderBindGroup() {
                const textureToDisplayView = (this.currentTextureIndex === 0) ? this.outputTextureView0 : this.outputTextureView1;

                if (!this.device || !this.renderPipeline || !this.outputSampler || !textureToDisplayView) {
                    console.warn("Skipping render bind group creation: essential resources not ready.");
                    return;
                }
                this.renderBindGroup = this.device.createBindGroup({
                    label: "Render Pass Bind Group",
                    layout: this.renderPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: this.outputSampler },
                        { binding: 1, resource: textureToDisplayView },
                    ],
                });
            },

            /**
             * Creates and runs a compute pass to generate a 3D noise texture.
             * Initializes this.noiseTexture3D, this.noiseTexture3DView, and this.noise3DComputePipeline.
             * This pass is executed once during initialization.
             * @async
             * @returns {Promise<void>}
             */
            async createNoiseGenerationPass() {
                if (!this.device || !this.resourceManager || !this.shaderManager) {
                    console.error("Noise generation requires device, resourceManager, and shaderManager.");
                    if(this.uiManager) this.uiManager.displayErrorMessage("Error: Noise generation resources not ready.");
                    return;
                }
                if(this.uiManager) this.uiManager.setLoadingStatus("Creating 3D noise texture resources...");

                // 1. Create Texture
                if (this.noiseTexture3D) this.noiseTexture3D.destroy();
                this.noiseTexture3D = this.resourceManager.createTexture({
                    size: this.noiseTextureSize,
                    dimension: '3d',
                    format: 'r32float',
                    usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING,
                }, "3D Noise Texture");
                this.noiseTexture3DView = this.noiseTexture3D.createView();
                console.log("3D Noise Texture and View created.");

                // 2. Create Pipeline
                if(this.uiManager) this.uiManager.setLoadingStatus("Compiling 3D noise shader...");
                const noiseModule = await this.shaderManager.createShaderModule(this.shaderManager.wgslNoise3DCompute, "3D Noise Compute Shader");

                const noisePipelineLayout = this.device.createPipelineLayout({
                    bindGroupLayouts: [
                        this.device.createBindGroupLayout({
                            entries: [{
                                binding: 0,
                                visibility: GPUShaderStage.COMPUTE,
                                storageTexture: { access: 'write-only', format: 'r32float', viewDimension: '3d' }
                            }]
                        })
                    ]
                });

                this.noise3DComputePipeline = await this.shaderManager.createComputePipeline({
                    layout: noisePipelineLayout,
                    compute: { module: noiseModule, entryPoint: 'main' }
                }, "3D Noise Compute Pipeline");
                console.log("3D Noise Compute Pipeline created.");

                // 3. Create Bind Group
                const noisePassBindGroup = this.device.createBindGroup({
                    label: "3D Noise Pass Bind Group",
                    layout: this.noise3DComputePipeline.getBindGroupLayout(0),
                    entries: [{ binding: 0, resource: this.noiseTexture3DView }]
                });
                console.log("3D Noise Pass Bind Group created.");

                // 4. Dispatch Compute Pass
                if(this.uiManager) this.uiManager.setLoadingStatus("Dispatching 3D noise generation pass...");
                const commandEncoder = this.device.createCommandEncoder({ label: "Noise Generation Encoder" });
                const passEncoder = commandEncoder.beginComputePass({ label: "3D Noise Pass" });
                passEncoder.setPipeline(this.noise3DComputePipeline);
                passEncoder.setBindGroup(0, noisePassBindGroup);
                passEncoder.dispatchWorkgroups(
                    Math.ceil(this.noiseTextureSize.width / 4),
                    Math.ceil(this.noiseTextureSize.height / 4),
                    Math.ceil(this.noiseTextureSize.depth / 4)
                );
                passEncoder.end();
                this.device.queue.submit([commandEncoder.finish()]);

                try {
                    await this.device.queue.onSubmittedWorkDone();
                    console.log("3D Noise texture generated successfully.");
                    if(this.uiManager) this.uiManager.setLoadingStatus("3D Noise texture generated.");
                } catch(e) {
                    console.error("Error during 3D noise generation:", e);
                    if(this.uiManager) this.uiManager.displayErrorMessage("Error generating 3D noise: " + e.message);
                }
            }
        };
        // --- End NovaRayEngine Definition ---

        /**
         * @class SceneManager
         * @description Manages all scene-specific data, objects, and related logic for NovaRay.
         * This includes camera, lights, spheres, BVH, and parameters for procedural elements like water and terrain.
         * It provides methods to update these elements and their corresponding GPU buffers.
         * @param {NovaRayEngine} novaRayEngine - A reference to the main NovaRayEngine instance.
         */
        class SceneManager {
            constructor(novaRayEngine) {
                this.novaRayEngine = novaRayEngine;

                /** @type {object} Camera properties including position, rotation, FOV, etc. */
                this.camera = {
                    position: [0.0, 5.0, 20.0],
                    rotationX: -0.05,
                    rotationY: Math.PI,
                    forward: [0, 0, -1],
                    right: [1, 0, 0],
                    up: [0, 1, 0],
                    movementSpeed: 0.05,
                    rotationSpeed: 0.005,
                    fovy: Math.PI / 3,
                    aspect: 0,
                    near: 0.1,
                    far: 100.0,
                    focalDistance: 10.0,
                    apertureSize: 0.00,
                };

                /** @type {object} Light properties including position, brightness, size, and color. */
                this.light = {
                    position: [0.0, 10.0, 2.8],
                    brightness: 1.0,
                    size: 0.4,
                    color: [1.0, 1.0, 1.0]
                };
                /** @type {number} Hue component for the sun's color, used by UI and converted to RGB. */
                this.sunHue = 0.0;

                /** @type {Array<object>} Array holding all sphere objects in the scene. */
                this.spheres = [];
                /** @type {number} The target number of spheres for the scene, controlled by UI. */
                this.targetSphereCount = 5;
                /** @type {number} The last actual number of spheres generated, for change detection. */
                this.lastSphereCount = 5;
                /** @type {{bvhNodes: Array<BvhNode>, primitiveIndices: Array<number>}} Stores the result of the BVH build. */
                this.currentBvhResult = { bvhNodes: [], primitiveIndices: [] };

                /** @type {number} Strength of water waves. */
                this.waveStrength = 0.24;
                /** @type {number} Frequency of water waves. */
                this.waveFrequency = 0.5;
                /** @type {number} Speed of water wave animation. */
                this.waveSpeed = 0.01;

                /** @type {number} Global refractive index, primarily for water and refractive spheres. */
                this.globalRefractiveIndex = 1.50;
                /** @type {number} Strength of domain warping applied to scene elements. */
                this.globalWarpStrength = 0.0;
                /** @type {number} Height scale for terrain generation. */
                this.terrainHeightScale = 0.0;
                /** @type {number} Frequency for terrain noise generation. */
                this.terrainFrequency = 0.15;

                /** @type {number} Maximum ray bounces for path tracing. */
                this.maxBounces = 2;
                /** @type {number} Maximum steps for raymarching (SDFs). */
                this.maxRaymarchSteps = 150;
                /** @type {number} Number of samples for soft shadows. */
                this.shadowSamples = 4;
                /** @type {number} Number of samples for depth of field effect. */
                this.dofSamples = 4;
                /** @type {number} Current sky preset (0 for Sunny Day, 1 for Dusk). */
                this.skyPreset = 0;

                // Material type constants, matching WGSL definitions
                this.MATERIAL_DIFFUSE = 0;
                this.MATERIAL_REFLECTIVE = 1;
                this.MATERIAL_REFRACTIVE = 2;

                if (this.novaRayEngine.canvas) {
                    this.camera.aspect = this.novaRayEngine.canvas.width / this.novaRayEngine.canvas.height;
                }
            }

            // --- Camera Movement and Rotation Methods ---
            /**
             * Moves the camera by the given deltas in world space.
             * @param {number} dx - Change in X position.
             * @param {number} dy - Change in Y position.
             * @param {number} dz - Change in Z position.
             */
            moveCamera(dx, dy, dz) {
                this.camera.position[0] += dx;
                this.camera.position[1] += dy;
                this.camera.position[2] += dz;
                this.updateCameraUniformBuffer();
                this.novaRayEngine.resetAccumulation();
            }

            /**
             * Rotates the camera based on yaw and pitch changes.
             * @param {number} deltaYaw - Change in yaw (left/right look).
             * @param {number} deltaPitch - Change in pitch (up/down look).
             */
            rotateCamera(deltaYaw, deltaPitch) {
                this.camera.rotationY += deltaYaw * this.camera.rotationSpeed;
                this.camera.rotationX += deltaPitch * this.camera.rotationSpeed;
                // Clamp pitch
                this.camera.rotationX = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, this.camera.rotationX));

                this.calculateCameraVectors(); // Ensure vectors are updated after rotation
                this.updateCameraUniformBuffer();
                this.novaRayEngine.resetAccumulation();
            }
            // --- Setter methods for scene parameters ---
            /** Sets camera focal distance and resets accumulation. */
            setFocalDistance(value) {
                value = parseFloat(value);
                if (this.camera.focalDistance !== value) {
                    this.camera.focalDistance = value;
                    this.updateRaytracerParamsUniformBuffer();
                    this.novaRayEngine.resetAccumulation();
                }
            }

            /** Sets camera aperture size and resets accumulation. */
            setApertureSize(value) {
                value = parseFloat(value);
                if (this.camera.apertureSize !== value) {
                    this.camera.apertureSize = value;
                    this.updateRaytracerParamsUniformBuffer();
                    this.novaRayEngine.resetAccumulation();
                }
            }

            /** Sets light position for a given axis and resets accumulation. */
            setLightPosition(axis, value) {
                value = parseFloat(value);
                let changed = false;
                if (axis === 'x' && this.light.position[0] !== value) { this.light.position[0] = value; changed = true; }
                else if (axis === 'y' && this.light.position[1] !== value) { this.light.position[1] = value; changed = true; }
                else if (axis === 'z' && this.light.position[2] !== value) { this.light.position[2] = value; changed = true; }
                if (changed) { this.updateLightUniformBuffer(); this.novaRayEngine.resetAccumulation(); }
            }
            // ... (other setters similarly commented if complex, or left if self-explanatory by name) ...
            setSunHue(value) {
                value = parseFloat(value);
                if (this.sunHue !== value) {
                    this.sunHue = value;
                    this.light.color = this.hsvToRgb(value);
                    this.updateLightUniformBuffer();
                    this.novaRayEngine.resetAccumulation();
                }
            }
            setGlobalRefractiveIndex(value) {
                value = parseFloat(value);
                if (this.globalRefractiveIndex !== value) {
                    this.globalRefractiveIndex = value;
                    this.spheres.forEach(s => { if (s.materialType === this.MATERIAL_REFRACTIVE) s.refractiveIndex = this.globalRefractiveIndex; });
                    this.updateGPUBuffers(this.spheres, this.currentBvhResult);
                    this.novaRayEngine.resetAccumulation();
                }
            }
            setGlobalWarpStrength(value) {
                value = parseFloat(value);
                if (this.globalWarpStrength !== value) {
                    this.globalWarpStrength = value;
                    this.globalWarpStrengthChanged = true; // Flag for manageSpheres
                    this.manageSpheres();
                    this.updateRaytracerParamsUniformBuffer();
                }
            }
             setTargetSphereCount(count) {
                const newCount = parseInt(count);
                if (this.targetSphereCount !== newCount) {
                    this.targetSphereCount = newCount;
                    this.manageSpheres();
                }
            }
            setWaveStrength(value) { value = parseFloat(value); if (this.waveStrength !== value) { this.waveStrength = value; this.updateWaterUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setWaveFrequency(value) { value = parseFloat(value); if (this.waveFrequency !== value) { this.waveFrequency = value; this.updateWaterUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setWaveSpeed(value) { value = parseFloat(value); if (this.waveSpeed !== value) { this.waveSpeed = value; this.updateWaterUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setTerrainHeightScale(value) { value = parseFloat(value); if (this.terrainHeightScale !== value) { this.terrainHeightScale = value; this.updateTerrainUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setTerrainFrequency(value) { value = parseFloat(value); if (this.terrainFrequency !== value) { this.terrainFrequency = value; this.updateTerrainUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setMaxBounces(value) { value = parseInt(value); if (this.maxBounces !== value) { this.maxBounces = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setMaxRaymarchSteps(value) { value = parseInt(value); if (this.maxRaymarchSteps !== value) { this.maxRaymarchSteps = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setShadowSamples(value) { value = parseInt(value); if (this.shadowSamples !== value) { this.shadowSamples = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setDofSamples(value) { value = parseInt(value); if (this.dofSamples !== value) { this.dofSamples = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }
            setSkyPreset(value) { value = parseInt(value); if (this.skyPreset !== value) { this.skyPreset = value; this.updateRaytracerParamsUniformBuffer(); this.novaRayEngine.resetAccumulation(); } }


            hsvToRgb(h) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = 0;
                const q = 1 - f;
                const t = f;
                switch (i % 6) {
                    case 0: r = 1; g = t; b = p; break;
                    case 1: r = q; g = 1; b = p; break;
                    case 2: r = p; g = 1; b = t; break;
                    case 3: r = p; g = q; b = 1; break;
                    case 4: r = t; g = p; b = 1; break;
                    case 5: r = 1; g = p; b = q; break;
                }
                return [r, g, b];
            }

            calculateCameraVectors() {
                const pitch = this.camera.rotationX;
                const yaw = this.camera.rotationY;
                this.camera.forward[0] = Math.cos(pitch) * Math.sin(yaw);
                this.camera.forward[1] = Math.sin(pitch);
                this.camera.forward[2] = -Math.cos(pitch) * Math.cos(yaw);
                let len = Math.sqrt(this.camera.forward[0] ** 2 + this.camera.forward[1] ** 2 + this.camera.forward[2] ** 2);
                this.camera.forward[0] /= len; this.camera.forward[1] /= len; this.camera.forward[2] /= len;

                let worldUp = [0, 1, 0];
                this.camera.right[0] = worldUp[1] * this.camera.forward[2] - worldUp[2] * this.camera.forward[1];
                this.camera.right[1] = worldUp[2] * this.camera.forward[0] - worldUp[0] * this.camera.forward[2];
                this.camera.right[2] = worldUp[0] * this.camera.forward[1] - worldUp[1] * this.camera.forward[0];
                len = Math.sqrt(this.camera.right[0] ** 2 + this.camera.right[1] ** 2 + this.camera.right[2] ** 2);
                if (len > 0) { this.camera.right[0] /= len; this.camera.right[1] /= len; this.camera.right[2] /= len; } else { this.camera.right = [1, 0, 0]; }

                this.camera.up[0] = this.camera.forward[1] * this.camera.right[2] - this.camera.forward[2] * this.camera.right[1];
                this.camera.up[1] = this.camera.forward[2] * this.camera.right[0] - this.camera.forward[0] * this.camera.right[2];
                this.camera.up[2] = this.camera.forward[0] * this.camera.right[1] - this.camera.forward[1] * this.camera.right[0];
                len = Math.sqrt(this.camera.up[0] ** 2 + this.camera.up[1] ** 2 + this.camera.up[2] ** 2);
                if (len > 0) { this.camera.up[0] /= len; this.camera.up[1] /= len; this.camera.up[2] /= len; } else { this.camera.up = [0, 1, 0]; }
            }
            /**
             * Populates the spheres array with a given number of spheres, including a ground sphere.
             * Applies domain warping if `this.globalWarpStrength > 0`.
             * @param {number} count - The total number of spheres to generate (including ground sphere).
             * @returns {Array<object>} The array of generated sphere objects.
             */
            populateInitialSpheres(count) {
                const newSpheres = [];
                const sphereMinRadius = 0.5;
                const sphereMaxRadius = 1.5;

                newSpheres.push({
                    position: [0.0, -100.5, 0.0], radius: 100.0,
                    color: [0.7, 0.7, 0.7],
                    baseReflectivity: 0.04,
                    perPixelRoughness: 0.9,
                    metallic: 0.0,
                    refractiveIndex: 1.0,
                    materialType: this.MATERIAL_DIFFUSE,
                    originalIndex: 0
                });

                for (let i = 1; i < count; ++i) {
                    let materialType;
                    const r = Math.random();
                    if (r < 0.4) materialType = this.MATERIAL_DIFFUSE;
                    else if (r < 0.7) materialType = this.MATERIAL_REFLECTIVE;
                    else materialType = this.MATERIAL_REFRACTIVE;

                    let s = {
                        position: [0, 0, 0],
                        radius: sphereMinRadius + Math.random() * (sphereMaxRadius - sphereMinRadius),
                        color: [0, 0, 0],
                        baseReflectivity: 0.04,
                        perPixelRoughness: 0.0,
                        metallic: 0.0,
                        refractiveIndex: 1.0,
                        materialType: materialType,
                        originalIndex: i
                    };

                    let attempts = 0; const max_attempts = 50; let collided;
                    const distanceSq = (p1, p2) => (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2;
                    do {
                        collided = false;
                        s.position[0] = (Math.random() - 0.5) * 15;
                        s.position[1] = s.radius + Math.random() * 3;
                        s.position[2] = (Math.random() - 0.5) * 15;
                        for (let j = 0; j < newSpheres.length; ++j) {
                            if (newSpheres[j] === s) continue;
                            if (distanceSq(s.position, newSpheres[j].position) < (s.radius + newSpheres[j].radius + 0.5)**2) {
                                collided = true; break;
                            }
                        }
                        attempts++;
                    } while (collided && attempts < max_attempts);


                    if (materialType === this.MATERIAL_DIFFUSE) {
                        s.perPixelRoughness = Math.random() * 0.7 + 0.3;
                        s.color = [Math.random(), Math.random(), Math.random()];
                    } else if (materialType === this.MATERIAL_REFLECTIVE) {
                        s.perPixelRoughness = Math.random() * 0.1; s.metallic = 1.0;
                        s.color = [Math.random() * 0.7 + 0.3, Math.random() * 0.7 + 0.3, Math.random() * 0.7 + 0.3];
                    } else if (materialType === this.MATERIAL_REFRACTIVE) {
                        s.perPixelRoughness = Math.random() * 0.1;
                        s.refractiveIndex = this.globalRefractiveIndex;
                        s.color = [Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5];
                    }
                    newSpheres.push(s);
                }
                this.spheres = newSpheres;

                if (this.globalWarpStrength > 0) {
                    this.spheres.forEach(sphere => {
                        if (sphere.originalIndex === 0) return;
                        const warpedPos = this.applyDomainWarp(sphere.position, this.globalWarpStrength);
                        sphere.position[0] = warpedPos[0];
                        sphere.position[1] = warpedPos[1];
                        sphere.position[2] = warpedPos[2];
                    });
                }
                return newSpheres;
            }

            applyDomainWarp(position, strength) {
                const p = position;
                const s = strength;
                const q = [
                    snoise([p[0], p[1], p[2]]),
                    snoise([p[0] + 5.2, p[1] - 1.3, p[2]]),
                    snoise([p[0] - 2.7, p[1] + 3.1, p[2] + 1.5])
                ];
                return [ p[0] + q[0] * s, p[1] + q[1] * s, p[2] + q[2] * s ];
            }

            /** Builds the BVH structure synchronously on the main thread. Used as a fallback or if worker is disabled. */
            buildBvhStructure(primitivesForBVH) {
                console.time("BVH Build (SceneManager Sync)");
                if (this.novaRayEngine.uiManager) this.novaRayEngine.uiManager.setLoadingStatus(`Building BVH for ${primitivesForBVH.length} spheres (Sync)...`);

                if (primitivesForBVH.length === 0) {
                    console.warn("No primitives to build BVH for (SceneManager Sync).");
                    return { bvhNodes: [], primitiveIndices: [] };
                }

                const flattenedNodes = [];
                const primitiveIndices = Array.from({ length: primitivesForBVH.length }, (_, i) => i);

                try {
                    buildBvh(primitivesForBVH, flattenedNodes, primitiveIndices, 0, primitivesForBVH.length);
                } catch (e) {
                    console.error("Error during BVH construction (SceneManager Sync):", e);
                    if (this.novaRayEngine.uiManager) this.novaRayEngine.uiManager.displayErrorMessage(`BVH construction failed (Sync): ${e.message}`);
                    return { bvhNodes: [], primitiveIndices: [] };
                }

                console.timeEnd("BVH Build (SceneManager Sync)");
                if (this.novaRayEngine.uiManager) this.novaRayEngine.uiManager.setLoadingStatus(`BVH built with ${flattenedNodes.length} nodes (Sync). Uploading to GPU...`);
                return { bvhNodes: flattenedNodes, primitiveIndices: primitiveIndices };
            }

            /**
             * Updates the GPU buffers for spheres, BVH nodes, and primitive indices.
             * @param {Array<object>} newSpheresData - Array of sphere objects.
             * @param {object} bvhData - Object containing `bvhNodes` (Array<BvhNode>) and `primitiveIndices` (Array<number>).
             */
            updateGPUBuffers(newSpheresData, bvhData) {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.resourceManager) {
                    console.warn("NovaRayEngine.device or resourceManager not ready for GPU buffer update.");
                    return;
                }
                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Updating sphere data (${newSpheresData.length} spheres)...`);

                const SPHERE_FLOAT_COUNT = 12;
                const sphereRawData = new Float32Array(newSpheresData.length * SPHERE_FLOAT_COUNT);
                newSpheresData.forEach((s, i) => {
                    let offset = i * SPHERE_FLOAT_COUNT;
                    sphereRawData[offset + 0] = s.position[0]; sphereRawData[offset + 1] = s.position[1]; sphereRawData[offset + 2] = s.position[2]; sphereRawData[offset + 3] = s.radius;
                    sphereRawData[offset + 4] = s.color[0]; sphereRawData[offset + 5] = s.color[1]; sphereRawData[offset + 6] = s.color[2]; sphereRawData[offset + 7] = s.metallic;
                    sphereRawData[offset + 8] = s.perPixelRoughness; sphereRawData[offset + 9] = s.baseReflectivity; sphereRawData[offset + 10] = s.materialType; sphereRawData[offset + 11] = s.refractiveIndex;
                });

                if (engine.sphereDataBuffer) { engine.sphereDataBuffer.destroy(); }
                engine.sphereDataBuffer = engine.resourceManager.createBuffer({
                    size: sphereRawData.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "Sphere Data Buffer (SceneManager)");
                engine.device.queue.writeBuffer(engine.sphereDataBuffer, 0, sphereRawData);

                this.currentBvhResult.bvhNodes = bvhData.bvhNodes;
                this.currentBvhResult.primitiveIndices = bvhData.primitiveIndices;

                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Updating BVH nodes (${bvhData.bvhNodes.length} nodes)...`);
                const BVH_NODE_FLOAT_COUNT = 12;
                const bvhNodesFlat = new Float32Array(bvhData.bvhNodes.length * BVH_NODE_FLOAT_COUNT);
                const bvhNodesIntView = new Uint32Array(bvhNodesFlat.buffer);

                bvhData.bvhNodes.forEach((node, i) => {
                    let floatOffset = i * BVH_NODE_FLOAT_COUNT;
                    let intOffset = floatOffset;

                    bvhNodesFlat[floatOffset + 0] = node.minBounds[0]; bvhNodesFlat[floatOffset + 1] = node.minBounds[1]; bvhNodesFlat[floatOffset + 2] = node.minBounds[2];
                    bvhNodesIntView[intOffset + 3] = node.isLeaf;

                    bvhNodesFlat[floatOffset + 4] = node.maxBounds[0]; bvhNodesFlat[floatOffset + 5] = node.maxBounds[1]; bvhNodesFlat[floatOffset + 6] = node.maxBounds[2];
                    bvhNodesIntView[intOffset + 7] = node.primitiveCount;

                    bvhNodesIntView[intOffset + 8] = node.leftChildOrFirstPrimitiveIndex;
                });
                
                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Updating primitive indices (${bvhData.primitiveIndices.length} indices)...`);
                const primitiveIndicesFlat = new Uint32Array(bvhData.primitiveIndices);

                if (engine.bvhNodesBuffer) { engine.bvhNodesBuffer.destroy(); }
                engine.bvhNodesBuffer = engine.resourceManager.createBuffer({
                    size: bvhNodesFlat.byteLength > 0 ? bvhNodesFlat.byteLength : 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "BVH Nodes Buffer (SceneManager)");
                if (bvhNodesFlat.byteLength > 0) engine.device.queue.writeBuffer(engine.bvhNodesBuffer, 0, bvhNodesFlat);


                if (engine.primitiveIndicesBuffer) { engine.primitiveIndicesBuffer.destroy(); }
                engine.primitiveIndicesBuffer = engine.resourceManager.createBuffer({
                    size: primitiveIndicesFlat.byteLength > 0 ? primitiveIndicesFlat.byteLength : 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                }, "Primitive Indices Buffer (SceneManager)");
                if (primitiveIndicesFlat.byteLength > 0) engine.device.queue.writeBuffer(engine.primitiveIndicesBuffer, 0, primitiveIndicesFlat);
                
                this.updateRaytracerParamsUniformBuffer();
                this.novaRayEngine.createComputeBindGroups();
            }

            /**
             * Manages sphere population and BVH construction, opting for asynchronous
             * BVH building via Web Worker if available and not busy, otherwise falls back
             * to synchronous construction.
             */
            manageSpheres() {
                const engine = this.novaRayEngine;
                if (this.spheres.length !== this.targetSphereCount || this.lastSphereCount !== this.targetSphereCount || this.spheres.length === 0 || this.globalWarpStrengthChanged) {
                    this.populateInitialSpheres(this.targetSphereCount);
                    this.lastSphereCount = this.targetSphereCount;
                    this.globalWarpStrengthChanged = false;

                    if (this.spheres.length === 0) {
                        this.updateGPUBuffers([], { bvhNodes: [], primitiveIndices: [] });
                        engine.resetAccumulation();
                        return;
                    }

                    if (engine.bvhWorker && !engine.isBVHBuilding) {
                        console.log("SceneManager: Attempting asynchronous BVH construction via worker.");
                        engine.isBVHBuilding = true;
                        if (engine.uiManager) engine.uiManager.setLoadingStatus(`Sending ${this.spheres.length} spheres to BVH worker...`);
                        engine.latestSphereDataForWorker = [...this.spheres];

                        const spheresForWorker = this.spheres.map((s, index) => ({
                            position: s.position, radius: s.radius, originalIndex: s.originalIndex !== undefined ? s.originalIndex : index
                        }));

                        engine.bvhUpdatePromise = new Promise((resolve, reject) => {
                            engine.bvhWorker.postMessage({ spheresData: spheresForWorker });
                            engine.bvhUpdatePromise._resolve = resolve;
                            engine.bvhUpdatePromise._reject = reject;
                        }).catch(err => {
                            console.error("SceneManager: BVH Update Promise rejected:", err);
                            this.fallbackToSyncBVH("BVH worker promise rejected.");
                        });
                    } else if (engine.isBVHBuilding) {
                        console.log("SceneManager: BVH worker is busy. Update will be processed after current build or manageSpheres needs to be called again.");
                    } else {
                        this.fallbackToSyncBVH("BVH worker not available.");
                    }
                } else {
                    this.updateRaytracerParamsUniformBuffer();
                }
            }

            fallbackToSyncBVH(reason) {
                const engine = this.novaRayEngine;
                console.log(`SceneManager: ${reason} Falling back to synchronous BVH construction.`);
                if (engine.uiManager) engine.uiManager.setLoadingStatus(`Building BVH synchronously for ${this.spheres.length} spheres...`);
                try {
                    const bvhResult = this.buildBvhStructure(this.spheres);
                    this.updateGPUBuffers(this.spheres, bvhResult);
                    engine.resetAccumulation();
                } catch (e) {
                    console.error("Error building BVH on main thread (SceneManager fallback):", e);
                    if (engine.uiManager) engine.uiManager.displayErrorMessage(`Error building BVH (sync fallback): ${e.message}`);
                }
            }


            // --- UBO Update Methods ---
            /** Updates the camera uniform buffer with current camera state. */
            updateCameraUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.canvas || !engine.cameraUBOBuffer || !engine.resourceManager) return;
                const cameraData = new Float32Array([
                    this.camera.position[0], this.camera.position[1], this.camera.position[2], 0.0,
                    this.camera.forward[0], this.camera.forward[1], this.camera.forward[2], 0.0,
                    this.camera.right[0], this.camera.right[1], this.camera.right[2], 0.0,
                    this.camera.up[0], this.camera.up[1], this.camera.up[2], 0.0,
                    engine.canvas.width, engine.canvas.height, this.camera.aspect, this.camera.fovy,
                    this.camera.near, this.camera.far, 0.0, 0.0,
                ]);
                if (cameraData.length !== 24) console.error("SceneManager: CameraUniformBuffer size mismatch! Expected 24 floats, got", cameraData.length);
                engine.device.queue.writeBuffer(engine.cameraUBOBuffer, 0, cameraData);
            }
            /** Updates the light uniform buffer. */
            updateLightUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.lightUBOBuffer || !engine.resourceManager) return;
                const lightData = new Float32Array([
                    this.light.position[0], this.light.position[1], this.light.position[2], this.light.brightness,
                    this.light.size, 0.0, 0.0, 0.0,
                    this.light.color[0], this.light.color[1], this.light.color[2], 0.0
                ]);
                engine.device.queue.writeBuffer(engine.lightUBOBuffer, 0, lightData);
            }
            /** Updates the time uniform buffer. */
            updateTimeUniformBuffer(time, frameCount) {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.timeUBOBuffer || !engine.resourceManager) return;
                const timeData = new Float32Array([ time, parseFloat(frameCount), 0.0, 0.0 ]);
                engine.device.queue.writeBuffer(engine.timeUBOBuffer, 0, timeData);
            }
            /** Updates the water parameters uniform buffer. */
            updateWaterUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.waterUBOBuffer || !engine.resourceManager) return;
                const waterData = new Float32Array([this.waveStrength, this.waveFrequency, this.waveSpeed, 0.0]);
                engine.device.queue.writeBuffer(engine.waterUBOBuffer, 0, waterData);
            }
             /** Updates the terrain parameters uniform buffer. */
            updateTerrainUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.terrainUBOBuffer || !engine.resourceManager) return;
                const terrainData = new Float32Array([this.terrainHeightScale, this.terrainFrequency, 0.0, 0.0]);
                engine.device.queue.writeBuffer(engine.terrainUBOBuffer, 0, terrainData);
            }
            /** Updates the main raytracer parameters uniform buffer. */
            updateRaytracerParamsUniformBuffer() {
                const engine = this.novaRayEngine;
                if (!engine.device || !engine.raytracerUBOBuffer || !engine.resourceManager) return;
                const raytracerData = new Float32Array(12);
                const raytracerDataUintView = new Uint32Array(raytracerData.buffer);
                raytracerDataUintView[0] = this.maxBounces;
                raytracerDataUintView[1] = this.maxRaymarchSteps;
                raytracerDataUintView[2] = this.shadowSamples;
                raytracerDataUintView[3] = this.dofSamples;
                raytracerDataUintView[4] = this.currentBvhResult.bvhNodes.length;
                raytracerDataUintView[5] = this.spheres.length;
                raytracerDataUintView[6] = this.skyPreset;
                raytracerData[8] = this.globalWarpStrength;
                raytracerData[9] = this.camera.focalDistance;
                raytracerData[10] = this.camera.apertureSize;
                engine.device.queue.writeBuffer(engine.raytracerUBOBuffer, 0, raytracerData);
            }
        }
        // --- End SceneManager Definition ---

        /**
         * @class UIManager
         * @description Manages all User Interface (UI) elements, interactions, view switching,
         * and feedback mechanisms like error messages and loading statuses for NovaRay.
         * @param {NovaRayEngine} novaRayEngine - A reference to the main NovaRayEngine instance.
         */
        class UIManager {
            constructor(novaRayEngine) {
                this.novaRayEngine = novaRayEngine;
                /** @type {string} Current active view ('menu', 'loading', 'scene'). */
                this.appState = 'menu';

                // DOM Elements are cached here after initDOMElements() is called.
                this.appContainer = null;
                this.menuView = null;
                this.loadingView = null;
                this.sceneView = null;
                this.settingsPanel = null;
                this.loadingStatusP = null;
                this.errorMessageDisplay = null;
                this.startButton = null;
                // ... other DOM element properties
            }

            /** Initializes (caches) references to all relevant DOM elements. */
            initDOMElements() {
                this.appContainer = document.getElementById('app-container');
                this.menuView = document.getElementById('menu-view');
                this.loadingView = document.getElementById('loading-view');
                this.sceneView = document.getElementById('scene-view');
                this.settingsPanel = document.getElementById('settings-panel');
                this.loadingStatusP = document.getElementById('loading-status');
                this.errorMessageDisplay = document.getElementById('error-message-display');
                this.startButton = document.getElementById('start-button');
                this.settingsButton = document.getElementById('settings-button');
                this.qualityPresetSelect = document.getElementById('quality-preset');
                this.numSpheresRange = document.getElementById('num-spheres');
                this.numSpheresValueSpan = document.getElementById('num-spheres-value');
                this.maxBouncesRange = document.getElementById('max-bounces');
                this.maxBouncesValueSpan = document.getElementById('max-bounces-value');
                this.samplesPerPixelRange = document.getElementById('samples-per-pixel');
                this.samplesPerPixelValueSpan = document.getElementById('samples-per-pixel-value');
                this.applySettingsButton = document.getElementById('apply-settings-button');
                this.backToMenuButton = document.getElementById('back-to-menu-button');
                this.backToMainMenuFromSceneButton = document.getElementById('back-to-main-menu-from-scene');
                this.canvas = document.getElementById('webgpu-canvas');
                this.sceneControlsPanel = document.getElementById('scene-controls-panel');
                this.togglePanelButton = document.getElementById('toggle-panel-button');
                this.sphereCountSlider = document.getElementById('sphereCountSlider');
                this.sphereCountValue = document.getElementById('sphereCountValue');
                this.lightXSlider = document.getElementById('lightXSlider'); this.lightXValue = document.getElementById('lightXValue');
                this.lightYSlider = document.getElementById('lightYSlider'); this.lightYValue = document.getElementById('lightYValue');
                this.lightZSlider = document.getElementById('lightZSlider'); this.lightZValue = document.getElementById('lightZValue');
                this.lightBrightnessSlider = document.getElementById('lightBrightnessSlider'); this.lightBrightnessValue = document.getElementById('lightBrightnessValue');
                this.lightSizeSlider = document.getElementById('lightSizeSlider'); this.lightSizeValue = document.getElementById('lightSizeValue');
                this.sunHueSlider = document.getElementById('sunHueSlider'); this.sunHueValueSpan = document.getElementById('sunHueValue');
                this.waveStrengthSlider = document.getElementById('waveStrengthSlider'); this.waveStrengthValue = document.getElementById('waveStrengthValue');
                this.waveFrequencySlider = document.getElementById('waveFrequencySlider'); this.waveFrequencyValue = document.getElementById('waveFrequencyValue');
                this.waveSpeedSlider = document.getElementById('waveSpeedSlider'); this.waveSpeedValue = document.getElementById('waveSpeedValue');
                this.refractiveIndexSlider = document.getElementById('refractiveIndexSlider'); this.refractiveIndexValue = document.getElementById('refractiveIndexValue');
                this.warpStrengthSlider = document.getElementById('warpStrengthSlider'); this.warpStrengthValue = document.getElementById('warpStrengthValue');
                this.terrainHeightSlider = document.getElementById('terrainHeightSlider'); this.terrainHeightValue = document.getElementById('terrainHeightValue');
                this.terrainFrequencySlider = document.getElementById('terrainFrequencySlider'); this.terrainFrequencyValue = document.getElementById('terrainFrequencyValue');
                this.bouncesSlider = document.getElementById('bouncesSlider'); this.bouncesValue = document.getElementById('bouncesValue');
                this.raymarchStepsSlider = document.getElementById('raymarchStepsSlider'); this.raymarchStepsValue = document.getElementById('raymarchStepsValue');
                this.shadowSamplesSlider = document.getElementById('shadowSamplesSlider'); this.shadowSamplesValue = document.getElementById('shadowSamplesValue');
                this.dofSamplesSlider = document.getElementById('dofSamplesSlider'); this.dofSamplesValue = document.getElementById('dofSamplesValue');
                this.focalDistanceSlider = document.getElementById('focalDistanceSlider'); this.focalDistanceValue = document.getElementById('focalDistanceValue');
                this.apertureSizeSlider = document.getElementById('apertureSizeSlider'); this.apertureSizeValue = document.getElementById('apertureSizeValue');
                this.sunnyDayButton = document.getElementById('sunnyDayButton');
                this.duskButton = document.getElementById('duskButton');
                this.fpsCounterElement = document.getElementById('fps-counter');
            }

            /**
             * Switches the active view of the application.
             * @param {string} newViewId - The ID of the view to switch to ('menu', 'loading', 'scene').
             */
            switchView(newViewId) {
                this.menuView.classList.remove('active');
                this.loadingView.classList.remove('active');
                this.sceneView.classList.remove('active');
                this.settingsPanel.classList.remove('active');
                if (this.fpsCounterElement) this.fpsCounterElement.style.display = 'none';
                if (this.sceneControlsPanel) this.sceneControlsPanel.style.display = 'none';
                if (this.backToMainMenuFromSceneButton) this.backToMainMenuFromSceneButton.style.display = 'none';

                setTimeout(() => {
                    if (newViewId === 'menu') {
                        this.menuView.classList.add('active');
                        if (this.canvas) this.canvas.style.display = 'none';
                    } else if (newViewId === 'loading') {
                        this.loadingView.classList.add('active');
                        if (this.canvas) this.canvas.style.display = 'none';
                    } else if (newViewId === 'scene') {
                        this.sceneView.classList.add('active');
                        if (this.canvas) this.canvas.style.display = 'block';
                        if (this.fpsCounterElement) this.fpsCounterElement.style.display = 'block';
                        if (this.sceneControlsPanel) this.sceneControlsPanel.style.display = 'block';
                        if (this.backToMainMenuFromSceneButton) this.backToMainMenuFromSceneButton.style.display = 'block';
                        startRenderLoop();
                    }
                    this.appState = newViewId;
                    console.log(`Switched to view: ${this.appState}`);
                }, 50);
            }

            /**
             * Displays an error message to the user.
             * @param {string} message - The error message to display.
             */
            displayErrorMessage(message) {
                if (this.errorMessageDisplay) {
                    this.errorMessageDisplay.textContent = message;
                    this.errorMessageDisplay.classList.add('active');
                    setTimeout(() => {
                        this.errorMessageDisplay.classList.remove('active');
                    }, 5000);
                }
                console.error(message);
            }

            /**
             * Sets the text content of the loading status display.
             * @param {string} message - The status message to display.
             */
            setLoadingStatus(message) {
                if (this.loadingStatusP) {
                    this.loadingStatusP.textContent = message;
                }
            }

            /**
             * Helper to update the text content of a span associated with a range slider.
             * @param {HTMLInputElement} sliderElement - The range input element.
             * @param {HTMLElement} valueSpanElement - The span element to display the value.
             * @param {number} [toFixedDigits=1] - Number of decimal places for the displayed value.
             */
            updateSliderValueDisplay(sliderElement, valueSpanElement, toFixedDigits = 1) {
                if (valueSpanElement && sliderElement) {
                    valueSpanElement.textContent = parseFloat(sliderElement.value).toFixed(toFixedDigits);
                }
            }

            /**
             * Updates the FPS counter display.
             * @param {number} fpsValue - The current FPS value.
             */
            updateFPSCounter(fpsValue) {
                if (this.fpsCounterElement) {
                    this.fpsCounterElement.textContent = \`FPS: \${fpsValue.toFixed(0)}\`;
                }
            }
            /**
             * Initializes the scene control panel UI elements with values from SceneManager
             * and sets up their event listeners.
             */
            initSceneControlsUI() {
                const sm = this.novaRayEngine.sceneManager;
                if (!sm) {
                    console.warn("SceneManager not initialized, skipping UI init Scene Controls.");
                    return;
                }

                this.updateSliderValueDisplay(this.sphereCountSlider, this.sphereCountValue, 0); this.sphereCountSlider.value = sm.targetSphereCount;
                this.updateSliderValueDisplay(this.lightXSlider, this.lightXValue); this.lightXSlider.value = sm.light.position[0];
                this.updateSliderValueDisplay(this.lightYSlider, this.lightYValue); this.lightYSlider.value = sm.light.position[1];
                this.updateSliderValueDisplay(this.lightZSlider, this.lightZValue); this.lightZSlider.value = sm.light.position[2];
                this.updateSliderValueDisplay(this.lightBrightnessSlider, this.lightBrightnessValue); this.lightBrightnessSlider.value = sm.light.brightness;
                this.updateSliderValueDisplay(this.lightSizeSlider, this.lightSizeValue); this.lightSizeSlider.value = sm.light.size;
                this.updateSliderValueDisplay(this.sunHueSlider, this.sunHueValueSpan, 2); this.sunHueSlider.value = sm.sunHue;
                this.updateSliderValueDisplay(this.waveStrengthSlider, this.waveStrengthValue, 2); this.waveStrengthSlider.value = sm.waveStrength;
                this.updateSliderValueDisplay(this.waveFrequencySlider, this.waveFrequencyValue); this.waveFrequencySlider.value = sm.waveFrequency;
                this.updateSliderValueDisplay(this.waveSpeedSlider, this.waveSpeedValue, 2); this.waveSpeedSlider.value = sm.waveSpeed;
                this.updateSliderValueDisplay(this.refractiveIndexSlider, this.refractiveIndexValue, 2); this.refractiveIndexSlider.value = sm.globalRefractiveIndex;
                this.updateSliderValueDisplay(this.warpStrengthSlider, this.warpStrengthValue, 2); this.warpStrengthSlider.value = sm.globalWarpStrength;
                this.updateSliderValueDisplay(this.terrainHeightSlider, this.terrainHeightValue); this.terrainHeightSlider.value = sm.terrainHeightScale;
                this.updateSliderValueDisplay(this.terrainFrequencySlider, this.terrainFrequencyValue, 2); this.terrainFrequencySlider.value = sm.terrainFrequency;
                this.updateSliderValueDisplay(this.bouncesSlider, this.bouncesValue, 0); this.bouncesSlider.value = sm.maxBounces;
                this.updateSliderValueDisplay(this.raymarchStepsSlider, this.raymarchStepsValue, 0); this.raymarchStepsSlider.value = sm.maxRaymarchSteps;
                this.updateSliderValueDisplay(this.shadowSamplesSlider, this.shadowSamplesValue, 0); this.shadowSamplesSlider.value = sm.shadowSamples;
                this.updateSliderValueDisplay(this.dofSamplesSlider, this.dofSamplesValue, 0); this.dofSamplesSlider.value = sm.dofSamples;
                this.updateSliderValueDisplay(this.focalDistanceSlider, this.focalDistanceValue); this.focalDistanceSlider.value = sm.camera.focalDistance;
                this.updateSliderValueDisplay(this.apertureSizeSlider, this.apertureSizeValue, 2); this.apertureSizeSlider.value = sm.camera.apertureSize;

                if (sm.skyPreset === 0) { this.sunnyDayButton.classList.add('active'); this.duskButton.classList.remove('active'); }
                else { this.duskButton.classList.add('active'); this.sunnyDayButton.classList.remove('active'); }
            }
            /**
             * Initializes all UI event listeners for the application.
             * This includes main menu, settings panel, scene controls, and canvas interactions.
             */
            initEventListeners() {
                const sm = this.novaRayEngine.sceneManager; // Alias

                this.startButton.addEventListener('click', () => applySettingsAndStart());
                this.settingsButton.addEventListener('click', () => {
                    this.menuView.classList.remove('active');
                    this.settingsPanel.classList.add('active');
                });
                this.backToMenuButton.addEventListener('click', () => {
                    this.settingsPanel.classList.remove('active');
                    this.menuView.classList.add('active');
                });
                this.applySettingsButton.addEventListener('click', () => applySettingsAndStart());

                this.numSpheresRange.addEventListener('input', (e) => { this.numSpheresValueSpan.textContent = e.target.value; });
                this.maxBouncesRange.addEventListener('input', (e) => { this.maxBouncesValueSpan.textContent = e.target.value; });
                this.samplesPerPixelRange.addEventListener('input', (e) => { this.samplesPerPixelValueSpan.textContent = e.target.value; });

                this.qualityPresetSelect.addEventListener('change', (e) => {
                    const preset = e.target.value;
                    if (preset === 'low') {
                        this.numSpheresRange.value = 5; this.maxBouncesRange.value = 2; this.samplesPerPixelRange.value = 4;
                    } else if (preset === 'medium') {
                        this.numSpheresRange.value = 10; this.maxBouncesRange.value = 4; this.samplesPerPixelRange.value = 16;
                    } else if (preset === 'high') {
                        this.numSpheresRange.value = 50; this.maxBouncesRange.value = 8; this.samplesPerPixelRange.value = 32;
                    }
                    this.numSpheresValueSpan.textContent = this.numSpheresRange.value;
                    this.maxBouncesValueSpan.textContent = this.maxBouncesRange.value;
                    this.samplesPerPixelValueSpan.textContent = this.samplesPerPixelRange.value;
                });

                this.togglePanelButton.addEventListener('click', () => {
                    this.sceneControlsPanel.classList.toggle('collapsed');
                    this.togglePanelButton.textContent = this.sceneControlsPanel.classList.contains('collapsed') ? '>' : '<';
                });

                this.sphereCountSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.sphereCountSlider, this.sphereCountValue, 0); sm.setTargetSphereCount(v); });
                this.lightXSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightXSlider, this.lightXValue); sm.setLightPosition('x', v); });
                this.lightYSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightYSlider, this.lightYValue); sm.setLightPosition('y', v); });
                this.lightZSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightZSlider, this.lightZValue); sm.setLightPosition('z', v); });
                this.lightBrightnessSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightBrightnessSlider, this.lightBrightnessValue); sm.setLightBrightness(v); });
                this.lightSizeSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.lightSizeSlider, this.lightSizeValue); sm.setLightSize(v); });
                this.sunHueSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.sunHueSlider, this.sunHueValueSpan, 2); sm.setSunHue(v); });
                this.waveStrengthSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.waveStrengthSlider, this.waveStrengthValue, 2); sm.setWaveStrength(v); });
                this.waveFrequencySlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.waveFrequencySlider, this.waveFrequencyValue); sm.setWaveFrequency(v); });
                this.waveSpeedSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.waveSpeedSlider, this.waveSpeedValue, 2); sm.setWaveSpeed(v); });
                this.refractiveIndexSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.refractiveIndexSlider, this.refractiveIndexValue, 2); sm.setGlobalRefractiveIndex(v); });
                this.warpStrengthSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.warpStrengthSlider, this.warpStrengthValue, 2); sm.setGlobalWarpStrength(v); });
                this.terrainHeightSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.terrainHeightSlider, this.terrainHeightValue); sm.setTerrainHeightScale(v); });
                this.terrainFrequencySlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.terrainFrequencySlider, this.terrainFrequencyValue, 2); sm.setTerrainFrequency(v); });
                this.bouncesSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.bouncesSlider, this.bouncesValue, 0); sm.setMaxBounces(v); });
                this.raymarchStepsSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.raymarchStepsSlider, this.raymarchStepsValue, 0); sm.setMaxRaymarchSteps(v); });
                this.shadowSamplesSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.shadowSamplesSlider, this.shadowSamplesValue, 0); sm.setShadowSamples(v); });
                this.dofSamplesSlider.addEventListener('input', (e) => { const v = parseInt(e.target.value); this.updateSliderValueDisplay(this.dofSamplesSlider, this.dofSamplesValue, 0); sm.setDofSamples(v); });
                this.focalDistanceSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.focalDistanceSlider, this.focalDistanceValue); sm.setFocalDistance(v); });
                this.apertureSizeSlider.addEventListener('input', (e) => { const v = parseFloat(e.target.value); this.updateSliderValueDisplay(this.apertureSizeSlider, this.apertureSizeValue, 2); sm.setApertureSize(v); });
                this.sunnyDayButton.addEventListener('click', () => { sm.setSkyPreset(0); this.sunnyDayButton.classList.add('active'); this.duskButton.classList.remove('active'); });
                this.duskButton.addEventListener('click', () => { sm.setSkyPreset(1); this.duskButton.classList.add('active'); this.sunnyDayButton.classList.remove('active'); });

                this.backToMainMenuFromSceneButton.addEventListener('click', () => {
                    if (this.novaRayEngine.animationFrameId) {
                        cancelAnimationFrame(this.novaRayEngine.animationFrameId);
                        this.novaRayEngine.animationFrameId = null;
                    }
                    this.switchView('menu');
                });

                this.setupCanvasEventListeners();
            }

            /** Sets up mouse and keyboard event listeners for the main canvas (camera controls). */
            setupCanvasEventListeners() {
                if (!this.canvas) {
                    console.error("UIManager: Canvas element not found for event listeners setup.");
                    return;
                }
                this.canvas.addEventListener('mousedown', (e) => {
                    if (this.appState === 'scene') {
                        this.novaRayEngine.isMouseDown = true;
                        this.novaRayEngine.lastMouseX = e.clientX;
                        this.novaRayEngine.lastMouseY = e.clientY;
                        this.canvas.requestPointerLock = this.canvas.requestPointerLock || this.canvas.mozRequestPointerLock;
                        this.canvas.requestPointerLock();
                        this.canvas.style.cursor = 'grabbing';
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.appState === 'scene' && this.novaRayEngine.isMouseDown) {
                        this.novaRayEngine.isMouseDown = false;
                        if (document.pointerLockElement === this.canvas) {
                            document.exitPointerLock();
                        }
                        this.canvas.style.cursor = 'grab';
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.appState === 'scene' && document.pointerLockElement === this.canvas) {
                        const movementX = e.movementX || e.mozMovementX || 0;
                        const movementY = e.movementY || e.mozMovementY || 0;
                        this.novaRayEngine.sceneManager.rotateCamera(-movementX, -movementY);
                    }
                });

                document.addEventListener('keydown', (e) => {
                    this.novaRayEngine.keysPressed[e.key.toLowerCase()] = true;
                });
                document.addEventListener('keyup', (e) => {
                    this.novaRayEngine.keysPressed[e.key.toLowerCase()] = false;
                });
                 window.addEventListener('resize', () => {
                    if (NovaRayEngine && NovaRayEngine.device) {
                        resizeCanvasAndAssets();
                    }
                });
            }
        }
        // --- End UIManager Definition ---

        // Global instance of the engine
        const NovaRayEngine = window.NovaRayEngine;

        // --- Global UI Access (Legacy, for applySettingsAndStart) ---
        const globalCanvas = document.getElementById('webgpu-canvas');
        const globalLoadingStatusP = document.getElementById('loading-status');
        const globalErrorMessageDisplay = document.getElementById('error-message-display');


        /**
         * Main application orchestrator for settings application and starting the engine.
         * This function is typically called from UI event listeners.
         * @async
         */
        async function applySettingsAndStart() {
            if (!NovaRayEngine.uiManager) {
                NovaRayEngine.uiManager = new UIManager(NovaRayEngine);
                NovaRayEngine.uiManager.initDOMElements();
            }
            NovaRayEngine.uiManager.switchView('loading');

            const success = await NovaRayEngine.initialize(globalCanvas, globalLoadingStatusP, globalErrorMessageDisplay);

            if (!success) {
                NovaRayEngine.uiManager.switchView('menu');
            }
        }

        /**
         * @class AABB
         * @description Axis-Aligned Bounding Box helper class for BVH construction.
         */
        class AABB {
            constructor(min, max) { this.min = min; this.max = max; }
            expand(point) { this.min[0] = Math.min(this.min[0], point[0]); this.min[1] = Math.min(this.min[1], point[1]); this.min[2] = Math.min(this.min[2], point[2]); this.max[0] = Math.max(this.max[0], point[0]); this.max[1] = Math.max(this.max[1], point[1]); this.max[2] = Math.max(this.max[2], point[2]); }
            union(other) { this.min[0] = Math.min(this.min[0], other.min[0]); this.min[1] = Math.min(this.min[1], other.min[1]); this.min[2] = Math.min(this.min[2], other.min[2]); this.max[0] = Math.max(this.max[0], other.max[0]); this.max[1] = Math.max(this.max[1], other.max[1]); this.max[2] = Math.max(this.max[2], other.max[2]); }
            centroid() { return [(this.min[0] + this.max[0]) * 0.5, (this.min[1] + this.max[1]) * 0.5, (this.min[2] + this.max[2]) * 0.5]; }
            longestAxis() { const dx = this.max[0] - this.min[0]; const dy = this.max[1] - this.min[1]; const dz = this.max[2] - this.min[2]; if (dx > dy && dx > dz) return 0; if (dy > dz) return 1; return 2; }
        }
        /**
         * @class BvhNode
         * @description Represents a node in the Bounding Volume Hierarchy.
         */
        class BvhNode { constructor() { this.minBounds = [Infinity, Infinity, Infinity]; this.maxBounds = [-Infinity, -Infinity, -Infinity]; this.isLeaf = 0; this.primitiveCount = 0; this.leftChildOrFirstPrimitiveIndex = 0; } }
        const BVH_LEAF_SIZE = 4;
        /** Builds the BVH recursively. This is a global helper for synchronous BVH construction. */
        function buildBvh(primitives, flattenedNodes, primitiveIndices, offset, count) {
            let bbox = new AABB([Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]);
            for (let i = offset; i < offset + count; ++i) { const p = primitives[primitiveIndices[i]]; bbox.expand([p.position[0] - p.radius, p.position[1] - p.radius, p.position[2] - p.radius]); bbox.expand([p.position[0] + p.radius, p.position[1] + p.radius, p.position[2] + p.radius]); }
            const nodeIndex = flattenedNodes.length; const node = new BvhNode(); node.minBounds = bbox.min; node.maxBounds = bbox.max; flattenedNodes.push(node);
            if (count <= BVH_LEAF_SIZE) { node.isLeaf = 1; node.primitiveCount = count; node.leftChildOrFirstPrimitiveIndex = offset;  } else {
                const axis = bbox.longestAxis(); const pivot = bbox.centroid()[axis]; let left = offset; let right = offset + count - 1;
                while (left <= right) { while (left <= right && primitives[primitiveIndices[left]].position[axis] < pivot) left++; while (left <= right && primitives[primitiveIndices[right]].position[axis] >= pivot) right--; if (left < right) { [primitiveIndices[left], primitiveIndices[right]] = [primitiveIndices[right], primitiveIndices[left]]; left++; right--; } }
                let mid = left; if (mid === offset || mid === offset + count) mid = offset + Math.floor(count / 2);
                const leftCount = mid - offset; const rightCount = count - leftCount;
                node.isLeaf = 0; node.primitiveCount = 0; node.leftChildOrFirstPrimitiveIndex = flattenedNodes.length;
                buildBvh(primitives, flattenedNodes, primitiveIndices, offset, leftCount); buildBvh(primitives, flattenedNodes, primitiveIndices, mid, rightCount);
            }
            flattenedNodes[nodeIndex] = node; return nodeIndex;
        }

        /** Handles canvas resizing and recreation of dependent GPU resources. This is a global function that operates on the global NovaRayEngine instance. */
        function resizeCanvasAndAssets() {
            let newWidth = window.innerWidth * window.devicePixelRatio;
            let newHeight = window.innerHeight * window.devicePixelRatio;
            const MAX_CANVAS_DIMENSION = 1920;

            if (newWidth > MAX_CANVAS_DIMENSION || newHeight > MAX_CANVAS_DIMENSION) {
                const aspectRatio = newWidth / newHeight;
                if (newWidth > newHeight) { newWidth = MAX_CANVAS_DIMENSION; newHeight = Math.floor(MAX_CANVAS_DIMENSION / aspectRatio); }
                else { newHeight = MAX_CANVAS_DIMENSION; newWidth = Math.floor(MAX_CANVAS_DIMENSION * aspectRatio); }
            }
            newWidth = Math.floor(newWidth); newHeight = Math.floor(newHeight);

            if (NovaRayEngine.canvas.width !== newWidth || NovaRayEngine.canvas.height !== newHeight) {
                NovaRayEngine.canvas.width = newWidth; NovaRayEngine.canvas.height = newHeight;
                if (NovaRayEngine.sceneManager) { NovaRayEngine.sceneManager.camera.aspect = NovaRayEngine.canvas.width / NovaRayEngine.canvas.height; }
                console.log(`Canvas resized to ${NovaRayEngine.canvas.width}x${NovaRayEngine.canvas.height}.`);
                if (NovaRayEngine.uiManager) NovaRayEngine.uiManager.setLoadingStatus(`Canvas resized to ${NovaRayEngine.canvas.width}x${NovaRayEngine.canvas.height}. Recreating textures...`);

                NovaRayEngine.context.configure({ device: NovaRayEngine.device, format: NovaRayEngine.presentationFormat, alphaMode: 'opaque', size: [NovaRayEngine.canvas.width, NovaRayEngine.canvas.height], });
                if (NovaRayEngine.outputTexture0) NovaRayEngine.outputTexture0.destroy(); if (NovaRayEngine.outputTexture1) NovaRayEngine.outputTexture1.destroy();
                NovaRayEngine.outputTexture0 = NovaRayEngine.resourceManager.createTexture({ size: { width: NovaRayEngine.canvas.width, height: NovaRayEngine.canvas.height }, format: 'rgba32float', usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT, }, "Output Texture 0 (Ping) - Resize");
                NovaRayEngine.outputTextureView0 = NovaRayEngine.outputTexture0.createView();
                NovaRayEngine.outputTexture1 = NovaRayEngine.resourceManager.createTexture({ size: { width: NovaRayEngine.canvas.width, height: NovaRayEngine.canvas.height }, format: 'rgba32float', usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT, }, "Output Texture 1 (Pong) - Resize");
                NovaRayEngine.outputTextureView1 = NovaRayEngine.outputTexture1.createView();

                if (NovaRayEngine.computePipeline && NovaRayEngine.renderPipeline) { NovaRayEngine.createComputeBindGroups(); NovaRayEngine.createRenderBindGroup(); }
                else { console.warn("Pipelines not yet ready on NovaRayEngine during resize, deferring bind group creation."); }
                if (NovaRayEngine.sceneManager) { NovaRayEngine.sceneManager.updateCameraUniformBuffer(); NovaRayEngine.sceneManager.updateRaytracerParamsUniformBuffer(); }
                NovaRayEngine.resetAccumulation();
            }
        }

        // Performance tracking variables, local to this script block for renderLoop
        let lastFpsUpdateTime = 0;
        let lastFrameTime = 0;

        /**
         * The main rendering loop for NovaRay.
         * Handles camera updates, UBO updates, dispatching compute and render passes,
         * and FPS counting. Relies on NovaRayEngine for state and resources.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function renderLoop(currentTime) {
            if (!NovaRayEngine.device || NovaRayEngine.device.lost || !NovaRayEngine.canvas || !NovaRayEngine.context || !NovaRayEngine.computePipeline || !NovaRayEngine.renderPipeline) {
                console.error("NovaRayEngine core components not ready or device lost. Stopping render loop.");
                if (NovaRayEngine.device && NovaRayEngine.device.lost) {
                    NovaRayEngine.uiManager.displayErrorMessage("WebGPU device lost. Please try reducing settings and refresh.");
                }
                NovaRayEngine.animationFrameId = null;
                return; 
            }

            if (NovaRayEngine.uiManager.appState !== 'scene') {
                NovaRayEngine.animationFrameId = null;
                return;
            }

            const current_time_seconds = currentTime / 1000.0;
            const deltaTime = (current_time_seconds - lastFrameTime);
            lastFrameTime = current_time_seconds; 

            const moveSpeed = NovaRayEngine.sceneManager.camera.movementSpeed;
            let dx = 0, dy = 0, dz = 0;

            if (NovaRayEngine.keysPressed['w'] || NovaRayEngine.keysPressed['W'] || NovaRayEngine.keysPressed['ArrowUp']) {
                dx += NovaRayEngine.sceneManager.camera.forward[0] * moveSpeed;
                dy += NovaRayEngine.sceneManager.camera.forward[1] * moveSpeed;
                dz += NovaRayEngine.sceneManager.camera.forward[2] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed['s'] || NovaRayEngine.keysPressed['S'] || NovaRayEngine.keysPressed['ArrowDown']) {
                dx -= NovaRayEngine.sceneManager.camera.forward[0] * moveSpeed;
                dy -= NovaRayEngine.sceneManager.camera.forward[1] * moveSpeed;
                dz -= NovaRayEngine.sceneManager.camera.forward[2] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed['a'] || NovaRayEngine.keysPressed['A'] || NovaRayEngine.keysPressed['ArrowLeft']) {
                dx -= NovaRayEngine.sceneManager.camera.right[0] * moveSpeed;
                dz -= NovaRayEngine.sceneManager.camera.right[2] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed['d'] || NovaRayEngine.keysPressed['D'] || NovaRayEngine.keysPressed['ArrowRight']) {
                dx += NovaRayEngine.sceneManager.camera.right[0] * moveSpeed;
                dz += NovaRayEngine.sceneManager.camera.right[2] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed[' ']) {
                dy += NovaRayEngine.sceneManager.camera.up[1] * moveSpeed;
            }
            if (NovaRayEngine.keysPressed['Control'] || NovaRayEngine.keysPressed['control']) {
                dy -= NovaRayEngine.sceneManager.camera.up[1] * moveSpeed;
            }

            if (dx !== 0 || dy !== 0 || dz !== 0) {
                NovaRayEngine.sceneManager.moveCamera(dx, dy, dz);
            }

            NovaRayEngine.totalTime = (currentTime - NovaRayEngine.startTimeForTotalTime) / 1000.0;
            if (NovaRayEngine.accumulationNeedsReset) {
                NovaRayEngine.frameCount = 0;
                NovaRayEngine.accumulationNeedsReset = false;
            } else {
                NovaRayEngine.frameCount++;
            }
            NovaRayEngine.sceneManager.updateTimeUniformBuffer(NovaRayEngine.totalTime, NovaRayEngine.frameCount);

            NovaRayEngine.createComputeBindGroups();

            NovaRayEngine.device.pushErrorScope('validation');
            NovaRayEngine.device.pushErrorScope('internal');

            const commandEncoder = NovaRayEngine.device.createCommandEncoder();
            const computePassEncoder = commandEncoder.beginComputePass();
            computePassEncoder.setPipeline(NovaRayEngine.computePipeline);
            computePassEncoder.setBindGroup(0, NovaRayEngine.computeBindGroup0);
            computePassEncoder.setBindGroup(1, NovaRayEngine.computeBindGroup1);
            const workgroup_size_x = 8;
            const workgroup_size_y = 8;
            const dispatchX = Math.ceil(NovaRayEngine.canvas.width / workgroup_size_x);
            const dispatchY = Math.ceil(NovaRayEngine.canvas.height / workgroup_size_y);
            computePassEncoder.dispatchWorkgroups(dispatchX, dispatchY, 1);
            computePassEncoder.end();

            const textureView = NovaRayEngine.context.getCurrentTexture().createView();
            const renderPassDescriptor = {
                colorAttachments: [{
                    view: textureView, loadOp: 'clear', clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, storeOp: 'store',
                }],
            };
            const renderPass = commandEncoder.beginRenderPass(renderPassDescriptor);
            renderPass.setPipeline(NovaRayEngine.renderPipeline);
            NovaRayEngine.createRenderBindGroup();
            renderPass.setBindGroup(0, NovaRayEngine.renderBindGroup);
            renderPass.setVertexBuffer(0, NovaRayEngine.renderQuadVertexBuffer);
            renderPass.draw(6);
            renderPass.end();

            NovaRayEngine.device.queue.submit([commandEncoder.finish()]);

            NovaRayEngine.device.popErrorScope().then((error) => {
                if (error) { console.error('WebGPU Error (internal scope):', error); NovaRayEngine.uiManager.displayErrorMessage(\`WebGPU Internal Error: \${error.message}\`); }
            });
            NovaRayEngine.device.popErrorScope().then((error) => {
                if (error) { console.error('WebGPU Error (validation scope):', error); NovaRayEngine.uiManager.displayErrorMessage(\`WebGPU Validation Error: \${error.message}\`); }
            });
            
            if (currentTime - lastFpsUpdateTime >= 1000) {
                const currentFps = (NovaRayEngine.frameCount / ((currentTime - lastFpsUpdateTime)/1000.0));
                NovaRayEngine.uiManager.updateFPSCounter(currentFps);
                lastFpsUpdateTime = currentTime;
            }

            NovaRayEngine.currentTextureIndex = 1 - NovaRayEngine.currentTextureIndex;

            NovaRayEngine.animationFrameId = requestAnimationFrame(renderLoop);
        }

        /** Starts the main render loop and initializes timing variables. */
        function startRenderLoop() {
            NovaRayEngine.totalTime = 0;
            NovaRayEngine.frameCount = 0;
            NovaRayEngine.currentTextureIndex = 0;
            NovaRayEngine.accumulationNeedsReset = true;
            NovaRayEngine.startTimeForTotalTime = performance.now();
            lastFrameTime = performance.now() / 1000.0;
            lastFpsUpdateTime = performance.now();


            if (!NovaRayEngine.animationFrameId) {
                NovaRayEngine.animationFrameId = requestAnimationFrame(renderLoop);
            }
        }

        window.onload = () => {
            // Global NovaRayEngine is already defined as an object literal.
            // UIManager needs to be instantiated and initialized.
            if (!NovaRayEngine.uiManager) {
                 NovaRayEngine.uiManager = new UIManager(NovaRayEngine);
                 NovaRayEngine.uiManager.initDOMElements();
                 NovaRayEngine.uiManager.initEventListeners();
            }
            NovaRayEngine.uiManager.switchView('menu');
            
            // Initialize NovaRayEngine state properties
            NovaRayEngine.totalTime = 0;
            NovaRayEngine.frameCount = 0;
            NovaRayEngine.currentTextureIndex = 0;
            NovaRayEngine.animationFrameId = null;
            NovaRayEngine.keysPressed = {};
            NovaRayEngine.isMouseDown = false;
            NovaRayEngine.lastMouseX = 0;
            NovaRayEngine.lastMouseY = 0;
            NovaRayEngine.accumulationNeedsReset = true;

        };
    </script>
</body>
</html>
